<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法笔记</title>
    <link href="/2021/08/13/AlgorithmNotes/"/>
    <url>/2021/08/13/AlgorithmNotes/</url>
    
    <content type="html"><![CDATA[<h3 id="Problems-to-be-solve"><a href="#Problems-to-be-solve" class="headerlink" title="Problems to be solve:"></a>Problems to be solve:</h3><p><a href="https://zhuanlan.zhihu.com/p/93647900/">并查集，洛谷P1551</a><br><a href="https://github.com/gatieme/CodingInterviews">剑指offer</a></p><h1 id="Notebook-for-Algorithm-Ploblems"><a href="#Notebook-for-Algorithm-Ploblems" class="headerlink" title="Notebook for Algorithm Ploblems"></a>Notebook for Algorithm Ploblems</h1><hr><p>分类参考：<br><a href="https://books.halfrost.com/leetcode/ChapterTwo/Linked_List/">https://books.halfrost.com/leetcode/ChapterTwo/Linked_List/</a></p><h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul><li><a href="">0. TEMPLATE</a></li><li><a href="#146-lru-cache">### 146. LRU Cache</a></li><li><a href="#nc61-两数之和">NC61 两数之和</a></li><li><a href="#jz40-最小的k个数">JZ40 最小的K个数</a></li><li><a href="#jz30-包含min函数的栈">JZ30 包含min函数的栈</a></li><li><a href="#jz35-复杂链表的复制">JZ35 复杂链表的复制</a></li><li><a href="#jz31-栈的压入弹出序列">JZ31 栈的压入、弹出序列</a></li><li><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</a></li><li><a href="#114-flatten-binary-tree-to-linked-list">114. Flatten Binary Tree to Linked List</a></li><li><a href="#110-balanced-binary-tree">110. Balanced Binary Tree</a></li><li><a href="#2-add-two-numbers">2. Add Two Numbers</a></li><li><a href="#82-remove-duplicates-from-sorted-list-ii">82. Remove Duplicates from Sorted List II</a></li><li><a href="#99-recover-binary-search-tree">99. Recover Binary Search Tree</a></li><li><a href="#341-flatten-nested-list-iterator">341. Flatten Nested List Iterator</a></li><li><a href="#p1014-noip1999-普及组-cantor-表">P1014.Cantor表</a></li></ul><hr><h3 id="0-TEMPLATE"><a href="#0-TEMPLATE" class="headerlink" title="0. TEMPLATE"></a>0. TEMPLATE</h3><p><a href="https://links_to_the_ploblem.com">https://links_to_the_ploblem.com</a></p><p>date: 20xx/xx/xx</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">SOLUTION!<br></code></pre></div></td></tr></table></figure><p>comment:<br><br>你的心得blablabla</p><h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h3><p><a href="https://leetcode.com/problems/lru-cache/submissions/">https://leetcode.com/problems/lru-cache/submissions/</a></p><p>date: 2021/10/27</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 这里typedef AA&lt;B&gt; C可以理解成用C作为AA&lt;B&gt;的别名</span><br>    <span class="hljs-keyword">typedef</span> list&lt;<span class="hljs-keyword">int</span>&gt; LI; <span class="hljs-comment">//维护一个list,存储的是key信息</span><br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, LI::iterator&gt; PII; <span class="hljs-comment">//桥接hashmap和list，其实也可以省略这一步，直接unordered_map&lt;int, &lt;int, LI::iterator&gt;&gt;</span><br>    <span class="hljs-keyword">typedef</span> unordered_map&lt;<span class="hljs-keyword">int</span>, PII&gt; HTPII;<span class="hljs-comment">//&lt;key, pair&lt;value, list&gt;&gt;</span><br>    <br>    LI history;<br>    HTPII map;<br>    <span class="hljs-keyword">int</span> _capacity;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">touch</span><span class="hljs-params">(HTPII::iterator it)</span></span>&#123;<br>        <span class="hljs-comment">// it: &lt;int, PII&gt;</span><br>        <span class="hljs-keyword">int</span> key = it-&gt;first;<br>        history.<span class="hljs-built_in">erase</span>(it-&gt;second.second);<br>        history.<span class="hljs-built_in">push_front</span>(key);<br>        <span class="hljs-comment">//记得更新map的对应history的内容!</span><br>        it-&gt;second.second = history.<span class="hljs-built_in">begin</span>();<br>    &#125;    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity):_capacity(capacity) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-keyword">if</span>(it == map.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">touch</span>(it);<br>        <span class="hljs-keyword">return</span> map[key].first;<br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(key);<br>        <span class="hljs-comment">// 先更新一下key的历史记录</span><br>        <span class="hljs-keyword">if</span>(it != map.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-built_in">touch</span>(it);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">size</span>() == _capacity)&#123;<br>                map.<span class="hljs-built_in">erase</span>(history.<span class="hljs-built_in">back</span>()); <span class="hljs-comment">//history.back()是一个key值</span><br>                history.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            history.<span class="hljs-built_in">push_front</span>(key);<br>        &#125;<br>        <span class="hljs-comment">//然后存value</span><br>        map[key] = &#123;value, history.<span class="hljs-built_in">begin</span>()&#125;;<br>    &#125;  <br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p>comment:<br><br><a href="https://leetcode.com/problems/lru-cache/discuss/45976/C%2B%2B11-code-74ms-Hash-table-%2B-List">https://leetcode.com/problems/lru-cache/discuss/45976/C%2B%2B11-code-74ms-Hash-table-%2B-List</a><br><br>idea是维护一个list（也就是双向链表），和一个hash表。<br><br>对于哈希表中的每一个key，他都对应一组pair<value, iter_of_list>，然后每次touch这个key之后都要在list（list的值存的就是key）中更新历史<br><br>这里补充一下list和vector的区别：<br></p><ul><li>如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</li><li>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</li></ul><h3 id="NC61-两数之和"><a href="#NC61-两数之和" class="headerlink" title="NC61 两数之和"></a>NC61 两数之和</h3><p><a href="https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=117&amp;&amp;tqId=37756&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high/question-ranking">https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=117&amp;&amp;tqId=37756&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high/question-ranking</a></p><p>date: 2021/10/19</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; numbers.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">find</span>(target - numbers[i]) != m.<span class="hljs-built_in">end</span>())<br>                <span class="hljs-comment">//没找到：返回unordered_map::end</span><br>                <span class="hljs-keyword">return</span>&#123;m[target-numbers[i]], i+<span class="hljs-number">1</span>&#125;;<br>            m[numbers[i]] = i+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br>绝了，用hash map来做</p><h3 id="JZ40-最小的K个数"><a href="#JZ40-最小的K个数" class="headerlink" title="JZ40 最小的K个数"></a>JZ40 最小的K个数</h3><p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=23263&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking">https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=23263&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking</a></p><p>date: 2021/10/18</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; output;<br>        output = <span class="hljs-built_in">SelectSort</span>(input, k);<br>        output = <span class="hljs-built_in">QuickSort</span>(input, k);<br>        output = <span class="hljs-built_in">MinHeap</span>(input, k);<br>        <br>        <br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>    <span class="hljs-comment">//选择排序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">SelectSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> min = input[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> temp, i, count;<br>        <span class="hljs-keyword">for</span>(count=<span class="hljs-number">0</span>;count&lt;k;count++)&#123;<br>            <span class="hljs-keyword">for</span>(i=count+<span class="hljs-number">1</span>;i&lt;input.<span class="hljs-built_in">size</span>();i++)&#123;<br>                <span class="hljs-keyword">if</span>(input[i]&lt;input[count])&#123;<br>                    temp = input[count];<br>                    input[count] = input[i];<br>                    input[i] = temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(&amp;input[<span class="hljs-number">0</span>],&amp;input[k])</span></span>;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br>    <span class="hljs-comment">// 快排</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-built_in">sort</span>(input.<span class="hljs-built_in">begin</span>(),input.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; out;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            out.<span class="hljs-built_in">push_back</span>(input[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br>    <span class="hljs-comment">// 最小堆</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">MinHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; input, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(!input.<span class="hljs-built_in">size</span>()||input.<span class="hljs-built_in">size</span>()&lt;k) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// less&lt;int&gt;() 是大顶堆，greater&lt;int&gt;() 是小顶堆，默认大顶堆</span><br>        <span class="hljs-built_in">make_heap</span>(input.<span class="hljs-built_in">begin</span>(),input.<span class="hljs-built_in">end</span>(),greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-comment">//最小的元素在堆顶</span><br>            res.<span class="hljs-built_in">push_back</span>(input[<span class="hljs-number">0</span>]);<br>            <span class="hljs-comment">//以下两个方法均可：</span><br>            <span class="hljs-comment">//1.清除它，然后重新建立堆：</span><br>            <span class="hljs-comment">//(疑问：sort_heap一次之后堆应该就无效了，不如直接sort完取前k个)</span><br>            <span class="hljs-comment">//input.erase(input.begin());</span><br>            <span class="hljs-comment">//sort_heap(input.begin(),input.end());</span><br>            <span class="hljs-comment">//2.或者直接从堆中弹出这个元素，用堆的弹出函数</span><br>            <span class="hljs-built_in">pop_heap</span>(input.<span class="hljs-built_in">begin</span>(),input.<span class="hljs-built_in">end</span>(),greater&lt;<span class="hljs-keyword">int</span>&gt;());<br>            input.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//vector删除末尾元素(前面的堆已经默认最后的元素被删了)</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br>三种方式：选择排序，快速排序和最小堆（最小堆感觉挺神奇的）<br><br>最小堆的使用：<a href="https://www.cnblogs.com/woxiaosade/p/10628388.html">https://www.cnblogs.com/woxiaosade/p/10628388.html</a></p><h3 id="JZ70-矩形覆盖"><a href="#JZ70-矩形覆盖" class="headerlink" title="JZ70 矩形覆盖"></a>JZ70 矩形覆盖</h3><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=23283&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=23283&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking</a></p><p>date: 2021/10/17</p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2<em>n的大矩形，从同一个方向看总共有多少种不同的方法？<br><br>比如n=3时，2</em>3的矩形块有3种不同的覆盖方法(从同一个方向看)：<br><br><img src="/img/pics/jz70.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        动态规划：</span><br><span class="hljs-comment">        n = 1:1种</span><br><span class="hljs-comment">        只能竖着放；</span><br><span class="hljs-comment">        n = 2：2种</span><br><span class="hljs-comment">        =和||，两种方式，这两种将作为接下来的基础</span><br><span class="hljs-comment">        n = 3：3=1+2种</span><br><span class="hljs-comment">        当最左边选择=时，余下n=1---&gt;1种</span><br><span class="hljs-comment">        当最左边选择|时，余下n=2---&gt;2种</span><br><span class="hljs-comment">        n = 4:5=2+3</span><br><span class="hljs-comment">        当最左边选择=时，余下n=2---&gt;2种</span><br><span class="hljs-comment">        当最左边选择|时，余下n=3---&gt;3种</span><br><span class="hljs-comment">        **类似斐波那契数列**</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-keyword">int</span> prev = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> post = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> temp;<br>        <span class="hljs-keyword">while</span>(number<span class="hljs-number">-2</span>)&#123;<br>            temp = prev+post;<br>            post = prev;<br>            prev = temp;<br>            number--;<br>        &#125;<span class="hljs-keyword">return</span> prev;<br>        <br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br>有点像找规律。。推出前面的关系，后边的决策和前边有关，这就是动态规划的思想吧</p><h3 id="JZ30-包含min函数的栈"><a href="#JZ30-包含min函数的栈" class="headerlink" title="JZ30 包含min函数的栈"></a>JZ30 包含min函数的栈</h3><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=23268&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking">https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=23268&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking</a></p><p>date: 2021/10/17</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">stack&lt;<span class="hljs-keyword">int</span>&gt; stk;<br>stack&lt;<span class="hljs-keyword">int</span>&gt; minHelper;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    stk.<span class="hljs-built_in">push</span>(value);<br>    <span class="hljs-keyword">if</span>(!minHelper.<span class="hljs-built_in">size</span>() || value &lt;= minHelper.<span class="hljs-built_in">top</span>())&#123;<br>        minHelper.<span class="hljs-built_in">push</span>(value);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">top</span>() == minHelper.<span class="hljs-built_in">top</span>())&#123;<br>        stk.<span class="hljs-built_in">pop</span>();<br>        minHelper.<span class="hljs-built_in">pop</span>();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> minHelper.<span class="hljs-built_in">top</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br> 看到这个问题, 我们最开始可能会想, 添加一个成员变量用于保存最小元素, 每次压栈时如果压栈元素比当前最小元素更小, 就更新最小元素.<br> 但是这样会有一个问题, 如果最小元素被弹出了呢, 如何获得下一个最小元素呢? 分析到这里可以发现, 仅仅添加一个成员变量存放最小元素是不够的, 我们需要在最小元素弹出后还能得到次小元素, 次小的弹出后, 还要能得到次次小的.<br> 因此, 用另一个栈来保存这些元素是再合适不过的了. 我们叫它<strong>最小元素栈</strong>.<br> 每次压栈操作时, 如果压栈元素比当前最小元素更小, 就把这个元素压入最小元素栈, 原本的最小元素就成了次小元素. 同理, 弹栈时, 如果弹出的元素和最小元素栈的栈顶元素相等, 就把最小元素的栈顶弹出.</p><h3 id="JZ35-复杂链表的复制"><a href="#JZ35-复杂链表的复制" class="headerlink" title="JZ35 复杂链表的复制"></a>JZ35 复杂链表的复制</h3><p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=23254&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking">https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=23254&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking</a></p><p>date: 2021/10/17</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*解题思路：</span><br><span class="hljs-comment">*1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span><br><span class="hljs-comment">*2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span><br><span class="hljs-comment">*3、拆分链表，将链表拆分为原链表和复制后的链表</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        RandomListNode* currentNode = pHead;<br>        <span class="hljs-comment">//1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span><br>        <span class="hljs-keyword">while</span>(currentNode != <span class="hljs-literal">NULL</span>)&#123;<br>            RandomListNode* cloneNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(currentNode-&gt;label);<br>            RandomListNode* nextNode = currentNode-&gt;next;<br>            currentNode-&gt;next = cloneNode;<br>            cloneNode-&gt;next = nextNode;<br>            currentNode = nextNode;<br>        &#125;<br>        currentNode = pHead;<br>        <br>        <span class="hljs-comment">//2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span><br>        <span class="hljs-keyword">while</span>(currentNode != <span class="hljs-literal">NULL</span>)&#123;<br>            currentNode-&gt;next-&gt;random = currentNode-&gt;random==<span class="hljs-literal">NULL</span>?<span class="hljs-literal">NULL</span>:currentNode-&gt;random-&gt;next; <span class="hljs-comment">//妙啊</span><br>            currentNode = currentNode-&gt;next-&gt;next;<br>        &#125;<br>        <br>        currentNode = pHead;<br>        RandomListNode* pCloneHead = pHead-&gt;next;<br><br>        <span class="hljs-comment">//3、拆分链表，将链表拆分为原链表和复制后的链表</span><br>        <span class="hljs-keyword">while</span>(currentNode)&#123;<br>            RandomListNode* cloneNode = currentNode-&gt;next;<br>            currentNode-&gt;next = cloneNode-&gt;next;<br>            cloneNode-&gt;next = cloneNode-&gt;next==<span class="hljs-literal">NULL</span>?<span class="hljs-literal">NULL</span>:cloneNode-&gt;next-&gt;next;<br>            currentNode = currentNode-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> pCloneHead;<br>        <br>    &#125;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>comment:<br><br><img src="/img/pics/complexlistnodecopy.png" alt=""></p><h3 id="JZ31-栈的压入、弹出序列"><a href="#JZ31-栈的压入、弹出序列" class="headerlink" title="JZ31 栈的压入、弹出序列"></a>JZ31 栈的压入、弹出序列</h3><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=23290&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=23290&amp;ru=/ta/sql-quick-study&amp;qru=/ta/sql-quick-study/question-ranking</a></p><p>date: 2021/10/06<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pushV,vector&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;pushV.<span class="hljs-built_in">size</span>())&#123;<br>            temp.<span class="hljs-built_in">push</span>(pushV[i]);<br>            <span class="hljs-keyword">while</span>(temp.<span class="hljs-built_in">size</span>()&amp;&amp;temp.<span class="hljs-built_in">top</span>()==popV[j])&#123;<br>                j++;<br>                temp.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!temp.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><br>comment:<br><br>之前一直把栈的输入输出原则搞错了。。实际上，栈并不是一定要满了才取出最顶上的元素，随时都可以取出，只要满足FILO即可，因此对于输入序列[1,2,3,4,5]，可以有[3,5,4,2,1]的输出顺序：[1]-&gt;[1,2]-&gt;[1,2,3]-&gt;[1,2]3-&gt;[1,2,4]3-&gt;[1,2,4,5]3-&gt;[1,2,4]3,5-&gt;[1,2]3,5,4-&gt;[]3,5,4,2,1<br><br>解题思路之一可以是模仿这一过程，借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。举例：入栈1,2,3,4,5 出栈4,5,3,2,1 首先1入辅助栈，此时栈顶1≠4，继续入栈2 此时栈顶2≠4，继续入栈3 此时栈顶3≠4，继续入栈4 此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3此时栈顶3≠5，继续入栈5此时栈顶5=5，出栈5, 弹出序列向后一位，此时为3，,辅助栈里面是1,2,3….依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p><h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/">https://links_to_the_ploblem.com</a></p><p>date: 2021/10/16</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootIdx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, inorder, rootIdx, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span>&amp; rootIdx, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">int</span> pivot = left;  <span class="hljs-comment">// find the root from inorder</span><br>        <span class="hljs-keyword">while</span>(inorder[pivot] != preorder[rootIdx]) pivot++;<br>        <br>        rootIdx++;<br>        TreeNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(inorder[pivot]);<br>        newNode-&gt;left = <span class="hljs-built_in">build</span>(preorder, inorder, rootIdx, left, pivot<span class="hljs-number">-1</span>);<br>        newNode-&gt;right = <span class="hljs-built_in">build</span>(preorder, inorder, rootIdx, pivot+<span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br>前序中序重建二叉树<br><br><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/340504/C%2B%2B-simple-recursive-(%2B-detail-explanation">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/340504/C%2B%2B-simple-recursive-(%2B-detail-explanation</a>)</p><h3 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h3><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p><p>date: 2021/10/12</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    TreeNode* prev=<span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        一个想法是，对树进行先序遍历，然后把遍历的历史记录下来，再make一颗对应的树。但是这种方法很傻；</span><br><span class="hljs-comment">        考虑到先序递归的节点遍历顺序是1 2 3 4 5 6，那么将其reverse，期待能够有6 5 4 3 2 1的遍历顺序，</span><br><span class="hljs-comment">        再相应地将他们的left设为Null，right设为前一个节点即可。</span><br><span class="hljs-comment">        抽象思考一下，就像是一根弹性绳被拉到最末端，然后再逐节处理回来</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-built_in">flatten</span>(root-&gt;right);<br>        <span class="hljs-built_in">flatten</span>(root-&gt;left); <br>        <br>        <span class="hljs-comment">//Let&#x27;s do something</span><br>        root-&gt;left = <span class="hljs-literal">NULL</span>;<br>        root-&gt;right = prev; <span class="hljs-comment">//这里prev的赋值是递归的关键</span><br>        prev = root;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/36977/My-short-post-order-traversal-Java-solution-for-share">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/36977/My-short-post-order-traversal-Java-solution-for-share</a><br>这题把递归用得好巧妙啊</p><h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h3><p><a href="https://leetcode.com/problems/balanced-binary-tree/">https://leetcode.com/problems/balanced-binary-tree/</a></p><p>date: 2021/10/09</p><p><strong>二叉树层序遍历标准方法：使用递归（感觉对于树，经常会用到递归呃）</strong><br><br>有两种方法：</p><ol><li>根据定义：该节点的左子树高和右子树高相差不大于一；左子树也是平衡二叉树；右子树也是平衡二叉树。不得不说，递归真的妙啊。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">depth</span>(root-&gt;right);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right) + <span class="hljs-number">1</span>;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">int</span> left_depth = <span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right_depth = <span class="hljs-built_in">depth</span>(root-&gt;right);<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left_depth - right_depth)&lt;=<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp;  <span class="hljs-built_in">isBalanced</span>(root-&gt;right);        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ol><li>使用DFS。碰到高度差大于1的直接复制-1，并不断传递到最上层。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfsHeight</span> <span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">int</span> leftHeight = <span class="hljs-built_in">dfsHeight</span> (root -&gt; left);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> rightHeight = <span class="hljs-built_in">dfsHeight</span> (root -&gt; right);<br>        <span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span> (leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfsHeight</span> (root) != <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>comment:<br><br><a href="https://leetcode.com/problems/balanced-binary-tree/discuss/35691/The-bottom-up-O(N)-solution-would-be-better">https://leetcode.com/problems/balanced-binary-tree/discuss/35691/The-bottom-up-O(N)-solution-would-be-better</a></p><h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h3><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p><p><strong>[LEETCODE] [Medium] [LinkedList] </strong></p><p>date: 2021/08/14</p><blockquote><p>description:</p><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.<br>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p></blockquote><p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Input: l1 = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>], l2 = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]<br>Output: [<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>]<br>Explanation: <span class="hljs-number">342</span> + <span class="hljs-number">465</span> = <span class="hljs-number">807.</span><br></code></pre></div></td></tr></table></figure><br>Answer1:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        这里有一个小Point，如果要同时新建多个结构体指针，你可以：</span><br><span class="hljs-comment">        1. ListNode *prev=NULL, *cloneHead=NULL, *clone;或者</span><br><span class="hljs-comment">        2. ListNode* prev=NULL, *cloneHead=NULL, *clone;也就是第一个prev不用加*，但之后的都要，</span><br><span class="hljs-comment">        就是不能：</span><br><span class="hljs-comment">        x. ListNode* prev=NULL, cloneHead=NULL, clone;或者</span><br><span class="hljs-comment">        x. ListNode* *prev=NULL, *cloneHead=NULL, *clone;这样第一个会变成**</span><br><span class="hljs-comment">        个人觉得还是1.这样定义比较容易理解一些。</span><br><span class="hljs-comment">        */</span><br>        ListNode *cur1 = l1, *cur2 = l2; <span class="hljs-comment">//加*代表结构体指针</span><br>        ListNode *prev=<span class="hljs-literal">NULL</span>, *cloneHead=<span class="hljs-literal">NULL</span>, *clone;<br>        <span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>, carry=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur1||cur2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur1&amp;&amp;cur2)&#123;<br>                s = cur1-&gt;val+cur2-&gt;val+carry;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!cur1)&#123;<br>                s = cur2-&gt;val+carry;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                s = cur1-&gt;val+carry;<br>            &#125;<br>            clone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(s%<span class="hljs-number">10</span>); <span class="hljs-comment">//s对10取余的值生成一个新结点</span><br>            <span class="hljs-keyword">if</span>(s&gt;=<span class="hljs-number">10</span>)&#123;<br>                carry = <span class="hljs-number">1</span>; <span class="hljs-comment">//进位</span><br>            &#125;<span class="hljs-keyword">else</span> carry=<span class="hljs-number">0</span>;<br>            <br>            <span class="hljs-comment">//接下来就是重要的链接部分了</span><br>            <span class="hljs-keyword">if</span>(!cloneHead)&#123;<br>                cloneHead = clone; <span class="hljs-comment">//若是表头，则直接链接到新生成的clone结点上</span><br>                prev = clone; <span class="hljs-comment">//这里prev指向的是和cloneHead**同一个**new出来的结点，因此后面只需延伸prev即可！</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                prev-&gt;next = clone; <span class="hljs-comment">//上一步new出来的那个结点的next指向新new出来的结点，创造链接</span><br>                prev = clone; <span class="hljs-comment">//prev指向新结点</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur1) cur1 = cur1-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur2) cur2 = cur2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry)&#123; <span class="hljs-comment">//循环之后，如果最后还有carry额外再加一位</span><br>            clone = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>            prev-&gt;next = clone;<br>            prev = clone;<br>        &#125;<br>        prev-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//结束链表</span><br>        <span class="hljs-keyword">return</span> cloneHead;<br>        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><br>Comment:</p><p>学完链表之后做（抄）的第一道题，虽然是Medium难度。抄完感觉对linked list的认识加深了，尤其是如何处理新增加结点和原结点之间的链接指向关系。</p><h3 id="P1014-NOIP1999-普及组-Cantor-表"><a href="#P1014-NOIP1999-普及组-Cantor-表" class="headerlink" title="P1014 [NOIP1999 普及组] Cantor 表"></a>P1014 [NOIP1999 普及组] Cantor 表</h3><p><a href="https://www.luogu.com.cn/problem/P1014">https://www.luogu.com.cn/problem/P1014</a></p><p><strong>[LUOGU] [模拟] [枚举，暴力]</strong></p><p>date: 2021/08/14</p><p>Answer1:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> N, a, b, odd, sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// a/b</span><br>cin &gt;&gt; N;<br><span class="hljs-comment">// 可以直接计算N对应的是第几个循环的</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>odd = i % <span class="hljs-number">2</span>; <span class="hljs-comment">//even=1则从上往下：1/4,2/3,...</span><br>sum = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (odd) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>a = <span class="hljs-number">1</span> + j;<br>b = i - j;<br>count++;<br><span class="hljs-keyword">if</span> (count == N) &#123;<br>cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; a &lt;&lt; endl;<br><span class="hljs-keyword">goto</span> outloop;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>b = <span class="hljs-number">1</span> + j;<br>a = i - j;<br>count++;<br><span class="hljs-keyword">if</span> (count == N) &#123;<br>cout &lt;&lt; b &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>outloop:<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>Comment:</p><p>是入门难度的题，虽然还是做了挺久。。。题目本身似乎没有什么技巧，只要找到规律模拟就行了。虽然很简单，但是还是贴上来纪念一下，毕竟万事开头难，希望将来能够坚持下去，不要再放弃了。</p><h3 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a>82. Remove Duplicates from Sorted List II</h3><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p><p><strong>[LEETCODE] [Medium] [LinkedList]</strong></p><p>date: 2021/08/16</p><blockquote><p>Description:</p><p>Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.</p></blockquote><p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Input: head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>Output: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br>Input: head = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>Output: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure></p><p>Answer1:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// sentinel Head, 即人为在链表前面添加一个value=0的头，以避免[1，1，1，1]这种edge case.</span><br>        ListNode *sentinel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head); <span class="hljs-comment">//包含虚表头的完整链表</span><br>        <br>        <span class="hljs-comment">// Predecessor = the last node outside the sublist of duplicates</span><br>        ListNode *pred = sentinel;<br>        <br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)<br>            &#123;<br>                <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;next &amp;&amp; head-&gt;val == (head-&gt;next)-&gt;val)&#123;<br>                    head = head-&gt;next;<br>                &#125;<br>                pred-&gt;next = head-&gt;next; <span class="hljs-comment">//注意，这里只是给next赋值，pred本身并没有动，这样即使next是另外一列duplicate也没事</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                pred = pred-&gt;next; <span class="hljs-comment">//前方没有duplicate，可以前移</span><br>            &#125;<br>            head = head-&gt;next; <span class="hljs-comment">//这一步不放在else里是为了保证3344这种情况不会崩（pred不会在34交汇处就前进）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> sentinel-&gt;next; <span class="hljs-comment">//这里又忽略了虚表头，这样若输入是[1,1,1]，加入虚表头后[0,1,1,1]，计算完[0,&#x27;null&#x27;]，最终返回则是[‘null] </span><br>    &#125;<br>    <br>&#125;;<br></code></pre></div></td></tr></table></figure><br>comment:</p><p>这一题是83题(Remove Duplicates from Sorted List)的加强版本，相较于83题（碰到重复的子列只需保留一个，比如[1,2,3,3,4,4,5]-&gt;[1,2,3,4,5]）这一题要求完全删去重复的子列，得到[1,2,5]。这在碰到极端情况时（比如[1,1,1,1]-&gt;[]）就特别难处理，用83题的方法时就得考虑很多的if，尤其是表头也属于重复子列的情况。非常丢脸，这道题前后卡了起码两个小时。。。后来还是看了solution。<br/><br>Solution中也特意点出了[1，1，1，1]这种edge case，但是它用了一个极为巧妙的方法，就是设定一个 pseudo-head伪表头，值为0且链接指向input的链表的表头，这样就规避了输入样例中[1，1，1，1]这样棘手的情况，具体分析如下： <br/><br>sentinel意为哨兵，在这里是一个虚的表头，可以从代码看到它接在input的链表前面<br/><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// sentinel Head, 即人为在链表前面添加一个value=0的头，以避免[1，1，1，1]这种edge case.</span><br>ListNode *sentinel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head); <span class="hljs-comment">//包含虚表头的完整链表</span><br></code></pre></div></td></tr></table></figure><br>然后也创建了一个pred，代表重复子列前的最新一个结点。（在后面很巧妙的保证了它不会等于重复子列中的元素）<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// Predecessor = the last node outside the sublist of duplicates</span><br>ListNode *pred = sentinel;<br></code></pre></div></td></tr></table></figure><br>在这个while循环中，尤其要注意当head从重复子列出来时，pred只是把它的next连接到head-&gt;next，pred结点本身是没有更新的，这样在碰到[1,2,2,4,4]的情况就不会出现pred=4的错误。甚至，由于只是pred-&gt;next而不是pred本身改变，在head遍历到NULL时将会自动pred-&gt;next = NULL，非常方便。<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;next &amp;&amp; head-&gt;val == (head-&gt;next)-&gt;val)&#123;<br>    head = head-&gt;next;<br>&#125;<br>pred-&gt;next = head-&gt;next; <span class="hljs-comment">//注意，这里只是给next赋值，pred本身并没有动，这样即使next是另外一列duplicate也没事</span><br>&#125;<br></code></pre></div></td></tr></table></figure><br><img src="pics/leetcodeP82.png" alt=""><br>早知道就早点看题解了，浪费了挺多时间的。。。做这些题主要还是熟练链表的操作，下次应该限时。</p><h3 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341. Flatten Nested List Iterator"></a>341. Flatten Nested List Iterator</h3><p><a href="https://leetcode.com/problems/flatten-nested-list-iterator/">https://leetcode.com/problems/flatten-nested-list-iterator/</a></p><p><strong>[LEETCODE] [Medium] [stack] [queue]</strong></p><p>date: 2021/08/31</p><blockquote><p>Description:</p><p>You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.<br>Implement the NestedIterator class:<br>NestedIterator(List&lt; NestedInteger &gt; nestedList) Initializes the iterator with the nested list nestedList.<br>int next() Returns the next integer in the nested list.<br>boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.</p></blockquote><p>Example:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Input: nestedList = [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],<span class="hljs-number">2</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>Output: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>Explanation: By calling next repeatedly until hasNext returns <span class="hljs-literal">false</span>, the order of elements returned by next should be: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].<br></code></pre></div></td></tr></table></figure></p><p>Answer:<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is the interface that allows for creating nested lists.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * class NestedInteger &#123;</span><br><span class="hljs-comment"> *   public:</span><br><span class="hljs-comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span><br><span class="hljs-comment"> *     bool isInteger() const;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span><br><span class="hljs-comment"> *     // The result is undefined if this NestedInteger holds a nested list</span><br><span class="hljs-comment"> *     int getInteger() const;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span><br><span class="hljs-comment"> *     // The result is undefined if this NestedInteger holds a single integer</span><br><span class="hljs-comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// **这个回答运用了由指针构成的栈** </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestedIterator</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 这里stack的类型背后要加上 iterator，可能是要强调vector是可迭代的数据类型，否则下面begins和ends没法用 .push() 等操作</span><br>    stack&lt;vector&lt;NestedInteger&gt;::iterator&gt; begins, ends; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;<br>        begins.<span class="hljs-built_in">push</span>(nestedList.<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">// 注意，这里的begin和end是一个指针，指向nestedList的起始位置</span><br>        ends.<span class="hljs-built_in">push</span>(nestedList.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 这个指针指向终止位置+1！</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">hasNext</span>(); <span class="hljs-comment">//如果hasNext = True，那么这一句不会造成什么影响。</span><br>        <span class="hljs-keyword">return</span> (begins.<span class="hljs-built_in">top</span>()++)-&gt;<span class="hljs-built_in">getInteger</span>(); <span class="hljs-comment">//这里的顺序是先begins.top()-&gt;getInterger返回值,再begins.top()+=1</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(begins.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(begins.<span class="hljs-built_in">top</span>()==ends.<span class="hljs-built_in">top</span>())&#123; <span class="hljs-comment">//这里若一层的list循环完了（begin和end位置相等），则脱去当前这一层list嵌套。下面会有进一步解释</span><br>                begins.<span class="hljs-built_in">pop</span>();<br>                ends.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">auto</span> x = begins.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//这里的auto会根据元素自动为其定义类型</span><br>                <span class="hljs-keyword">if</span>(x-&gt;<span class="hljs-built_in">isInteger</span>())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//脱出该while循环</span><br>                <br>                begins.<span class="hljs-built_in">top</span>()++; <span class="hljs-comment">//这里的top实际上是一个指针(位置信息)，因此这里是指向的位置+=1</span><br>                begins.<span class="hljs-built_in">push</span>(x-&gt;<span class="hljs-built_in">getList</span>().<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">//若指向的是嵌套list，则把这个嵌套list再加载到stack中进行处理</span><br>                ends.<span class="hljs-built_in">push</span>(x-&gt;<span class="hljs-built_in">getList</span>().<span class="hljs-built_in">end</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NestedIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NestedIterator i(nestedList);</span><br><span class="hljs-comment"> * while (i.hasNext()) cout &lt;&lt; i.next();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><br>comment:<br><br>这种需要自己构造一个类的题目是第一次碰到，而且他是完全建立在抽象的数据结构之上的，因此第一次着实有点摸不着头脑了。不过看了这个题解之后发现实际上就是根据给定的上一层的抽象数据结构的说明，构造更高一层的、调用前一层的数据类型的一个新数据类型。</p><p>举例子来说明这个代码的主要流程：</p><p><img src="pics/leetcode341.png" alt=""></p><p>只能说，脑子还不够灵光，想不到这么抽象的层面啊！</p><h3 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h3><p><a href="https://leetcode.com/problems/recover-binary-search-tree/">https://leetcode.com/problems/recover-binary-search-tree/</a></p><p><strong>[LEETCODE] [Medium] [tree]</strong></p><p>date: 2021/10/08<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    TreeNode* firstElement = <span class="hljs-literal">NULL</span>;<br>    TreeNode* secondElement = <span class="hljs-literal">NULL</span>;<br>    TreeNode* prevElement = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(INT_MIN);<br>    <span class="hljs-keyword">int</span> temp;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traverse</span>(root);<br>        <br>        temp = firstElement-&gt;val;<br>        firstElement-&gt;val = secondElement-&gt;val;<br>        secondElement-&gt;val = temp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span>(!firstElement &amp;&amp; prevElement-&gt;val &gt; root-&gt;val)&#123;<br>            firstElement = prevElement;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(firstElement &amp;&amp; prevElement-&gt;val &gt; root-&gt;val)&#123;<br>            secondElement = root;<br>        &#125;<br>        prevElement = root;<br>        <br>        <span class="hljs-built_in">traverse</span>(root-&gt;right);<br>    &#125;  <br>&#125;;<br></code></pre></div></td></tr></table></figure><br>comment:<br><br>直接看这个题解，简直无敌：<br><br><a href="https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal">https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal</a><br><br><br>需要推一下递归算法排查节点的顺序，就可以理解两个traverse之间的操作了。<br><br>不得不说，碰到树的题目时，递归还是爽啊。</p><h3 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h3><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p><p><strong>[LEETCODE] [Medium] [tree]</strong></p><p>date: 2021/10/09<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode* curr;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; output;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> output;<br>        <br>        que.<span class="hljs-built_in">push</span>(root);<br>        que.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//NULL is a marker.</span><br>        <br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            <br>            curr = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <br>            <span class="hljs-keyword">if</span>(curr!=<span class="hljs-literal">NULL</span>)&#123;<br>                temp.<span class="hljs-built_in">push_back</span>(curr-&gt;val);<br>                <span class="hljs-keyword">if</span>(curr-&gt;left) que.<span class="hljs-built_in">push</span>(curr-&gt;left);<br>                <span class="hljs-keyword">if</span>(curr-&gt;right) que.<span class="hljs-built_in">push</span>(curr-&gt;right);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                output.<span class="hljs-built_in">push_back</span>(temp);<br>                temp.<span class="hljs-built_in">resize</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//Clear.</span><br>                <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) que.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">//Iteratively add NULL marker to confine each level.</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><br>comment:<br><br>层序遍历的核心代码是很简单的，一个queue就行，这里的问题在于如何判断每一层的末尾，这里卡了好久。。。<br><br>最后还是看了别人的题解，这里用了一个类似递归的方法：在queue中，先在root后插入一个NULL作为标记，今后扫到这个NULL时（上层扫到NUUL那么下层应该也全部入队完毕了），在queue的末尾插入一个NULL，这样就可以自动重复下去了，只能说很妙。<br><br>注意插入NULL时要判断现在的queue是不是已经为空，否则会死循环，因为NULL本身是占据空间的。<br><br>PS:甚至不用这个NULL作为marker，直接用queue.size()即可，因为这个信息也是在最初可以直到的。</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记</title>
    <link href="/2021/08/10/DataStructure/"/>
    <url>/2021/08/10/DataStructure/</url>
    
    <content type="html"><![CDATA[<h1 id="Notebook-for-DataStructure"><a href="#Notebook-for-DataStructure" class="headerlink" title="Notebook for DataStructure"></a>Notebook for DataStructure</h1><hr><p><a href="https://blog.csdn.net/weixin_43751983/article/details/103411097">数据结构复习题</a></p><h2 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h2><h3 id="数据结构是什么？"><a href="#数据结构是什么？" class="headerlink" title="数据结构是什么？"></a>数据结构是什么？</h3><p>个人认为比较确切的定义：</p><blockquote><p>“数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定以相关的函数来给出。” —Sartaj Sahni, 《数据结构、算法与应用》</p></blockquote><h4 id="举例：如何摆放图书？"><a href="#举例：如何摆放图书？" class="headerlink" title="举例：如何摆放图书？"></a>举例：如何摆放图书？</h4><ul><li>随便放<ul><li>找书的时候累死</li></ul></li><li>按照书名的拼音字母顺序排放<ul><li>新书要如何插入？<ul><li>比如《阿Q正传》</li></ul></li><li>怎么找到指定的书？<ul><li>二分查找？</li></ul></li></ul></li><li>把书架分成几块，每块区域摆放指定类别的书；每种类别内按照拼音顺序排序<ul><li>新书怎么插入？<ul><li>先定类别，二分查找确定位置，<strong>移出空位</strong></li></ul></li><li>怎么找到某本指定的书？<ul><li>先定类别，再二分查找</li></ul></li><li>空间如何分配？类别应该分多细？</li></ul></li></ul><p><strong>解决问题的效率，跟数据的组织方式有关。</strong> </p><p>相较于循环算法，递归算法很占空间，效率很低。<br><!--补充二分法的知识--></p><p><strong>计时模板：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-comment">/* clock_t是clock()函数返回的变量类型*/</span><br><span class="hljs-keyword">clock_t</span> start,stop;<br><span class="hljs-keyword">double</span> duration;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    start = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">MyFunction</span>();<br>    stop = <span class="hljs-built_in">clock</span>();<br>    duration = ((<span class="hljs-keyword">double</span>)(stop - start))/CLK_TCK;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="数据对象的组织方式"><a href="#数据对象的组织方式" class="headerlink" title="数据对象的组织方式"></a>数据对象的组织方式</h4><ul><li>逻辑结构<ul><li>线性结构，一对一</li><li>树，一对多</li><li>图，多对多</li></ul></li><li>物理存储结构<ul><li>数组</li><li>链表</li></ul></li></ul><h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><ul><li>数据类型（面向对象语言中对象集和操作集是可以合并的，比如类）<ul><li>数据对象集</li><li>数据集合相关联的操作集</li></ul></li><li>抽象：<strong>描述</strong>数据类型的方法<strong>不依赖于具体实现</strong><ul><li>与存放的机器无关</li><li>与数据存储的物理结构无关</li><li>与实现操作的算法和编程语言无关</li></ul></li></ul><p><strong>只描述</strong>数据对象集和相关操作集<strong>是什么</strong>，并不涉及<strong>如何做到</strong>的问题。比如定义<strong>抽象</strong>数据类型：<code>ElementType</code>，之后在具体调用时只要<code>define ElementType xxx</code>即可，方便很多。</p><h3 id="算法是什么"><a href="#算法是什么" class="headerlink" title="算法是什么"></a>算法是什么</h3><h4 id="选择排序算法的伪码描述"><a href="#选择排序算法的伪码描述" class="headerlink" title="选择排序算法的伪码描述"></a>选择排序算法的伪码描述</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> List[],<span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*非递减排序*/</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;N;i++&gt;)&#123;<br>        MinPosition = <span class="hljs-built_in">ScanForMin</span>(List,i,N<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">/*找list中从i到N-1的index中的最小元，并将其index返回*/</span><br>        <span class="hljs-comment">/*注意，这里是伪码，List看起来很香数组，但是它也可以是链表*/</span><br>        Swap（List[i],List[MinPosition]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="什么是好的算法"><a href="#什么是好的算法" class="headerlink" title="什么是好的算法"></a>什么是好的算法</h4><ul><li>空间复杂度S(n)<ul><li>根据算法写成的程序在执行时<strong>占用存储单元的长度</strong></li><li>S(n)过高的算法可能导致内存超限，导致非正常中断</li><li>比如递归算法，为了执行下一个递归需暂存目前函数的状态，比如为了<code>PrintN(9999)</code>需要先暂存<code>PrintN(10000)</code>的状态，而为了<code>PrintN(9998)</code>又需要暂存<code>PrintN(9999)</code>的状态，以此递推，需要占用很大的空间来暂存状态，S(n) = C·N </li></ul></li><li>时间复杂度T(n)<ul><li>根据算法写成的程序在执行时<strong>耗费时间的长度</strong></li><li>T(n)过高可能导致有生之年都没法执行完程序</li><li>比如计算多项式的值，若使用简单的循环<code>p += (a[i] * pow(x,i))</code>则需要(1+2+···+n = C<sub>1</sub>·n<sup>2</sup>+C<sub>2</sub>·n 次乘法)</li></ul></li></ul><h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><div class="table-container"><table><thead><tr><th>函数</th><th>1</th><th>2</th><th>4</th><th>8</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>log n</td><td>0</td><td>1</td><td>2</td><td>3</td></tr><tr><td>n</td><td>1</td><td>2</td><td>4</td><td>8</td></tr><tr><td>n log n</td><td>0</td><td>2</td><td>8</td><td>24</td></tr><tr><td>n<sup>2</sup></td><td>1</td><td>4</td><td>6</td><td>64</td></tr><tr><td>2<sup>n</sup></td><td>2</td><td>4</td><td>16</td><td>256</td></tr><tr><td>n!</td><td>1</td><td>2</td><td>24</td><td>40326</td></tr></tbody></table></div><p><strong>复杂度分析窍门</strong></p><ul><li>对于加性的组合，算法复杂度取两个中最大的，T<sub>1</sub>+T<sub>2</sub> = max(O(f<sub>1</sub>(n)),O(f<sub>2</sub>(n)))</li><li>对于嵌套的组合（乘性），算法复杂度为两个的积的复杂度，T<sub>1</sub>xT<sub>2</sub> = O(f<sub>1</sub>(n)xf<sub>2</sub>(n))</li><li>若T(n)是关于n的k阶多项式，那么T(n)=O(n<sup>k</sup>)，也就是去最大的那一项</li><li>一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度</li><li>if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大</li></ul><h4 id="最大子列和"><a href="#最大子列和" class="headerlink" title="最大子列和"></a>最大子列和</h4><p>如下：</p><script type="math/tex; mode=display">f(i,j) = max(0,\Sigma_{k=i}^jA_k)</script><p>对于O(n<sup>2</sup>)的算法，应考虑是否能化成O(nlogn)</p><p><strong>分治法</strong>，分而治之</p><blockquote><p>把一个大而复杂的问题切分成小的块，并分别解决他们，最后再进行综合。</p></blockquote><hr><h2 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h2><h3 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h3><h4 id="多项式的表示"><a href="#多项式的表示" class="headerlink" title="多项式的表示"></a>多项式的表示</h4><ol><li><strong>顺序存储结构直接表示</strong><ul><li>值为系数，下标为指数</li><li>对于x+3x<sup>2000</sup>，则需要用2001个分量的数组来表示，效率很低</li><li>是否能只保存非零项？</li></ul></li><li><strong>顺序存储结构表示非零项</strong><ul><li>使用结构数组P<sub>1</sub>(x) = (a<sub>i</sub>,i),其中a<sub>i</sub>是系数，i是指数</li><li>为了计算方便，应按照指数大小有序存储</li><li>相加时只需从高到低分别滑动比较两个二元组的指数，copy指数更大的；若两个指数相同，则相加即可。</li></ul></li><li><p><strong>链表结构存储非零项</strong></p><ul><li>链表中每个<strong>结点</strong>存储多项式中的一个非零项，包括系数和指数两个数据域和一个指针域。</li></ul><p>| coef | expon | link |<br>| —— | ——- | —— |</p><p>定义一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span> *<span class="hljs-title">Polynominal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> coef;<br>    <span class="hljs-keyword">int</span> expon;<br>    Polynominal link;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="线性表，List"><a href="#线性表，List" class="headerlink" title="线性表，List"></a>线性表，List</h4><blockquote><p>由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p></blockquote></li></ol><ul><li>表中元素个数称为其长度</li><li>没有元素时，成为空表</li><li>起始位置是表头，结束位置是表尾</li></ul><h4 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h4><ul><li>类型名称：线性表（List）</li><li>数据对象集：线性表是n（&gt;=0）个元素构成的有序序列</li><li>操作集：对于L $\in$ List,整数i表示位置，元素X $\in$ ElementType，线性表基本操作如下：<ol><li>List MakeEmpty():返回一个初始化的空线性表</li><li>ElementType FindKth(int K, List L):返回第K位元素</li><li>int Find(ElementType X, List L):在L中查找X<strong>第一次</strong>出现的位置</li><li>void Insert(ElementType X, int i, List L):在第i位前插入X</li><li>void Delete(int i, List L):删除第i位元素</li><li>int Length(List L):返回长度</li></ol></li></ul><h4 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    <span class="hljs-comment">//这里定义一个数组Data，最大长度是MAXSIZE，元素类型是ElementType</span><br>    ElementType Data[MAXSIZE]<br>    <span class="hljs-comment">//我们还要知道这个数组的末端在哪里噢</span><br>    <span class="hljs-keyword">int</span> Last;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">L</span>;</span><span class="hljs-comment">//构建了一个结构体L</span><br>List PtrL;<span class="hljs-comment">//构建了一个结构体指针PtrL</span><br><br><span class="hljs-comment">//若要访问下标为i的元素，下面两种方法都可以：</span><br>L.Data[i];<span class="hljs-comment">//或者</span><br>PtrL-&gt;Data[i];<br><span class="hljs-comment">//若要访问线性表的长度，则：</span><br>L.Last+<span class="hljs-number">1</span>;<span class="hljs-comment">//或者</span><br>Ptrl-&gt;Last+<span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure><p>结构体和结构体指针的理解和使用：<br><a href="https://blog.csdn.net/weixin_36209467/article/details/82261286">https://blog.csdn.net/weixin_36209467/article/details/82261286</a></p><h4 id="线性表顺序存储的主要操作的实现"><a href="#线性表顺序存储的主要操作的实现" class="headerlink" title="线性表顺序存储的主要操作的实现"></a>线性表顺序存储的主要操作的实现</h4><p>（这里为什么要用结构体指针呢？可能是因为使用结构体进行操作的时候，比如作为函数参数，就要<strong>复制</strong>整个结构体，占内存？如果用指针，只需要复制4个字节（指针长度）即可，节省性能？）</p><ol><li>初始化<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">List <span class="hljs-title">MakeEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    List PtrL;<br>    PtrL = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct LNode));<span class="hljs-comment">//分配空间</span><br>    PtrL-&gt;Last = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> PtrL;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>查找<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=PtrL-&gt;Last&amp;&amp;Ptrl-&gt;Data[i]!=X)<br>        i++;<br>    <span class="hljs-keyword">if</span>(i&gt;PtrL-&gt;Last) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果没找到</span><br>    <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>插入<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//要先把每个元素往后挪</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X, <span class="hljs-keyword">int</span> i, List PrtL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">if</span>(PtrL-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表已经满了&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;PtrL-&gt;Last+<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=PtrL-&gt;Last;j&gt;=i<span class="hljs-number">-1</span>;j++)<br>        PtrL-&gt;Data[j+<span class="hljs-number">1</span>]=PtrL-&gt;Data[j];<br>    PtrL-&gt;Data[i<span class="hljs-number">-1</span>] = X;<br>    PtrL-&gt;Last++;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>删除<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    inr j;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;PtrL-&gt;Last+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素不存在&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=PtrL-&gt;Last;j++)<br>        PtrL-&gt;Data[j<span class="hljs-number">-1</span>]=PtrL-&gt;Data[j];<br>    PtrL-&gt;Last--;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="线性表链式存储的实现"><a href="#线性表链式存储的实现" class="headerlink" title="线性表链式存储的实现"></a>线性表链式存储的实现</h4><blockquote><p>只需逻辑上相邻，不需物理上相邻。通过<strong>链</strong>建立起数据元素之间的逻辑关系。<br>因此，插入或删除不需要移动元素，只需要修改<strong>链</strong>即可。</p></blockquote></li></ol><div class="table-container"><table><thead><tr><th>$\sigma_1$</th><th>-&gt;</th><th>$\sigma_2$</th><th>-&gt;</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><strong>链表定义</strong><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    ElementType Data;<br>    List Next<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">L</span>;</span><br>List PtrL;<br></code></pre></div></td></tr></table></figure></p><h4 id="链表主要操作的实现"><a href="#链表主要操作的实现" class="headerlink" title="链表主要操作的实现"></a>链表主要操作的实现</h4><ol><li>求表长<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p = PtrL; <span class="hljs-comment">//p指向链表的第一个结点</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-comment">//对链表进行一次遍历，当遍历到最后一个元素时，指针p=NULL，就会终止循环。</span><br>        p = p-&gt;Next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j++;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>查找<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//1.按序号查找</span><br><span class="hljs-function">List <span class="hljs-title">FindKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p = PtrL;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p !=NUll&amp;&amp; i&lt;K)&#123;<br>        p = p-&gt;Next;<span class="hljs-comment">//指向链表下一个</span><br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i == K)<br>         <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//找到第K个的指针值，返回p，否则返回空。</span><br>&#125;<br><br><span class="hljs-comment">//2.按值查找</span><br><span class="hljs-function">List <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p = PtrL;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;Data!=X)&#123;<br>        p=p-&gt;Next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>插入<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.先构造一个新结点，用s指向</span><br><span class="hljs-comment">2.再找到第i-1个结点，用p指向</span><br><span class="hljs-comment">3.s-&gt;Next = p-&gt;Next</span><br><span class="hljs-comment">4.p-&gt;Next = s</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X, <span class="hljs-keyword">int</span> i, = List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p,s;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//新结点若插在表头，要单独考虑</span><br>        s = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct LNode));<span class="hljs-comment">//先分配空间</span><br>        s-&gt;Data = X;<br>        s-&gt;Next = PtrL;<span class="hljs-comment">//插在表头</span><br>        <span class="hljs-keyword">return</span> s;<span class="hljs-comment">//同时，返回新表的表头（已经变了）</span><br>    &#125;<br>    p = <span class="hljs-built_in">FindKth</span>(i<span class="hljs-number">-1</span>, PtrL);<span class="hljs-comment">//找到指向这个序号所对应结点的指针值</span><br>    <span class="hljs-keyword">if</span>(p = <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        s = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct LNode));<br>        s-&gt;Data = X;<br>        s-&gt;Next = p-&gt;Next;<br>        p-&gt;Next = s;<br>        <span class="hljs-keyword">return</span> PtrL;<span class="hljs-comment">//表头位置不变</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>删除<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.若要删除第i个结点，先p指向第i-1个结点</span><br><span class="hljs-comment">2.然后s指向第i个结点</span><br><span class="hljs-comment">3.修改指针，p-&gt;Next=s-&gt;Next,第i个元素被丢出链表</span><br><span class="hljs-comment">4.free(s),释放空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p,s;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//单独处理删除表头的情况</span><br>        s = PtrL;<br>        <span class="hljs-keyword">if</span>(PtrL!=<span class="hljs-literal">NULL</span>)&#123;<br>            PtrL = PtrL-&gt;Next;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">free</span>(s);<br>        <span class="hljs-keyword">return</span> PtrL;<br>    &#125;<br>    p = <span class="hljs-built_in">FindKth</span>(i<span class="hljs-number">-1</span>,PtrL);<br>    <span class="hljs-keyword">if</span>(p = <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error:%dth&quot;</span>,i<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;Next == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error:%dth&quot;</span>,i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        s = p-&gt;Next;<br>        p-&gt;Next = s-&gt;Next;<br>        <span class="hljs-built_in">free</span>(s);<br>        <span class="hljs-keyword">return</span> PtrL;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4>广义表中，元素不仅可以是单元素也可以是另一个广义表。</li></ol><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">GList</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Tag; <span class="hljs-comment">//需要一个标签来标注这个结点是单元素(0)还是广义表(1)</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span> <span class="hljs-comment">//cpp用union来组合不同类型的数据，这个数中可以是不一样的类型的数据</span><br>    ElementType Data;<span class="hljs-comment">//既可以是这种</span><br>    GList SubList;<span class="hljs-comment">//也可是这种指针</span><br>    &#125;URegion；<br>    GList Next;<span class="hljs-comment">//指向后续结点</span><br>&#125;；<br></code></pre></div></td></tr></table></figure><h4 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h4><p>链表中的结点可能同时隶属于多个链。</p><ul><li>多重链表中结点的指针域会有多个，如上一例中包含了Next和SubList两个指针。</li><li>然而，包含两个指针域并不一定就是多重链表，比如双向链表。</li></ul><p>树结构，图结构可以用多重链表来实现存储。</p><p>举例：可以使用<strong>十字链表</strong>来存储稀疏矩阵：</p><ul><li>只存储非零项，其中数据域包括：行R，列C，值V；</li><li>通过向右指针Right和向下指针Down来把这些结点串起来。</li></ul><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>后入先出</p><h4 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h4><p>通过一个一维数组来实现</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize <span class="hljs-meta-string">&lt;12&gt;</span></span><br><span class="hljs-keyword">typedef</span> struch SNode *Stack;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span>&#123;</span><br>    ElementType Data[MaxSize];<br>    <span class="hljs-keyword">int</span> Top;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ol><li>入栈<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack PtrS, ElemenType item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(PtrS-&gt;Top == MaxSize<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack full&quot;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; <span class="hljs-comment">// topp++</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>出栈</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">(Stack PtrS)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Ptrs-&gt;Top == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack empty&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//ERROR是ElementType的特殊值，标志错误！</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">return</span></span>(PtrS-&gt;Data[(Ptrs-&gt;Top)--]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h4><p>注意：链表尾端无法作为栈顶，因为不能对尾端进行删除操作。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span>&#123;</span><br>    ElementType Data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Next</span>;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>构建一个空堆栈：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Stack <span class="hljs-title">CreateStack</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//构建一个堆栈的头结点，返回指针</span><br>    Stack S;<br>    S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct SNode)); <span class="hljs-comment">//这里也可以用new(c++)</span><br>    S = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SNode</span>();<br>    S-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(Stack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Next == <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//链式堆栈只能在链表头插入删除，因此如果后面是NULL则表示这个链表(堆栈)空了</span><br>&#125; <br></code></pre></div></td></tr></table></figure><p> Tips：malloc和new的区别：</p><ul><li>malloc/free是标准库函数，new/delete是C++运算符</li><li>new/delete会调用构造、析构函数，malloc/free不会，所以他们无法满足动态对象的要求。</li><li>new返回有类型的指针，malloc返回无类型的指针。malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。</li><li>malloc内存分配失败后返回NULL；new分配内存失败则会抛异常（bac_alloc）。</li><li>reference: <a href="https://blog.csdn.net/qq_40840459/article/details/81268252">https://blog.csdn.net/qq_40840459/article/details/81268252</a></li></ul></li></ol><ol><li>插入 <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">( Stack S, ElementType X )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span><br>    PtrToSNode TmpCell;<br><br>    TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct SNode));<br>    TmpCell-&gt;Data = X;<br>    TmpCell-&gt;Next = S-&gt;Next;<br>    S-&gt;Next = TmpCell;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>删除 <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">( Stack S )</span>  </span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span><br>    PtrToSNode FirstCell;<br>    ElementType TopElem;<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">IsEmpty</span>(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>); <br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FirstCell = S-&gt;Next; <br>        TopElem = FirstCell-&gt;Data;<br>        S-&gt;Next = FirstCell-&gt;Next;<br>        <span class="hljs-built_in">free</span>(FirstCell);<br>        <span class="hljs-keyword">return</span> TopElem;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4>详见浙大数据结构ppt</li><li><p>中缀表达式利用堆栈转换为后缀表达式</p><ul><li>运算数：直接输出；</li><li>左括号：压入堆栈；</li><li>右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）；</li><li>运算符：<ul><li>若优先级大于栈顶运算符时，则把它压栈；</li><li>若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；</li></ul></li><li>若各对象处理完毕，则把堆栈中存留的运算符一并输出。</li></ul></li><li><p>利用堆栈求后缀表达式的值</p><ul><li>字符序列的后缀表达式 -&gt; 分割 -&gt; 对象序列的后缀表达式 -&gt; 利用堆栈求值</li><li>6 2 / 3 - 4 2 * + =  8:</li><li>6/2=3,3-3=0,4*2=8,0+8=8</li></ul></li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>是一种具有操作约束的线性表。<br><br>只能在后端(rear)插入，前端(front)删除，因此是先进先出（FIFO）。<br>| data(front) | data | data(rear) | -&gt; |<br>| —- | —- | —- | —- |</p><p>定义：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-keyword">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br></code></pre></div></td></tr></table></figure></p><h4 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h4><p>循环队列，善用取余操作<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Queue <span class="hljs-title">CreateQueue</span><span class="hljs-params">( <span class="hljs-keyword">int</span> MaxSize )</span></span><br><span class="hljs-function"></span>&#123;<br>    Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct QNode));<br>    Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElementType));<br>    Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;<br>    Q-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> Q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%(Q-&gt;MaxSize) == Q-&gt;Front);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsFull</span>(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%(Q-&gt;MaxSize); <br>        Q-&gt;Data[Q-&gt;Rear] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear);<br>&#125;<br><br><span class="hljs-function">ElementType <span class="hljs-title">DeleteQ</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsEmpty</span>(Q) ) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  &#123;<br>        Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        <span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h4><p>注意，front只能是链表头，rear只能是链表尾，因为只有链表头可以删除结点</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">/* 队列中的结点 */</span><br>    ElementType Data;<br>    PtrToNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToNode Position;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-keyword">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function">ElementType <span class="hljs-title">DeleteQ</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    Position FrontCell; <br>    ElementType FrontElem;<br>    <br>    <span class="hljs-keyword">if</span>  ( <span class="hljs-built_in">IsEmpty</span>(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FrontCell = Q-&gt;Front;<br>        <span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span><br>            Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span><br>        <span class="hljs-keyword">else</span>                     <br>            Q-&gt;Front = Q-&gt;Front-&gt;Next;<br>        FrontElem = FrontCell-&gt;Data;<br><br>        <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span><br>        <span class="hljs-keyword">return</span>  FrontElem;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="多项式加法运算"><a href="#多项式加法运算" class="headerlink" title="多项式加法运算"></a>多项式加法运算</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Polynomial <span class="hljs-title">PolyAdd</span> <span class="hljs-params">(Polynomial P1, Polynomial P2)</span></span><br><span class="hljs-function"></span>&#123;<br>    Polynomial front, rear, temp;<br>    <span class="hljs-keyword">int</span> sum;<br>    rear = (Polynomial) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct PolyNode)); <br>    front = rear; <span class="hljs-comment">/* 由front 记录结果多项式链表头结点 */</span><br>    <span class="hljs-keyword">while</span> ( P1 &amp;&amp; P2 ) <span class="hljs-comment">/* 当两个多项式都有非零项待处理时 */</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( <span class="hljs-built_in">Compare</span>(P1-&gt;expon, P2-&gt;expon) ) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>            <span class="hljs-built_in">Attach</span>( P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>            P1 = P1-&gt;link;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <br>            <span class="hljs-built_in">Attach</span>(P2-&gt;coef, P2-&gt;expon, &amp;rear); <br>            P2 = P2-&gt;link;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <br>            sum = P1-&gt;coef + P2-&gt;coef;<br>            <span class="hljs-keyword">if</span> ( sum ) <span class="hljs-built_in">Attach</span>(sum, P1-&gt;expon, &amp;rear);<br>            P1 = P1-&gt;link; <br>            P2 = P2-&gt;link;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-comment">/* 将未处理完的另一个多项式的所有结点依次复制到结果多项式中去 */</span><br>    <span class="hljs-keyword">for</span> ( ; P1; P1 = P1-&gt;link ) <span class="hljs-built_in">Attach</span>(P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>    <span class="hljs-keyword">for</span> ( ; P2; P2 = P2-&gt;link ) <span class="hljs-built_in">Attach</span>(P2-&gt;coef, P2-&gt;expon, &amp;rear);<br>    rear-&gt;link = <span class="hljs-literal">NULL</span>; <br>    temp = front;<br>    front = front-&gt;link; <span class="hljs-comment">/*令front指向结果多项式第一个非零项 */</span><br>    <span class="hljs-built_in">free</span>(temp); <span class="hljs-comment">/* 释放临时空表头结点 */</span><br>    <span class="hljs-keyword">return</span> front;<br></code></pre></div></td></tr></table></figure><h2 id="第三讲-树（上）"><a href="#第三讲-树（上）" class="headerlink" title="第三讲 树（上）"></a>第三讲 树（上）</h2><h3 id="树与树的表示"><a href="#树与树的表示" class="headerlink" title="树与树的表示"></a>树与树的表示</h3><p>为什么要用树？<br><br>因分层次的组织在管理上具有更高的效率。<br><br>用树可以实现有效率的查找</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找分为<strong>动态查找</strong>和<strong>静态查找</strong></p><ul><li>静态查找<ul><li>集合中记录是固定的</li><li>没有插入和删除操作</li><li>方法：<ul><li>顺序查找。按顺序查找，平均找n/2次，复杂度O(n)</li><li>二分查找。<ul><li>假设n个数据元素的关键字满足有序（比如：从小到大）并且是连续存放的（数组），那么可以进行二分查找</li><li>二分查找流程(假设数据从小到大排列)：<ul><li>设定初始左右边界(left,right)</li><li>迭代入口&gt;&gt;&gt;while(left&lt;=right)</li><li>计算中间坐标(mid)对应元素的值</li><li>若中间元素比给定值大，调整右边边界等于中间坐标-1，right=mid-1，并进行下一轮迭代</li><li>若中间元素比给定值小，调整左边边界等于中间坐标+left=mid+1，并进行下一轮迭代</li><li>若中间元素等于给定值，return中间元素的下标，寻找成功</li><li>&lt;&lt;&lt;若跳出while循环，代表左右边界错位，不存在待查早数据，return-1</li></ul></li><li>时间复杂度是O(logN)，事先进行有序化排序是效率提升的关键</li><li>实际上这种二分查找流程就构成了一个树</li></ul></li></ul></li></ul></li><li>动态查找<ul><li>集合中记录是动态变化的</li><li>除了查找还可能发现插入和删除</li></ul></li></ul><p>技巧：在边界设定“哨兵”（sentinel），这样可以规避edge case，避免进行麻烦的边界情况的判断。参考<a href="algorithmNotes.md">算法笔记</a>中的82. Remove Duplicates from Sorted List II</p><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><p>树(Tree) :n (n $\geq$ 0)个结点构成的有限集合。<br><br>当n=0时，称为空树; <br><br>对于任一棵非空树(n&gt;0)，它具备以下性质:</p><ul><li>树中有一个称为“根(Root) ”的特殊结点，用r表示;</li><li>其余结点可分为m(m&gt;0)个<strong>互不相交</strong>的有限集T，T2, …，Tm，其中每个集合本身又是一棵树，称为原来树的“子树(SubTree)”。<br><br><strong>子树是不相交的</strong></li><li>除了根结点外，<strong>每个结点有且仅有一个父结点</strong>;一棵N个结点的树有N-1条边，因此<strong>树是保证链接数最小的结点连接方式</strong></li></ul><p>关于树的基本术语：</p><ul><li>结点的度(Degree)：结点的子树个数</li><li>树的度：树的所有结点中最大的度数</li><li>叶结点(Leaf)：度为0的结点</li><li>父结点(Parent)：有子树的结点是其子树的根结点的父结点</li><li>子结点(Child)：若A是B的父结点，则B是A的子结点</li><li>兄弟结点(Sibling)：具有同一父结点的各结点之间是兄弟结点</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2,…,nk, ni是ni+1的父结点。路径所包含边的个数为路径的长度。</li><li>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</li><li>子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。</li><li>结点的层次（Level）：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。</li><li>树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度</li></ul><h4 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h4><p>树难以用数组表示，也不太好用链表表示(每个Node结构不同，因为next指针域的数量不同)</p><p>可以使用儿子-兄弟表示法：<br>这样每一个链表结点的构造都是相同的。<br><br>这种树结构称为二叉树。</p><p><img src="/img/pics/child_sibling_1.png" alt=""></p><p><img src="/img/pics/child_sibling_2.png" alt=""></p><h3 id="二叉树及存储结构"><a href="#二叉树及存储结构" class="headerlink" title="二叉树及存储结构"></a>二叉树及存储结构</h3><h4 id="几种特殊二叉树"><a href="#几种特殊二叉树" class="headerlink" title="几种特殊二叉树"></a>几种特殊二叉树</h4><ol><li>斜二叉树(实际上就是链表)<br><img src="/img/pics/3.2_1.png" alt=""></li><li>完美/满二叉树<br><img src="/img/pics/3.2_2.png" alt=""></li><li><strong>完全二叉树</strong><br>完全二叉树可以不是完美二叉树，可以缺结点，但是必须是按照一定规则（从上到下，从左到右）排序之后的尾端的连续结点序列。<br><br>比如，下面这个是完全二叉树：<br><br><img src="/img/pics/3.2_3.png" alt=""><br>而下面这个不是：<br><br><img src="/img/pics/3.2_4.png" alt=""><br>完全二叉树是很重要的一种树。</li></ol><h4 id="二叉树的重要性质"><a href="#二叉树的重要性质" class="headerlink" title="二叉树的重要性质"></a>二叉树的重要性质</h4><ul><li>一个二叉树第i层的最大结点数为：2<sup>i-1</sup>, i $\geq$ 1</li><li>深度为k的二叉树有最大结点总数为2<sup>k</sup>-1, k $\geq$ 1</li><li>对任何非空二叉树T，若n<sub>0</sub>表示叶结点的个数,n<sub>2</sub>是度为2的非叶结点个数，那么两者满足关系n<sub>0</sub>=n<sub>2</sub>+1。</li></ul><h4 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h4><p>对于完全二叉树（需按照上面的规则编号），可以用数组实现，而且非常方便：</p><ul><li>非根结点(序号i&gt;1)的父结点的序号是int(i/2)（向下取整—）;</li><li>结点(序号为i)的左孩子结点的序号是2i,(若2i&lt;=n，否则没有左孩子) ;</li><li>结点(序号为i )的右孩子结点的序号是2i+1,(若2i+1&lt;=n， 否则没有右孩子);<br>一般二叉树也可以这样处理，但是在没有值的位置需要把对应的位置空出来。这样会造成空间浪费</li></ul><h4 id="二叉树链式存储结构"><a href="#二叉树链式存储结构" class="headerlink" title="二叉树链式存储结构"></a>二叉树链式存储结构</h4><div class="table-container"><table><thead><tr><th>Left</th><th>Data</th><th>Right</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">BinTree</span>;</span><br><span class="hljs-keyword">typedef</span> BinTree Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    ElementType Data;<br>    BinTree Left;<br>    BinTree Right;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a><strong>二叉树的递归遍历</strong></h4><ol><li><p>先序遍历<br><img src="/img/pics/3.3_1.png" alt=""></p><ol><li>访问根结点</li><li>先序遍历其左子树</li><li>先序遍历其右子树<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraversal</span><span class="hljs-params">(BinTree BT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(BT)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, BT-&gt;Data);<br>        <span class="hljs-built_in">PreOrderTraversal</span>(BT-&gt;Left);<br>        <span class="hljs-built_in">PreOrderTraversal</span>(BT-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol></li><li><p>中序遍历<br><img src="/img/pics/3.3_2.png" alt=""></p><ol><li>中序遍历其左子树</li><li>访问根结点</li><li>中序遍历其右子树<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraversal</span><span class="hljs-params">(BinTree BT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(BT)&#123;<br>        <span class="hljs-built_in">InOrderTraversal</span>(BT-&gt;Left);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, BT-&gt;Data);<br>        <span class="hljs-built_in">InOrderTraversal</span>(BT-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol></li><li>后序遍历<br><img src="/img/pics/3.3_3.png" alt=""><ol><li>后序遍历其左子树</li><li>后序遍历其右子树</li><li>访问根结点<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraversal</span><span class="hljs-params">(BinTree BT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(BT)&#123;<br>        <span class="hljs-built_in">PostOrderTraversal</span>(BT-&gt;Left);<br>        <span class="hljs-built_in">PostOrderTraversal</span>(BT-&gt;Right);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, BT-&gt;Data);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><strong>二叉树遍历的核心问题：二维结构的线性化</strong><br><img src="/img/pics/3.3_4.png" alt=""><br>因此需要一个存储结构保存暂时不访问的结点（堆栈或者队列），否则扫描经过之后就无法访问了。</li></ol></li></ol><p>队列实现:遍历从根结点开始，首先将根结点入队，然后开始执行循环:1.结点出队、2.访问该结点、3.其左右儿子入队.</p><p>举例：对于下面的树：<br><img src="/img/pics/3.3_5.png" alt=""><br><br>有：<br><br>| A    | out: <br><br>| B C  | out:A<br><br>| C D F | out:AB<br><br>| D F G I| out:ABC<br><br>| F G I E | out:ABCD<br><br>| G I E H | out:ABCDF<br><br>out: ABCDFGIEH<br></p><p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrderTraversal</span> <span class="hljs-params">( BinTree BT )</span></span><br><span class="hljs-function"></span>&#123; Queue Q; BinTree T;<br>    <span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span><br>    Q = <span class="hljs-built_in">CreatQueue</span>( MaxSize ); <span class="hljs-comment">/*创建并初始化队列Q*/</span><br>    <span class="hljs-built_in">AddQ</span>( Q, BT );<br>    <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">IsEmptyQ</span>( Q ) ) &#123;<br>        T = <span class="hljs-built_in">DeleteQ</span>( Q );<br>        <span class="hljs-built_in">printf</span>(“%d\n”, T-&gt;Data); <span class="hljs-comment">/*访问取出队列的结点*/</span><br>        <span class="hljs-keyword">if</span> ( T-&gt;Left ) <span class="hljs-built_in">AddQ</span>( Q, T-&gt;Left );<br>        <span class="hljs-keyword">if</span> ( T-&gt;Right ) <span class="hljs-built_in">AddQ</span>( Q, T-&gt;Right );<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p><h4 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h4><ol><li>输出二叉树中的叶子结点<br>只需要在二叉树遍历算法中增加检测结点的“左右子树是都否为空”即可。<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span>( BT ) &#123;<br>         <span class="hljs-keyword">if</span> ( !BT-Left &amp;&amp; !BT-&gt;Right )<br>             <span class="hljs-built_in">printf</span>(“%d”, BT-&gt;Data );<br>         <span class="hljs-built_in">PreOrderPrintLeaves</span> ( BT-&gt;Left );<br>         <span class="hljs-built_in">PreOrderPrintLeaves</span> ( BT-&gt;Right );<br>     &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure></li><li>求二叉树的高度<br>假设左子树高度为HL，右子树高度为HR，则<br><br>Height=max(HL, HR)+1（根结点）<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PostOrderGetHeight</span><span class="hljs-params">( BinTree BT )</span></span><br><span class="hljs-function"> </span>&#123;   <span class="hljs-keyword">int</span> HL, HR, MaxH;<br>     <span class="hljs-keyword">if</span>( BT ) &#123;<br>         HL = <span class="hljs-built_in">PostOrderGetHeight</span>(BT-&gt;Left); <span class="hljs-comment">/*求左子树的深度*/</span><br>         HR = <span class="hljs-built_in">PostOrderGetHeight</span>(BT-&gt;Right); <span class="hljs-comment">/*求右子树的深度*/</span><br>         MaxH = （HL &gt; HR）? HL : HR; <span class="hljs-comment">/*取左右子树较大的深度*/</span><br>         <span class="hljs-keyword">return</span> ( MaxH + <span class="hljs-number">1</span> ); <span class="hljs-comment">/*返回树的深度*/</span><br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 空树深度为0 */</span><br> &#125;<br></code></pre></div></td></tr></table></figure></li><li>通过中序遍历+前序/后序遍历，唯一确定一颗二叉树</li></ol><h4 id="判断树的同构"><a href="#判断树的同构" class="headerlink" title="判断树的同构"></a>判断树的同构</h4><p>运用链表的思想，构造结构数组来表示下面的树：<br><br><img src="/img/pics/3.3_6.png" alt=""><br><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 来学习一下怎么构造结构数组吧！</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxTree 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ElementType char</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Tree int</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Null -1</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElementType Element;<br>    Tree Left;<br>    Tree Right;<br>&#125;T1[MaxTree], T2[MaxTree]<br></code></pre></div></td></tr></table></figure><br>需要完成：1.读入两个二叉树；2.二叉树同构判别<br><br>输入样例：<br><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment">### 输入样例:</span><br><span class="hljs-attribute">8</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">5</span> -<br><span class="hljs-attribute">D</span> - -<br><span class="hljs-attribute">E</span> <span class="hljs-number">6</span> -<br><span class="hljs-attribute">G</span> <span class="hljs-number">7</span> -<br><span class="hljs-attribute">F</span> - -<br><span class="hljs-attribute">H</span> - -<br><span class="hljs-attribute">8</span><br><span class="hljs-attribute">G</span> - <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">F</span> - -<br><span class="hljs-attribute">A</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">H</span> - -<br><span class="hljs-attribute">C</span> <span class="hljs-number">0</span> -<br><span class="hljs-attribute">D</span> - -<br><span class="hljs-attribute">E</span> <span class="hljs-number">2</span> -<br></code></pre></div></td></tr></table></figure><br>结构：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree R1, R2;<br>    R1 = <span class="hljs-built_in">BuildTree</span>(T1); <span class="hljs-comment">// T1，T2就是上面的结构数组，返回的是根结点的index</span><br>    R2 = <span class="hljs-built_in">BuildTree</span>(T2);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Isomorphic</span>(R1,R2))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">BuildTree</span><span class="hljs-params">( struct TreeNode T[] )</span></span><br><span class="hljs-function"></span>&#123;...<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">if</span> (N) &#123;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) check[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %c %c\n&quot;</span>, &amp;T[i].Element, &amp;cl, &amp;cr);<br>            <span class="hljs-keyword">if</span> (cl != <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                T[i].Left = cl-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                check[T[i].Left] = <span class="hljs-number">1</span>; <span class="hljs-comment">//原理是，如果一个元素没有指向被指向，则它就是根结点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> T[i].Left = Null;<br>            ... <span class="hljs-comment">/*对cr的对应处理 */</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>            <span class="hljs-keyword">if</span> (!check[i]) <span class="hljs-keyword">break</span>;<br>        Root = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Isomorphic</span> <span class="hljs-params">( Tree R1, Tree R2 )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( (R1==Null )&amp;&amp; (R2==Null) ) <span class="hljs-comment">/* both empty */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> ( ((R1==Null)&amp;&amp;(R2!=Null)) || ((R1!=Null)&amp;&amp;(R2==Null)) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* one of them is empty */</span><br>    <span class="hljs-keyword">if</span> ( T1[R1].Element != T2[R2].Element )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* roots are different */</span><br>    <span class="hljs-keyword">if</span> ( ( T1[R1].Left == Null )&amp;&amp;( T2[R2].Left == Null ) )<br>        <span class="hljs-comment">/* both have no left subtree */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Isomorphic</span>( T1[R1].Right, T2[R2].Right );<br>    <span class="hljs-keyword">if</span> ( ((T1[R1].Left!=Null)&amp;&amp;(T2[R2].Left!=Null))&amp;&amp;<br>        ((T1[T1[R1].Left].Element)==(T2[T2[R2].Left].Element)) )<br>        <span class="hljs-comment">/* no need to swap the left and the right */</span><br>        <span class="hljs-keyword">return</span> ( <span class="hljs-built_in">Isomorphic</span>( T1[R1].Left, T2[R2].Left ) &amp;&amp;<br>        <span class="hljs-built_in">Isomorphic</span>( T1[R1].Right, T2[R2].Right ) );<br><br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* need to swap the left and the right */</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> ( <span class="hljs-built_in">Isomorphic</span>( T1[R1].Left, T2[R2].Right) &amp;&amp;<br>        <span class="hljs-built_in">Isomorphic</span>( T1[R1].Right, T2[R2].Left ) );<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h2 id="第四讲-树（中）"><a href="#第四讲-树（中）" class="headerlink" title="第四讲 树（中）"></a>第四讲 树（中）</h2><h3 id="二叉搜索树-BST-Binary-Search-Tree"><a href="#二叉搜索树-BST-Binary-Search-Tree" class="headerlink" title="二叉搜索树(BST, Binary Search Tree)"></a>二叉搜索树(BST, Binary Search Tree)</h3><p><strong>也成为二叉排序树和二叉查找树</strong></p><p>满足以下性质：</p><ol><li>非空左子树的所有键值小于其根结点的键值 （运用二分查找的思想，需要先排序）</li><li>非空右子树的所有键值大于于其根结点的键值</li><li>左、右子树都是二叉搜索树</li></ol><p><img src="/img/pics/4.1_1.png" alt=""></p><h4 id="查找操作：Find"><a href="#查找操作：Find" class="headerlink" title="查找操作：Find"></a>查找操作：Find</h4><ul><li>查找从根结点开始，如果树为空，返回NULL</li><li>若搜索树非空，则根结点关键字和X进行比较，并进行不同处理:<ul><li>若X小于根结点键值，只需在左子树中继续搜索;</li><li>如果X大于根结点的键值，在右子树中进行继续搜索;</li><li>若两者比较结果是相等，搜索完成，返回指向此结点的指针。<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">1.</span>使用尾递归的方法：<br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//failure</span><br>    <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, BST-&gt;Right); <span class="hljs-comment">//在右子树中继续查找</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, BST-&gt;Left);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//X == Bst-&gt;Data&#123;</span><br>        <span class="hljs-keyword">return</span> BST; <span class="hljs-comment">//查找成功，返回找到的结点的位置</span><br>    &#125;<br>&#125;<br><br><span class="hljs-number">2.</span>使用迭代循环的方法（推荐）：<br><span class="hljs-function">Position <span class="hljs-title">IterFind</span><span class="hljs-params">(ElementType X, BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(BST)&#123;<br>        <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)&#123;<br>            BST = BST-&gt;Right; <span class="hljs-comment">//向右移动</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)&#123;<br>            BST = BST-&gt;Left; <span class="hljs-comment">//向左移动</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> BST；<br>        &#125;<br>    &#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>若树往一边倒，比如全都只有左儿子，或者都只有右儿子，那算法效率就很低，达不到二分的log2n。因此需要平衡二叉树</li></ul></li></ul><h4 id="查找最值操作：FindMin，FindMax2"><a href="#查找最值操作：FindMin，FindMax2" class="headerlink" title="查找最值操作：FindMin，FindMax2"></a>查找最值操作：FindMin，FindMax2</h4><p>FindMin:最小值肯定在最左边<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Position <span class="hljs-title">FindMin</span><span class="hljs-params">(BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归方法</span><br>    <span class="hljs-keyword">if</span>(!BST)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!BST-&gt;Left)<br>        <span class="hljs-keyword">return</span> BST; <span class="hljs-comment">//找到最左边结点并返回</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">FindMin</span>(BST-&gt;Left);<br>&#125;<br></code></pre></div></td></tr></table></figure><br>FindMin:最大值肯定在最右边<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Position <span class="hljs-title">FindMax</span><span class="hljs-params">(BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 迭代方法</span><br>    <span class="hljs-keyword">if</span>(BST)&#123;<br>        <span class="hljs-keyword">while</span>(BST-&gt;Right)&#123;<br>            BST = BST-&gt;Right;<br>        &#125;<br>    &#125;<span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>找到一个数的排序位置，并将其作为叶结点插入<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">BinTree <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X, BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST)&#123;<br>        <span class="hljs-comment">// 若原树为空，则生成并返回一个结点的二叉搜索树</span><br>        BST = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct TreeNode))<br>        BST-&gt;Data = X;<br>        BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//开始找插入的位置</span><br>        <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)<br>            BST-&gt;Left = <span class="hljs-built_in">Insert</span>(X, BST-&gt;Left);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>            BST-&gt;Right = <span class="hljs-built_in">Insert</span>(X,BST-&gt;Right);<br>    &#125;<span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>三种情况：</p><ol><li>要删除的是叶结点：直接删除，再修改其父结点指针为NULL</li><li>要删除的结点<strong>只有一个孩子结点</strong>：将其父结点的指针指向要删除结点的孩子结点即可，也就是直接把删除结点的子结点挂在删除结点的父结点的对应位置</li><li>要删除的结点有左、右、两棵子树：用另一结点替代被删除结点—右子树的最小元素，或者左子树的最大元素（因为左子树的最大值和右子树的最小值一定不会有两个儿子，这样只需参照1和2修改即可）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">BinTree <span class="hljs-title">Delete</span><span class="hljs-params">( BinTree BST, ElementType X )</span> </span><br><span class="hljs-function"></span>&#123; <br>    Position Tmp; <br><br>    <span class="hljs-keyword">if</span>( !BST ) <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>); <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data ) <br>            BST-&gt;Left = <span class="hljs-built_in">Delete</span>( BST-&gt;Left, X );   <span class="hljs-comment">/* 从左子树递归删除 */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data ) <br>            BST-&gt;Right = <span class="hljs-built_in">Delete</span>( BST-&gt;Right, X ); <span class="hljs-comment">/* 从右子树递归删除 */</span><br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* BST就是要删除的结点 */</span><br>            <span class="hljs-comment">/* 如果被删除结点有左右两个子结点 */</span> <br>            <span class="hljs-keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;<br>                <span class="hljs-comment">/* 从右子树中找最小的元素填充删除结点，也可以左子树找最大元素 */</span><br>                Tmp = <span class="hljs-built_in">FindMin</span>( BST-&gt;Right );<br>                BST-&gt;Data = Tmp-&gt;Data; <span class="hljs-comment">//用右子树中最小元素替换被删除结点</span><br>                <span class="hljs-comment">/* 从右子树中删除最小元素 */</span><br>                BST-&gt;Right = <span class="hljs-built_in">Delete</span>( BST-&gt;Right, BST-&gt;Data );<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 被删除结点有一个或无子结点 */</span><br>                Tmp = BST; <br>                <span class="hljs-keyword">if</span>( !BST-&gt;Left )       <span class="hljs-comment">/* 只有右孩子或无子结点 */</span><br>                    BST = BST-&gt;Right;  <span class="hljs-comment">//把当前结点的下一个结点桥接上来，等于删除当前结点 </span><br>                <span class="hljs-keyword">else</span>                   <span class="hljs-comment">/* 只有左孩子 */</span><br>                    BST = BST-&gt;Left;<br>                <span class="hljs-built_in">free</span>( Tmp );<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>搜索树结点不同的插入次序，将导致不同的<strong>深度</strong>和<strong>平均查找长度</strong>ASL</p><p>平衡因子（BF）：左子树和右子树的高度差<br><br>BF(T) = h<sub>L</sub> - h<sub>R</sub></p><p>平衡二叉树(Balanced Binary Tree), 或AVL树（AVL是提出的科学家的名字缩写）：<br></p><ul><li>空树，或者;</li><li><strong>任 一 结 点</strong>左、右子树的高度差绝对值不超过1，即|BF(T)| $\leq$  1<br><br><img src="/img/pics/4.2_1.png" alt=""></li><li>给定结点数为n的AVL树的最大高度为O(log<sub>2</sub>n)</li></ul><h4 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h4><p>分为四种情况</p><ol><li>RR插入，RR旋转<br><img src="/img/pics/4.2_2.png" alt=""></li><li>LL插入，LL选择<br><img src="/img/pics/4.2_3.png" alt=""></li><li>LR插入，LR选择<br><img src="/img/pics/4.2_4.png" alt=""></li><li>RL插入，RL旋转<br><img src="/img/pics/4.2_5.png" alt=""></li></ol><h4 id="如何判断是同一颗二叉搜索树"><a href="#如何判断是同一颗二叉搜索树" class="headerlink" title="如何判断是同一颗二叉搜索树"></a>如何判断是同一颗二叉搜索树</h4><p>给定一个插入序列就可以唯一确定一棵二叉搜索树，但反之则不然。<br><br>尝试根据输入的队列来确定是否能生成一样的二叉搜索树</p><ol><li>搜索树的表示<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">Tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> v;<br>    Tree Left, Right;<br>    <span class="hljs-keyword">int</span> flag; <span class="hljs-comment">// 用来记录结点是否有被遍历到</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>程序主要框架：<ol><li>读入N和L</li><li>根据第一个序列建树T</li><li>判别之后的L个序列是否能形成和T一样的树，并返回结果<br><br>构建部分：<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> N,L,i;<br>    Tree T;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">while</span>(N)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;L);<br>        T = <span class="hljs-built_in">MakeTree</span>(N);<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;L;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Judge</span>(T,N)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>            <span class="hljs-built_in">ResetT</span>(T);<br>        &#125;<br>        <span class="hljs-built_in">FreeTree</span>(T);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">MakeTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree T;<br>    <span class="hljs-keyword">int</span> i, V;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V);<br>    T = <span class="hljs-built_in">NewNode</span>(V);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;N;i++&gt;)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V);<br>        T = <span class="hljs-built_in">Insert</span>(T,V);<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">NewNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree T = (Tree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct TreeNode));<br>    T-&gt;v = T;<br>    T-&gt;Left = T-&gt;Right = <span class="hljs-literal">NULL</span>;<br>    T-&gt;frag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">Insert</span><span class="hljs-params">(Tree T, <span class="hljs-keyword">int</span> V)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)<br>         T = <span class="hljs-built_in">NewNode</span>(V);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(V&gt;T-&gt;v)<br>             T-&gt;Right = <span class="hljs-built_in">Insert</span>(T-&gt;Right, V);<br>        <span class="hljs-keyword">else</span><br>             T-&gt;Left = <span class="hljs-built_in">Insert</span>(T-&gt;Left, V);<br>     &#125;<br>     <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol></li><li><strong>判别方法</strong><ul><li>在构建好的树T中按顺序搜索序列3 2 4 1中的每一个数：</li><li><strong>如果每次搜索所经过的结点在前面均出现过</strong>，则一致；</li><li>否则（某次搜索中遇到未经过，即flag=0的结点），则不一致<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(Tree T, <span class="hljs-keyword">int</span> V)</span> <span class="hljs-comment">// 单个元素的判别</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;flag)&#123; <span class="hljs-comment">// 目前遍历到的结点是之前有标记的，继续迭代</span><br>        <span class="hljs-keyword">if</span>(V &lt; T-&gt;v)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(T-&gt;Left, V);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(V &gt; T-&gt;v)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(T-&gt;Right, V);<br>        &#125;<span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-keyword">if</span>(V == T-&gt;v)&#123; <span class="hljs-comment">// 碰到了新结点，康康值是否相等呢？</span><br>            T-&gt;flag = <span class="hljs-number">1</span>; <span class="hljs-comment">// 是正确的结点，把他标记一下就return</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 碰到了未经过的结点，判断出来不是同一棵树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Judge</span><span class="hljs-params">(Tree, <span class="hljs-keyword">int</span> N)</span> <span class="hljs-comment">// 循环调用check来判断整个序列</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, V, flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// flag=1:代表(可能序列还没检查完就已经)碰到不一致了</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>    <span class="hljs-keyword">if</span>( V!=T-&gt;v) flag=<span class="hljs-number">1</span>; <span class="hljs-comment">// 根节点就不同了</span><br>    <span class="hljs-keyword">else</span> T-&gt;flag = <span class="hljs-number">1</span> <span class="hljs-comment">// 注意区分flag和T的flag！</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;N;i++）&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>        <span class="hljs-keyword">if</span>((!flag)&amp;&amp;(!<span class="hljs-built_in">check</span>(T,V))) flag=<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果check返回0，则flag=1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>( flag ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">ResetT</span>(Tree T)<br>&#123;<br>    <span class="hljs-keyword">if</span> (T-&gt;Left) <span class="hljs-built_in">Reset</span>(T-&gt;Left);<br>    <span class="hljs-keyword">if</span> (T-&gt;Right) <span class="hljs-built_in">Reset</span>(T-&gt;Right);<br>    T-&gt;falg = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">FreeTree</span>(Tree T)<br>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;Left) <span class="hljs-built_in">FreeTree</span>(T-&gt;Left);<br>    <span class="hljs-keyword">if</span>(T-&gt;Right) <span class="hljs-built_in">FreeTree</span>(T-&gt;Right;<br>    <span class="hljs-built_in">free</span>(T))<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ol><h3 id="（补充）红黑树"><a href="#（补充）红黑树" class="headerlink" title="（补充）红黑树"></a>（补充）红黑树</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/143396578">https://zhuanlan.zhihu.com/p/143396578</a></p><p>为了解决二叉树多次插入结点后可能产生的不平衡现象，提出了红黑树。<br><br>那么红黑树和平衡二叉树(AVL树)有什么区别呢？</p><ul><li>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</li><li>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</li></ul><h4 id="红黑树的具体概念"><a href="#红黑树的具体概念" class="headerlink" title="红黑树的具体概念"></a>红黑树的具体概念</h4><p><strong>红黑树是一种自平衡的二叉查找树，它具有以下特点：</strong></p><ol><li><strong>结点是红色或黑色。</strong></li><li><strong>根结点是黑色。</strong></li><li><strong>每个叶子结点都是黑色的空结点（NIL结点）。</strong></li><li><strong>每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</strong></li><li><strong>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</strong><br><img src="/img/pics/BRT-1.png" alt=""></li></ol><ul><li>因为这五条规则的限制，红黑树能够保证自平衡，且<strong>从根到叶子的最长路径不会超过最短路径的2倍。</strong></li><li>而ALVL树是严格平衡的二叉树，要求<strong>每个节点的左右子树高度差不超过1</strong></li><li>AVL树查找效率更高，需要频繁查找时，可以选用AVL树</li><li>频繁插入删除时，则可以使用红黑树</li></ul><p>比如，这种情况插入之后就还是正常的：<br><img src="/img/pics/BRT-2.png" alt=""></p><p>但是这种就需要做出调整了：<br><img src="/img/pics/BRT-3.png" alt=""></p><p>调整的方法：</p><ol><li>变色</li><li>旋转<ol><li>左旋</li><li>右旋</li></ol></li></ol><h5 id="1-变色"><a href="#1-变色" class="headerlink" title="1. 变色"></a>1. 变色</h5><p><img src="/img/pics/BRT-4.png" alt=""></p><p>但是凭空多出来一个黑色节点会打破规则5，因此需要进一步的调整。</p><h5 id="2-1-左旋"><a href="#2-1-左旋" class="headerlink" title="2.1. 左旋"></a>2.1. 左旋</h5><p>父节点下沉，右孩子上浮，父节点的链接转移给右孩子；他们三的子节点继续按原顺序依次排列：<br><img src="/img/pics/BRT-5.png" alt=""></p><h5 id="2-2-右旋"><a href="#2-2-右旋" class="headerlink" title="2.2. 右旋"></a>2.2. 右旋</h5><p>也是同样地，父节点下沉，左孩子上浮，父节点的链接转移给右左孩子；他们三的子节点继续按原顺序依次排列：</p><p>就像下象棋一样，不同的局面对应着不同的搞法。而对于插入新结点来说，又可以归结为5种不同局面：</p><h5 id="局面1：新结点（A）位于树根，没有父结点。"><a href="#局面1：新结点（A）位于树根，没有父结点。" class="headerlink" title="局面1：新结点（A）位于树根，没有父结点。"></a>局面1：新结点（A）位于树根，没有父结点。</h5><p><img src="/img/pics/BRT-6.png" alt=""><br>直接让新节点变成黑色即可，能够满足5条规则。</p><h5 id="局面2：新结点（B）的父结点是黑色。"><a href="#局面2：新结点（B）的父结点是黑色。" class="headerlink" title="局面2：新结点（B）的父结点是黑色。"></a>局面2：新结点（B）的父结点是黑色。</h5><p><img src="/img/pics/BRT-7.png" alt=""><br>此时插入没有打破任何规则，不用做任何调整</p><h5 id="局面3：新结点（D）的父结点和叔叔结点都是红色。"><a href="#局面3：新结点（D）的父结点和叔叔结点都是红色。" class="headerlink" title="局面3：新结点（D）的父结点和叔叔结点都是红色。"></a>局面3：新结点（D）的父结点和叔叔结点都是红色。</h5><p><img src="/img/pics/BRT-8.png" alt=""><br>这种局面，两个红色结点B和D连续，违反了规则4。因此我们先让结点B变为黑色；但这样一来，结点B所在路径凭空多了一个黑色结点，打破了规则5。因此我们让结点A变为红色：<br><img src="/img/pics/BRT-9.png" alt=""><br>这时候，结点A和C又成为了连续的红色结点，我们再让结点C变为黑色：<br><img src="/img/pics/BRT-10.png" alt=""></p><p>即可。</p><h5 id="局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"><a href="#局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"></a>局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。</h5><p><img src="/img/pics/BRT-11.png" alt=""><br>做一次左旋，进入局面5.</p><h5 id="局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"><a href="#局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"></a>局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。</h5><p>我们以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子：<br><img src="/img/pics/BRT-12.png" alt=""></p><p>接下来，我们让结点B变为黑色，结点A变为红色：<br><img src="/img/pics/BRT-13.png" alt=""></p><p>即可。</p><p>如果局面4中的父结点B是右孩子，则成为了局面5的镜像，原本的右旋操作改为左旋；如果局面5中的父结点B是右孩子，则成为了局面4的镜像，原本的左旋操作改为右旋。</p><p>对于删除，也有三种不同的局面，这里就不再赘述</p><h2 id="第五讲-树（下）"><a href="#第五讲-树（下）" class="headerlink" title="第五讲 树（下）"></a>第五讲 树（下）</h2><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p><strong>优先队列(Priority Queue)</strong>: 特殊的“队列”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序.</p><p>采用数组或链表实现优先队列，则他们的复杂度：</p><ul><li>数组<ul><li>插入：元素总是插在尾部 — O(1)</li><li>删除：<ul><li>先找到最大、最小的关键字 — O(n)</li><li>数组删除还需要移动逐个元素 — O(n)</li></ul></li></ul></li><li>链表<ul><li>插入：元素总是插在链表头部 — O(1)</li><li>删除：<ul><li>先找到最大、最小的关键字 — O(n)</li><li>链表删去结点不需逐个移动 — O(1)</li></ul></li></ul></li><li>有序数组<ul><li>插入：<ul><li>找到合适的位置 — O(n)或者O(log2n) (二分法？)</li><li>移动元素并插入 — O(n)</li></ul></li><li>删除：删去最后一个元素 — O(1)</li></ul></li><li>有序链表<ul><li>插入：<ul><li>找到合适位置 — O(n)<ul><li>插入元素 — O(1)</li></ul></li><li>删除：首个元素或最后的元素 — O(1)</li></ul></li></ul></li></ul><p>尝试使用二叉树来存储？</p><p>由于删除比插入更加复杂，因此可以把最大值放在树根，并且使得其他的根节点都是相对的子节点的最大值，并使用完全二叉树来构造，这样就构成了堆。<br><br>堆的两个特性：</p><ul><li>结构性：用数组表示的完全二叉树</li><li>有序性：任一结点的关键字是其子树所有节点的最大值或最小值<ul><li>“最大堆（MaxHeap）”也成为“大顶堆”</li><li>“最小堆（MinHeap）”也成为“小顶堆”</li></ul></li></ul><p>堆的有序性在于它从上到下的任何一条路径都是单调的。</p><p><img src="/img/pics/5.1_1.png" alt=""></p><h4 id="最大堆的实现"><a href="#最大堆的实现" class="headerlink" title="最大堆的实现"></a>最大堆的实现</h4><ol><li>最大堆的定义<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapStruct</span> *<span class="hljs-title">MaxHeap</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeadStruct</span>&#123;</span><br>    ElementType *Elements;<br>    <span class="hljs-keyword">int</span> Size;<br>    <span class="hljs-keyword">int</span> Capacity;<br>&#125;;<br><br><span class="hljs-function">MaxHeap <span class="hljs-title">Create</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> MaxSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    MaxHeap H = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct HeapStruct));<br>    H-&gt;Elements = <span class="hljs-built_in">malloc</span>((MaxSize+<span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElementType)); <span class="hljs-comment">//这里+1是因为下标为0处并不用来存放数据</span><br>    H-&gt;Size = <span class="hljs-number">0</span>;<br>    H-&gt;Capacity = MaxSize;<br>    H-&gt;Elements[<span class="hljs-number">0</span>] = MaxData; <span class="hljs-comment">// 定义‘哨兵’为大于堆中所有可能元素的值，便于以后更快操作。</span><br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>最大堆的插入</li></ol><p>假设需要在[6]的位置上插入一个新节点，根据最大堆的性质进行判断：若该结点值比它的上一个结点大，则他们需要交换，在这里58&gt;31，交换一次；58&gt;44，再交换一次，最后新插入的58被交换到了[1]的位置。</p><p><img src="/img/pics/5.1_2.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(MaxHeap H, ElementType item)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// O(logN)</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsFull</span>(H))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap is Full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    i = ++ H-&gt;Size; <span class="hljs-comment">// i指向插入后堆中最后一个元素的位置</span><br>    <span class="hljs-keyword">for</span>(; H-&gt;Elements[i/<span class="hljs-number">2</span>]&lt;item ; i/=<span class="hljs-number">2</span> )&#123;<br>        H -&gt; Elements[i] = H -&gt; Elements[i/<span class="hljs-number">2</span>]; <span class="hljs-comment">//路径上碰到更小的元素将其逐个下移一位（如果item更大的话）</span><br>    &#125;<br>    H -&gt; Elements[i] = item; <span class="hljs-comment">// item 插入移位后上面空出来的位置</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    注意，如果比到树的第一个元素</span><br><span class="hljs-comment">    （比如说：将25 插入 1000[0,哨兵]-&gt;20[1]-&gt;15[2]-&gt;12[3]-&gt;2[4] 这棵树,)</span><br><span class="hljs-comment">    在0位置设定一个很大的数作为正式数据之外的哨兵，保证其比插入的元素大，这样可以保证插入的这个25不会越界，巧妙地规避edge case。</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><ol><li>最大堆的删除</li></ol><p><img src="/img/pics/5.1_3.png" alt=""></p><p>假设要删除58(最大值，在根的位置)：</p><ul><li>先把31移动到根的位置</li><li>然后找到31 的较大的孩子，交换位置</li><li>然后再往下迭代，交换位置</li></ul><p><img src="/img/pics/5.1_4.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">DeleteMax</span><span class="hljs-params">(MaxHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//从最大堆H中取出键值最大的元素，并删除一个结点</span><br>    <span class="hljs-keyword">int</span> Parent, Child;<br>    ElementType MaxIten, temp;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(H))&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MaxHeap is empty&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MaxItem = H-&gt;ELements[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 取出根节点最大值</span><br>    <span class="hljs-comment">// 然后，用最大堆中的最后一个元素从根节点开始向上过滤下层结点，也就是逐个比较，移位。</span><br>    temp = H-&gt;Elements[H-&gt;Size--] <span class="hljs-comment">// 取出H的最后一个元素（要删除的），暂时储存，再让Size-1</span><br>    <span class="hljs-keyword">for</span>(Parent=<span class="hljs-number">1</span>; Parent*<span class="hljs-number">2</span> &lt;= H-&gt;Size; Parent = Child)&#123;<br>        Child = Parent*<span class="hljs-number">2</span>; <span class="hljs-comment">//子节点位置,注意，父节点的两个子节点:i*2 and i*2+1</span><br>        <span class="hljs-keyword">if</span>( (Child != H-&gt;Size) &amp;&amp; (H-&gt;Element[Child] &lt; H-&gt;Elements[Child+<span class="hljs-number">1</span>]) )&#123;<br>            Child +=<span class="hljs-number">1</span>; <span class="hljs-comment">//指向两个孩子中的较大者</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp &gt;= H-&gt;Elements[Child]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 移位完成</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            H -&gt; Elements[Parents] = H-&gt;Elements[Child] <span class="hljs-comment">//更大的子节点上移</span><br>        &#125;<br>    &#125;<br>    H -&gt; Elements[Parent] = temp;<br>    <span class="hljs-keyword">return</span> MaxItem;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>最大堆的建立</li></ol><p>建立最大堆是指将<strong>给定的N个元素</strong>按照最大堆的要求存放在一个一维数组中。</p><ul><li>方法一：通过插入操作一个一个插入到初始为空的堆中去 — O(nlongn)</li><li>方法二：在线性时间复杂度下建立最大堆：<ul><li>先将N个元素按顺序存入，先满足完全二叉树的结构特性</li><li>再调节各节点的位置，以满足最大堆的有序特性</li></ul></li></ul><p>方法二的具体逻辑：<br><br>在堆删除中，根节点的底下是两个最大堆，以此类推，往下每个结点的两边都是最大堆<br><br>如果将其反过来，从最底层起，不断往上迭代地构筑最大堆，到根节点就是一个完整的最大堆了。</p><h3 id="哈夫曼树与哈夫曼编码-Huffman"><a href="#哈夫曼树与哈夫曼编码-Huffman" class="headerlink" title="哈夫曼树与哈夫曼编码 Huffman"></a>哈夫曼树与哈夫曼编码 Huffman</h3><p>根据数据出现的频率来建立更具效率的匹配<br><br>比如将100分制转化为5分制，可以score&lt;60 ==grade 1; 60&lt;=score&lt;70 ==grade 2,以此类推，这样会形成如下一颗判定树：</p><p><img src="/img/pics/5.2_1.png" alt=""></p><p>可以通过不同的方法构造搜索树，但不同搜索树的搜索效率又是不一样的（比如把频率最大的元素放在根节点）</p><h4 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h4><p><strong>带权路径长度(WPL)</strong>：设二叉树有n个叶子结点，每个叶子结点带有权值W<sub>k</sub>,从根结点到每个叶子结点的长度为l<sub>k</sub>，则每个叶子结点的带权路径长度之和就是:</p><script type="math/tex; mode=display">\Sigma_{k=1}^{n} w_kl_k</script><p><strong>最优二叉树/哈夫曼树</strong>：WPL最小的二叉树</p><p>例如下面的二叉树：<br><img src="/img/pics/5.2_2.png" alt=""></p><p>WPL = 5x1+4x2+3x3+2x4+1x4 = 34</p><p>而下面这棵树：<br><img src="/img/pics/5.2_3.png" alt=""></p><p>WPL = 1x3+2x3+3x2+4x2+5x2 = 33</p><h4 id="如何构造哈夫曼树"><a href="#如何构造哈夫曼树" class="headerlink" title="如何构造哈夫曼树"></a>如何构造哈夫曼树</h4><p>每次把<strong>权值最小的两棵树合并</strong>即可。（可以利用最小堆）<br><img src="/img/pics/5.2_4.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">HuffmanTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Weight;<br>    HuffmanTree Left, Right;<br>&#125;<br><br><span class="hljs-function">HuffmanTree <span class="hljs-title">Huffman</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">O</span>(NlogN)<br>    <span class="hljs-keyword">int</span> i; HuffmanTree T;<br>    <span class="hljs-built_in">BuildMinHeap</span>(H); <span class="hljs-comment">//将 H-&gt;Element[]按权值调整为最小堆</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i; i&lt; H-&gt;Size; i++)&#123; <span class="hljs-comment">//做H.Size - 1次的合并</span><br>        T = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct TreeNode));<br>        T-&gt;Left = <span class="hljs-built_in">DeletMin</span>(H); <span class="hljs-comment">// 从最小堆中删除一个结点，作为新T的左子节点</span><br>        T-&gt;Right = <span class="hljs-built_in">DeletMin</span>(H); <span class="hljs-comment">// 从最小堆中删除一个结点，作为新T的右子节点</span><br>        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;<br><br>        <span class="hljs-built_in">Insert</span>(H,T);<br>    &#125;<br>    T = <span class="hljs-built_in">DeletMin</span>(H);<br>    <span class="hljs-keyword">return</span> T; <span class="hljs-comment">//返回的是合并之后的树根</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h4><ul><li><strong>没有度为1的结点</strong></li><li>n个叶子节点的哈夫曼树共有2n-1个结点</li><li>哈夫曼树的任意<strong>非叶节点的左右子树交换后仍是哈夫曼树</strong>;</li><li>对同一组权值{W<sub>1</sub>,…..,w<sub>n</sub>},存在不同构的两棵哈夫曼树</li></ul><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>给定一段字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最少?<br><br>进行不等长编码，并避免其二义性。</p><p>前缀码(prefixcode):任何字符的编码都不是另一字符编码的前缀</p><ul><li>可以无二义地解码</li></ul><p>通过二叉树进行编码：<br>下图是两种二叉树的编码方式，第一种四个元素分别对应00，01，10，11，由于每个元素不是另外一个元素的前缀，因此没有二义性。但是第二个编码方式出现了某个元素在其他元素前面的情况，这就会产生二义性。<br><br>因此，需要产生一棵二叉树，使得每个元素都在叶节点上，保证其不会出现前缀的情况。<br></p><p><img src="/img/pics/5.2_5.png" alt=""></p><p>生成一棵正常的二叉树之后，如果要让编码效率最高，实际上就等同于生成一颗哈夫曼树，而每条路径就代表它的编码。</p><p><img src="/img/pics/5.2_6.png" alt=""></p><p><img src="/img/pics/5.2_7.png" alt=""></p><h4 id="如何构造一个哈夫曼编码树"><a href="#如何构造一个哈夫曼编码树" class="headerlink" title="如何构造一个哈夫曼编码树"></a>如何构造一个哈夫曼编码树</h4><p>比如，要根据如下的字母和出现频数来构造一个最优的哈夫曼编码：<br>| a | e | i | s | t | sp | nl |<br>| - | - | - | - | - | - | - |<br>| 10|15 |12 |3 |4 |13 |1|</p><p>过程：不断找最小的来合并结点即可。</p><p><img src="/img/pics/5.2_8.png" alt=""><br><img src="/img/pics/5.2_9.png" alt=""><br><img src="/img/pics/5.2_10.png" alt=""><br><img src="/img/pics/5.2_11.png" alt=""><br><img src="/img/pics/5.2_12.png" alt=""></p><p>最后得到：</p><p><img src="/img/pics/5.2_13.png" alt=""></p><h3 id="集合及运算，并查集"><a href="#集合及运算，并查集" class="headerlink" title="集合及运算，并查集"></a>集合及运算，<strong>并查集</strong></h3><p>并查集运用：File Transfer<br><br><a href="https://www.icourse163.org/learn/ZJU-93001?tid=1464647442#/learn/content?type=detail&amp;id=1243232243&amp;cid=1266529407&amp;replay=true">https://www.icourse163.org/learn/ZJU-93001?tid=1464647442#/learn/content?type=detail&amp;id=1243232243&amp;cid=1266529407&amp;replay=true</a></p><h4 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h4><ul><li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li><li>并查集：集合并、查某元素属于什么集合</li><li>并查集问题中集合存储如何实现？</li></ul><p>可以通过<strong>树</strong>来表示，树的每个结点代表一个集合元素</p><p>假设有三个整数集合：<br><br>S1={1,2,4,7}<br><br>S2={3,5,8}<br><br>S3={6,9,10}<br><br>他们可以表示成：<br><img src="/img/pics/5.3.1.png" alt=""></p><p>这样一棵树，可以使用链表存储，但是使用数组存储更好。<br><br>假设每个元素的类型描述为：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElementType Data;<br>    <span class="hljs-keyword">int</span> Parent;<br>&#125;SetType;<br></code></pre></div></td></tr></table></figure><br><img src="/img/pics/5.3.2.png" alt=""></p><p>如果没有父节点，则parent为-1，否则指向其父节点的下标</p><div class="table-container"><table><thead><tr><th>index</th><th>Data</th><th>Parent</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>-1</td></tr><tr><td>1</td><td>2</td><td>0</td></tr><tr><td>2</td><td>3</td><td>-1</td></tr><tr><td>3</td><td>4</td><td>0</td></tr><tr><td>4</td><td>5</td><td>2</td></tr><tr><td>5</td><td>6</td><td>-1</td></tr><tr><td>6</td><td>7</td><td>0</td></tr><tr><td>7</td><td>8</td><td>2</td></tr><tr><td>8</td><td>9</td><td>5</td></tr><tr><td>9</td><td>10</td><td>5</td></tr></tbody></table></div><h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ol><li>查找某个元素所在的集合(用根节点表示)<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(SetType S[], ElementType X)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在数组S中查找值为X的元素所属的集合</span><br>    <span class="hljs-comment">//MaxSize是全局变量，为S的最大长度</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;MaxSize&amp;&amp;S[i].Data != X; i++&gt;); <span class="hljs-comment">//空转，直到找到X</span><br>    <span class="hljs-keyword">if</span>(i&gt;=NaxSize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//未找到，返回-1</span><br>    <span class="hljs-keyword">for</span>( ;S[i].Parent&gt;=<span class="hljs-number">0</span>;i=S[i].Parent); <span class="hljs-comment">//不断向上，直到找到根节点</span><br>    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回根节点在数组中的下标</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>集合的并操作<br>分别找到X1和X2两个元素所在集合树的根节点，如果他们不同根，则将其中一个根节点的父节点指针设置成另一个根节点的数组下标</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(SetType S[], ElementType X1, ElementType X2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> Root1, Root2;<br>    Root1 = <span class="hljs-built_in">Find</span>(S, X1);<br>    Root2 = <span class="hljs-built_in">Find</span>(S, X2);<br>    <span class="hljs-keyword">if</span>(Root1 != Root2)   S[Root2].Parent = Root1;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了改善合并以后的查找性能(防止树过高)，可使每一次合并都小的集合合并到大的集合中。但是要怎么表示每个集合中元素的个数（大小）呢？可以把根节点原来的Parent(-1)改成（负号+这个集合中元素的个数）</p><p><img src="/img/pics/5.3.4.png" alt=""></p></li></ol><h2 id="图（上）"><a href="#图（上）" class="headerlink" title="图（上）"></a>图（上）</h2><h3 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h3><p>图表示<strong>多对多</strong>的关系。因此，线性表和树都是图的一种特殊形式。<br><br>包含：</p><ul><li>一组顶点：用V(Vertex)表示顶点集合</li><li>一组边：用E(Edge)表示边的集合<ul><li>边是定点对：(v,w) $\in$ E，其中v，w $\in$ V</li><li>有向边<v,w>表示从v指向w的单向边</li><li>不考虑重边(两条互指的单向边)和自回路</li></ul></li></ul><h4 id="怎样表示一个图"><a href="#怎样表示一个图" class="headerlink" title="怎样表示一个图"></a>怎样表示一个图</h4><ol><li><p>可以用邻接矩阵 G[N][N]，其中：</p><script type="math/tex; mode=display">G[i][j]= \begin{cases}1 & \text { 若< } v_{i}, v_{j}>\text { 是G中的边 } \\ 0 & \text { 否则 }\end{cases}</script><p>它是对称矩阵，有一半空间是浪费的 <br><br>因此，将上面邻接矩阵压缩成一个长度为N(N+1)/2的一维数组A：{G<sub>00</sub>,G<sub>10</sub>,G<sub>11</sub>,…,G<sub>n-1 0</sub>,…,G<sub>n-1 n-1</sub>,}</p><p>则G<sub>ij</sub>在G中对应的下标为(i*(i+1)/2+j)</p><p>如果要构造一个网络，只要把G[i][j]的值定义为边<vi,vj>的权重即可</p><p>缺点：<br></p><ol><li>存稀疏图的时候很浪费空间</li><li>浪费时间：需要每一个元素都扫过去</li></ol></li><li><p>邻接表：G[N]为指针数组，对应的矩阵每行一个链表，只存储非0元素<br><br>无所谓顺序<br><img src="/img/pics/6.1.1.png" alt=""></p><p>特点：</p><ol><li>方便找任意顶点的连接点</li><li>节约稀疏图的空间</li><li><strong>对于无向图</strong>，方便计算任意顶点的度</li><li>很难检测任意一对顶点之间是否存在边</li></ol></li></ol><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p><strong>深度优先搜索，Depth First Search, DFS</strong><br>一条路走到底，没路后<strong>原路返回</strong>，直到返回到这样一个岔路口（结点）：还有没被遍历的支路可以走。重复，指导最后原路返回至初始节点。</p><p>伪码描述：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span> <span class="hljs-params">(Vertex V)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">//类似树的先序遍历</span><br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(V的每个邻接点W)<br>        <span class="hljs-keyword">if</span>(!visited)<br>            <span class="hljs-built_in">DFS</span>(W);<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>若有N个顶点、E条边，时间复杂度是（主要耗在对“V的每个邻接点W”进行扫描）:</p><ul><li>用邻接表存储图，有O(N+E) </li><li>用邻接矩阵存储图，有O(N<sup>2</sup>)</li></ul><p><strong>广度优先搜索，Breadth First Search, BFS</strong><br>类似树的层序遍历</p><p>伪码描述：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Vertex V)</span></span><br><span class="hljs-function"></span>&#123;<br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">Enqueue</span>(V, Q);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br>        V = <span class="hljs-built_in">Dequeue</span>(Q);<br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[W])&#123;<br>                visited[W] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">Enqueue</span>(W, Q);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>时间复杂度(主要耗在对“V的每个邻接点W”进行扫描)：</p><ul><li>用邻接表存储图，有O(N+E)</li><li><p>用邻接矩阵存储图，有O(N<sup>2</sup>)</p><h4 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h4></li><li><p>连通:如果从v到w存在一条(无向)路径,则称v和w是连通的。</p></li><li>路径：V到W的路径是一系列顶点{V, v1, v2, …, vn, W}的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同，则称简单路径。 </li><li>回路：起点等于终点的路径</li><li>连通图：图中任意两顶点均连通</li></ul><p>无向图：</p><ul><li>连通分量：无向图的<strong>极大</strong>连通子图<ul><li><strong>极大</strong>顶点数：再加1个顶点就不连通了</li><li><strong>极大</strong>边数：包含子图中所有顶点相连的所有边</li></ul></li></ul><p>有向图：</p><ul><li>强连通：有向图中顶点V和W之间存在<strong>双向路径</strong>（不一定是同一条，但是都存在），则称V和W是强连通的<ul><li>强连通图：有向图中任意两顶点均强连通</li><li>强连通分量：有向图的极大强连通子图</li></ul></li></ul><p>如何遍历不连通的图呢？<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListComponents</span><span class="hljs-params">(Graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(each V in G)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[V])&#123;<br>            <span class="hljs-built_in">DFS</span>(V);<span class="hljs-comment">//or BFS</span><br>            <span class="hljs-comment">// 每调用一次DFS/BFS, 就把V所在的连通分量遍历了一遍</span><br>            <span class="hljs-comment">// 类似于绘画工具中的油漆桶</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="如何建立图"><a href="#如何建立图" class="headerlink" title="如何建立图"></a>如何建立图</h3><h4 id="邻接矩阵表示"><a href="#邻接矩阵表示" class="headerlink" title="邻接矩阵表示"></a>邻接矩阵表示</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Nv; <span class="hljs-comment">//顶点数</span><br>    <span class="hljs-keyword">int</span> Ne; <span class="hljs-comment">//边数</span><br>    WeightType G[MaxVertexNum][MaxVertexNum]<br>    Datatype Data[MaxVertexNum] <span class="hljs-comment">//存顶点的数据</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToGNOde MGraph; <span class="hljs-comment">//以邻接矩阵存储的图类型</span><br></code></pre></div></td></tr></table></figure><p>初始化一个有VertexNum个顶点但没有边的图<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">MGraph <span class="hljs-title">CreateGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> VertexNum)</span></span><br><span class="hljs-function"></span>&#123;<br>    MGraph Graph;<br>    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct GNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(V =<span class="hljs-number">0</span> ;V&lt;Graph-&gt;Nv;V++)&#123;<br>        <span class="hljs-keyword">for</span>(W=;W&lt;Graph-&gt;Nv;W++)&#123;<br>            Graph-&gt;G[V][W] = ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>向MGraph中插入边<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span><br>    Vertex V1,V2; <span class="hljs-comment">//有向边&lt;V1,V2&gt;</span><br>    WeightType Weight; <span class="hljs-comment">//权值</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToENode Edge;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">(MGraph Graph, Edge E)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//插入&lt;v1,v2&gt;</span><br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    <span class="hljs-comment">//若是无向图，还要插入&lt;v2,v1&gt;</span><br>    Graph-&gt;G[E-&gt;v2][E-&gt;v1] = E-&gt;Weight;<br>&#125;<br>完整地建立一个MGraph&lt;br&gt;<br>输入格式：&lt;br&gt;<br>Nv Ne&lt;br&gt;<br>V1 V2 Weight&lt;br&gt;<br>... ...&lt;br&gt;<br>```<span class="hljs-function">cpp</span><br><span class="hljs-function">MGraph <span class="hljs-title">BuildGraph</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MGraph Graph;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Nv);<br>    Graph = <span class="hljs-built_in">CreateGraph</span>(NV); <span class="hljs-comment">//initialization</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;(Graph-&gt;Ne));<br>    <span class="hljs-keyword">if</span>(Graph-&gt;Ne !=<span class="hljs-number">0</span>)&#123;<br>        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct ENode));<br>        <span class="hljs-keyword">for</span>(i=;i&lt;Graph-&gt;Ne;i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);<br>            <span class="hljs-built_in">InsertEdge</span>(Graph, E);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//如果顶点有数据的话，读入数据</span><br>    <span class="hljs-keyword">for</span>(V=;V&lt;Graph-&gt;Nv;V++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>),&amp;(Graph-&gt;Data[V]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>更简单的实现方法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> G[MAXN][MAXN],Nv,Ne;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildGraph</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,v1,v2,w;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Nv);<br>    <span class="hljs-comment">// CreateGraph</span><br>    <span class="hljs-keyword">for</span>(i=;i&lt;Nv;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=;j&lt;Nv;j++)&#123;<br>            G[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Ne);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;Ne;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;v1,&amp;v2,&amp;w);<br>        G[v1][v2] = w;<br>        G[v2][v1] = w;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="邻接表表示"><a href="#邻接表表示" class="headerlink" title="邻接表表示"></a>邻接表表示</h4><p><img src="/img/pics/6.1.5.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Nv; <span class="hljs-comment">//顶点数</span><br>    <span class="hljs-keyword">int</span> Ne; <span class="hljs-comment">//边数</span><br>    AdjList G; <span class="hljs-comment">//邻接表</span><br>&#125;；<br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph;<br><span class="hljs-comment">//以邻接表方式存储的图</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vnode</span>&#123;</span><br>    PtrToAdjVNode FirstEdge;<br>    DataType Data; <span class="hljs-comment">//存顶点的数据</span><br>&#125; AdjList[MaxVertexNum];<br><span class="hljs-comment">// AdjList是邻接表类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span><br>    Vertex AdjV; <span class="hljs-comment">//邻接点下标</span><br>    WeightType Weight; <span class="hljs-comment">// 边权值</span><br>    PtrToAdjVNode Next; <span class="hljs-comment">// 指向下一个</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><br>初始化一个有VertexNum个顶点但没有边的图<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Vertex; <span class="hljs-comment">//用顶点下标表示顶点，为整形</span><br><span class="hljs-function">LGraph <span class="hljs-title">CreateGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> VertexNum)</span></span><br><span class="hljs-function"></span>&#123;<br>    Vertex V,W;<br>    LGraph Graph;<br>    Graph = (LGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct GNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 使得其指针为空</span><br>    <span class="hljs-keyword">for</span>(V = <span class="hljs-number">0</span>;V&lt;Graph-&gt;Nv;V++)&#123;<br>        Graph-&gt;G[V].FirstEdge = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>向LGraph中插入边<br><img src="/img/pics/6.1.6.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">(LGraph Graph, Edge E)</span></span><br><span class="hljs-function"></span>&#123;<br>    PtrToAdjVNode NewNode;<br>    <span class="hljs-comment">//先为V2建立新的邻接点</span><br>    NewNode=(PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V2;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">//再将V2插入V1的表头</span><br>    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;<br>    Graph-&gt;[E-&gt;V1].FirstEdge = NewNode;<br><br>    <span class="hljs-comment">//若是无向图，还要插入&lt;V2,V1&gt;</span><br>    <span class="hljs-comment">//先为V1建立新的邻接点</span><br>    NewNode=(PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V1;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">//再将V1插入V2的表头</span><br>    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;<br>    Graph-&gt;[E-&gt;V2].FirstEdge = NewNode;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h2 id="图（下）"><a href="#图（下）" class="headerlink" title="图（下）"></a>图（下）</h2><h3 id="最小生成树（Minimum-Spanning-Tree"><a href="#最小生成树（Minimum-Spanning-Tree" class="headerlink" title="最小生成树（Minimum Spanning Tree)"></a>最小生成树（Minimum Spanning Tree)</h3><p><strong>最小生成树存在</strong> 和 <strong>图连通</strong> 是一对充分必要条件</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>是一棵树<ul><li>无回路</li><li>V个顶点一定有V-1条边</li></ul></li><li>是生成树<ul><li>包含全部顶点</li><li>V-1条边都在图里</li><li>向生成树中任加一条边都一定构成回路</li></ul></li><li>边的权重和最小</li></ul><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><ul><li>每一步都要最好的</li><li>每次都要权重最小的边</li></ul><p><strong>约束：</strong></p><ul><li><strong>只能用图里有的边</strong></li><li><strong>只能正好用掉V-1条边</strong></li><li><strong>不能有回路</strong></li></ul><h4 id="Prim-普利姆-算法-让一棵小树长大"><a href="#Prim-普利姆-算法-让一棵小树长大" class="headerlink" title="Prim(普利姆)算法-让一棵小树长大"></a>Prim(普利姆)算法-让一棵小树长大</h4><p><strong>注意：构造时需要判断不能构成回路！</strong></p><p>适用于稠密图，算法复杂度为<strong>O(V<sup>2</sup></strong></p><p>算法描述：</p><ol><li>在一个加权连通图中，顶点集合V，边集合为E</li><li>任意选出一个点作为初始顶点,标记为visit,计算所有与之相连接的点的距离，选择距离最短的，标记visit.</li><li>重复以下操作，直到所有点都被标记为visit：<br>在剩下的点中，计算与已标记visit点距离最小的点，标记visit,证明加入了最小生成树。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化：dist[V] = E(s,V)或正无穷</span><br>    <span class="hljs-comment">//        parent[s] = -1</span><br>    MST = &#123;s&#125;;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        V = 未收录顶点中dist最小者;<br>        <span class="hljs-keyword">if</span>(这样的V不存在)&#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">//MST完成了，或者剩下的结点和树之间的距离都是无穷大</span><br>        &#125;<br>        <span class="hljs-comment">//将V收录进MST</span><br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>            <span class="hljs-keyword">if</span>(dist[W]!=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;即没有被收录&quot;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">E</span>(V,W)&lt;dist[W],<span class="hljs-string">&quot;小树长大后，需要更新一下未收录结点和MST的距离&quot;</span>)&#123;<br>                    dist[W] = <span class="hljs-built_in">E</span>(V,W);<br>                    parent[W] = V;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">if</span>(MST中收录的顶点不到V个)<br>         <span class="hljs-comment">//说明图不是连通的</span><br>         &#123;<br>             <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;生成树不存在&quot;</span>);<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="Kruskal算法-将森林合并成树"><a href="#Kruskal算法-将森林合并成树" class="headerlink" title="Kruskal算法-将森林合并成树"></a>Kruskal算法-将森林合并成树</h4><p><strong>注意：构造时需要判断不能构成回路！</strong></p><p>适用于稀疏图，直接选出权重最小的边（每一条边都会连接两棵树，因此是树的合并），直到无法再选出符合条件的边为止。时间复杂度：O(ElogE)</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(Graph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    MST = &#123;&#125;;<br>    <span class="hljs-keyword">while</span>(MST中不到V<span class="hljs-number">-1</span>条边&amp;&amp;E中还有边)&#123;<br>        从E中取一条权重最小的边<span class="hljs-built_in">E</span>(V,W); <span class="hljs-comment">//最小堆</span><br>        将<span class="hljs-built_in">E</span>(V,W)从E中删除；<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">E</span>(V,W)不在MST中构成回路)<br>            将<span class="hljs-built_in">E</span>(V,W)加入MST;<br>        <span class="hljs-keyword">else</span><br>            彻底无视<span class="hljs-built_in">E</span>(V,W);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(MST中不到V<span class="hljs-number">-1</span>条边)<br>        <span class="hljs-built_in">ERROR</span>(<span class="hljs-string">&quot;生成树不存在&quot;</span>)；<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul><li>AOV(activity on vertex)网络,活动仅发生在顶点处。</li><li>拓扑序：如果图中从V到W有一条有向路径，则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序</li><li>获得一个拓扑序的过程就是拓扑排序</li><li>AOV如果有合理的拓扑序，则必定是有向无环图（Directed Acyclic Graph, DAG)<br><img src="/img/pics/8.2.1.png" alt=""></li></ul><p>算法：</p><ul><li>每次选择入度为0的顶点（没有前置结点）</li><li>每次输出后，要把被输出的点和他对应的边给抹除</li><li>不断这样一层一层输出，即可得到拓扑序<br><img src="/img/pics/8.2.2.png" alt=""><br><img src="/img/pics/8.2.3.png" alt=""></li></ul><p>O(V<sup>2</sup>)<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TopSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(cnt = <span class="hljs-number">0</span>; cnt&lt;V;cnt++)&#123;<br>        V = 未输出的入度为<span class="hljs-number">0</span>的顶点; <span class="hljs-comment">//这一步的扫描很耗时（O(N)）</span><br>        <span class="hljs-keyword">if</span>(这样的V不存在)&#123;  <span class="hljs-comment">//即，外循环还没结束，就碰到入度始终不为0的结点</span><br>            <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;图中有回路&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        输出V，或者记录V的输出序号;<br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>            Indegree[W]--;<span class="hljs-comment">//入度减少</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 更加聪明的算法：随时将入度变为0的顶点放到一个容器里，这样就不用扫描</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TopSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(图中每个顶点V)&#123;<br>        <span class="hljs-keyword">if</span>(Indegree[V]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">Enqueue</span>(V,Q);<br>        &#125;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br>            V = <span class="hljs-built_in">Dequeue</span>(Q);<br>            输出V，或者记录V的输出序号;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>                <span class="hljs-keyword">if</span>(--Indegree[W]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">Enqueue</span>(W,Q); <span class="hljs-comment">//碰到入度为0的直接加入队列，就不用额外重新扫描</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt != V)&#123;<br>        <span class="hljs-built_in">ERROR</span>(<span class="hljs-string">&quot;图中有回路&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>这个算法还可以用来检测一个有向图是否是有向无环图(DAG)</p><h4 id="关键路径问题"><a href="#关键路径问题" class="headerlink" title="关键路径问题"></a>关键路径问题</h4><p>AOE(Activity On Edge)网络</p><ul><li>一般用于安排项目的工序<br><img src="/img/pics/8.2.4.png" alt=""></li></ul><p>工期安排举例：<br><img src="/img/pics/8.2.5.png" alt=""></p><p>关键路径则是由<strong>绝对不允许延误</strong>的活动组成的路径</p><h2 id="排序（上）"><a href="#排序（上）" class="headerlink" title="排序（上）"></a>排序（上）</h2><p>模板：</p><h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h4><p>改进：设立一个flag标志一次循环中是否有做交换（swap）若没有做交换，则认为其余序列已经是有序的，则可以直接跳出，节省时间。</p><p>最好情况：顺序，T=O(N)<br><br>最坏情况：逆序，T=O(N<sup>2</sup>)</p><p>优点：可与适配数组和链表，而且在由于只在值不同时才做交换，是稳定的。<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (P=N<span class="hljs-number">-1</span>;P&gt;=<span class="hljs-number">0</span>;P--)&#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;P;i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i]&gt;A[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(A[i], A[i+<span class="hljs-number">1</span>]);<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h4><p>最好情况：顺序，T=O(N)<br><br>最坏情况：逆序，T=O(N<sup>2</sup>)<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insertion_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(P=<span class="hljs-number">1</span>;P&lt;N;P++)&#123;<br>        Tmp = A[P]; <br>        <span class="hljs-keyword">for</span>(i=P; i&gt;<span class="hljs-number">0</span> &amp;&amp; A[i<span class="hljs-number">-1</span>] &gt; Tmp; i--)&#123;<br>            A[i] = A[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//数据往后逐个拷贝移位</span><br>        &#125;<br>        A[i] = Tmp; <span class="hljs-comment">//插入</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>由于只有在牌大小不同时才移位，这种排序也是稳定的</p><h4 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h4><ul><li>对于下标i<j，如果A[i]>A[j], 则称(i,j)是一对逆序对(inversion)</li><li>交换2个相邻元素正好消去1个逆序对!</li><li>因此插入和冒泡对于同一个数列的交换次数一样不是巧合</li><li>插入排序：T(N,I)=O(N+I)<ul><li>如果序列基本有序，则插入排序简单有效</li></ul></li><li>任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对。</li><li>定理:任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为Ω(N<sup>2</sup>)<ul><li>因此，要提高效率，必须<ul><li>每次消去不止一个的逆序对</li><li>每次交换相隔较远的2个元素</li></ul></li></ul></li></ul><h3 id="希尔排序（Shell-sort）（不稳定）"><a href="#希尔排序（Shell-sort）（不稳定）" class="headerlink" title="希尔排序（Shell sort）（不稳定）"></a>希尔排序（Shell sort）（不稳定）</h3><p>即采取设定间隔来采样，并对采样值分别做插入排序.<br><img src="/img/pics/9.1.1.png" alt=""></p><p>希尔排序为什么不稳定？</p><blockquote><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p></blockquote><p>流程：</p><ol><li>定义一个增量序列作为采样间隔DM&gt;DM-1&gt;…&gt;D1=1，最后一位必须是1，比如{5, 3, 1}</li><li>对每个采样间隔进行“Dk-间隔排序”，比如对按照5-间隔滑动采样出来的5个序列分别进行插入排序。</li><li><strong>注意:“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk间隔”有序的，这是希尔排序的关键</strong></li></ol><p>注意：需要保证增量序列的互质！增量元素不互质，则小增量可能根本不起作用，如：<br><img src="/img/pics/9.1.2.png" alt=""></p><p>因此增量序列的设计是关键的，如这里采用Sedgwick</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 希尔排序 - 用Sedgewick增量序列 */</span><br>     <span class="hljs-keyword">int</span> Si, D, P, i;<br>     ElementType Tmp;<br>     <span class="hljs-comment">/* 这里只列出一小部分增量 */</span><br>     <span class="hljs-keyword">int</span> Sedgewick[] = &#123;<span class="hljs-number">929</span>, <span class="hljs-number">505</span>, <span class="hljs-number">209</span>, <span class="hljs-number">109</span>, <span class="hljs-number">41</span>, <span class="hljs-number">19</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>     <br>     <span class="hljs-keyword">for</span> ( Si=<span class="hljs-number">0</span>; Sedgewick[Si]&gt;=N; Si++ ) <br>         ; <span class="hljs-comment">/* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br><br>     <span class="hljs-keyword">for</span> ( D=Sedgewick[Si]; D&gt;<span class="hljs-number">0</span>; D=Sedgewick[++Si] )<br>         <span class="hljs-keyword">for</span> ( P=D; P&lt;N; P++ ) &#123; <span class="hljs-comment">/* 插入排序*/</span><br>             Tmp = A[P];<br>             <span class="hljs-keyword">for</span> ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )<br>                 A[i] = A[i-D];<br>             A[i] = Tmp;<br>         &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="选择排序（不稳定），堆排序（不稳定）"><a href="#选择排序（不稳定），堆排序（不稳定）" class="headerlink" title="选择排序（不稳定），堆排序（不稳定）"></a>选择排序（不稳定），堆排序（不稳定）</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序和插入排序的差别：插入排序是选择给定序列中最近的一组逆序对交换，而选择排序则是寻找全局最小元，并将其换到序列的最后位置</p><p>选择排序是不稳定的。</p><blockquote><p>举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p></blockquote><p>选择排序算法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Selection_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt; N; i++)&#123;<br>        MinPosition = <span class="hljs-built_in">ScanForMin</span>(A, i, N<span class="hljs-number">-1</span>); <span class="hljs-comment">//这一步scanformin需要O(N)的复杂度，可以用最小堆优化</span><br>        <span class="hljs-comment">// 从到中寻找最小元，并将其位置赋给MinPosition</span><br>        <span class="hljs-built_in">Swap</span>(A[i], A[MinPosition]&#125;);<br>        <span class="hljs-comment">// 将未排序部分的最小元换到有序部分的最后位置</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>（实际中，堆排序可能不如Sedgwick序列的希尔排序好用）</p><p>简单的情况：调用一个最小堆，使用时让其返回根节点（最小值）即可。</p><p><a href="https://zhidao.baidu.com/question/589205766.html">堆排序不是稳定的</a><br><a href="https://blog.csdn.net/weixin_39996908/article/details/111108431">为什么需要判断排序是否稳定</a></p><blockquote><p>在需要对多个(也意味着多次)具有优先级的关键字进行排序的场景下，稳定排序能利用上一次排序的结果服务于本次排序，从而保证对于值相同的元素的两次排序结果相同。</p></blockquote><p>算法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_Sort</span> <span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">BuildHeap</span>(A); <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        TmpA[i] = <span class="hljs-built_in">DeleteMin</span>(A); <span class="hljs-comment">//O(logN)</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123; <span class="hljs-comment">//这一步需要额外的O(N)空间，且复制也需要时间</span><br>        A[i] = TmpA[i];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>另一种算法，直接在原数组上操作，不需额外开辟空间复制元素</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PercDown</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br>  <span class="hljs-comment">/* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */</span><br>    <span class="hljs-keyword">int</span> Parent, Child;<br>    ElementType X;<br><br>    X = A[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span><br>    <span class="hljs-keyword">for</span>( Parent=p; (Parent*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&lt;N; Parent=Child ) &#123;<br>        Child = Parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>( (Child!=N<span class="hljs-number">-1</span>) &amp;&amp; (A[Child]&lt;A[Child+<span class="hljs-number">1</span>]) )<br>            Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span><br>        <span class="hljs-keyword">if</span>( X &gt;= A[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span><br>            A[Parent] = A[Child];<br>    &#125;<br>    A[Parent] = X;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 堆排序 */</span><br>     <span class="hljs-keyword">int</span> i;<br>      <br>     <span class="hljs-keyword">for</span> ( i=N/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i-- )<span class="hljs-comment">/* 建立最大堆 */</span><br>         <span class="hljs-built_in">PercDown</span>( A, i, N );<br>     <br>     <span class="hljs-keyword">for</span> ( i=N<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; i-- ) &#123;<br>         <span class="hljs-comment">/* 删除最大堆顶 */</span><br>         <span class="hljs-built_in">Swap</span>( &amp;A[<span class="hljs-number">0</span>], &amp;A[i] ); <span class="hljs-comment">/* 见代码7.1 */</span><br>         <span class="hljs-built_in">PercDown</span>( A, <span class="hljs-number">0</span>, i );<br>     &#125;<br></code></pre></div></td></tr></table></figure><h3 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h3><p>是一种<strong>稳定</strong>的排序，算法复杂度也低。唯一的不好是需要额外的空间<br></p><p>内排序：指在排序期间数据对象全部存放在内存的排序。<br>外排序：指在排序期间全部对象太多，不能同时存放在内存中，必须根据排序过程的要求，不断在内，外存间移动的排序。<br><br>归并排序适用于外排序，不适用于内排序</p><h4 id="有序子列的归并"><a href="#有序子列的归并" class="headerlink" title="有序子列的归并"></a>有序子列的归并</h4><p>类似多项式相加的思想：<br><img src="/img/pics/9.2.1.png" alt=""></p><p>算法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">( ElementType A[], ElementType TmpA[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> RightEnd )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span><br>     <span class="hljs-keyword">int</span> LeftEnd, NumElements, Tmp;<br>     <span class="hljs-keyword">int</span> i;<br>     <br>     LeftEnd = R - <span class="hljs-number">1</span>; <span class="hljs-comment">/* 左边终点位置 */</span><br>     Tmp = L;         <span class="hljs-comment">/* 有序序列的起始位置 */</span><br>     NumElements = RightEnd - L + <span class="hljs-number">1</span>;<br>     <br>     <span class="hljs-keyword">while</span>( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;<br>         <span class="hljs-keyword">if</span> ( A[L] &lt;= A[R] )<br>             TmpA[Tmp++] = A[L++]; <span class="hljs-comment">/* 将左边元素复制到TmpA */</span><br>         <span class="hljs-keyword">else</span><br>             TmpA[Tmp++] = A[R++]; <span class="hljs-comment">/* 将右边元素复制到TmpA */</span><br>     &#125;<br><br>     <span class="hljs-keyword">while</span>( L &lt;= LeftEnd )<br>         TmpA[Tmp++] = A[L++]; <span class="hljs-comment">/* 直接复制左边剩下的 */</span><br>     <span class="hljs-keyword">while</span>( R &lt;= RightEnd )<br>         TmpA[Tmp++] = A[R++]; <span class="hljs-comment">/* 直接复制右边剩下的 */</span><br>         <br>     <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; NumElements; i++, RightEnd -- )<br>         A[RightEnd] = TmpA[RightEnd]; <span class="hljs-comment">/* 将有序的TmpA[]复制回A[] */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>分而治之。<br><img src="/img/pics/9.2.2.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Msort</span><span class="hljs-params">( ElementType A[], ElementType TmpA[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> RightEnd )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 核心递归排序函数 */</span> <br>     <span class="hljs-keyword">int</span> Center;<br>     <br>     <span class="hljs-keyword">if</span> ( L &lt; RightEnd ) &#123;<br>          Center = (L+RightEnd) / <span class="hljs-number">2</span>;<br>          <span class="hljs-built_in">Msort</span>( A, TmpA, L, Center );              <span class="hljs-comment">/* 递归解决左边 */</span> <br>          <span class="hljs-built_in">Msort</span>( A, TmpA, Center+<span class="hljs-number">1</span>, RightEnd );     <span class="hljs-comment">/* 递归解决右边 */</span>  <br>          <span class="hljs-built_in">Merge</span>( A, TmpA, L, Center+<span class="hljs-number">1</span>, RightEnd );  <span class="hljs-comment">/* 合并两段有序序列 */</span> <br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-comment">/* 归并排序 - 循环实现 */</span><br><span class="hljs-comment">/* 这里Merge函数在递归版本中给出 */</span><br><br><span class="hljs-comment">/* length = 当前有序子列的长度*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge_pass</span><span class="hljs-params">( ElementType A[], ElementType TmpA[], <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> length )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 两两归并相邻有序子列 */</span><br>     <span class="hljs-keyword">int</span> i, j;<br>      <br>     <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i &lt;= N<span class="hljs-number">-2</span>*length; i += <span class="hljs-number">2</span>*length )<br>         <span class="hljs-built_in">Merge</span>( A, TmpA, i, i+length, i+<span class="hljs-number">2</span>*length<span class="hljs-number">-1</span> );<br>     <span class="hljs-keyword">if</span> ( i+length &lt; N ) <span class="hljs-comment">/* 归并最后2个子列*/</span><br>         <span class="hljs-built_in">Merge</span>( A, TmpA, i, i+length, N<span class="hljs-number">-1</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 最后只剩1个子列*/</span><br>         <span class="hljs-keyword">for</span> ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge_Sort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <br>     <span class="hljs-keyword">int</span> length; <br>     ElementType *TmpA;<br>     <br>     length = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 初始化子序列长度*/</span><br>     TmpA = <span class="hljs-built_in">malloc</span>( N * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( ElementType ) );<br>     <span class="hljs-keyword">if</span> ( TmpA != <span class="hljs-literal">NULL</span> ) &#123;<br>          <span class="hljs-keyword">while</span>( length &lt; N ) &#123;<br>              <span class="hljs-built_in">Merge_pass</span>( A, TmpA, N, length );<br>              length *= <span class="hljs-number">2</span>;<br>              <span class="hljs-built_in">Merge_pass</span>( TmpA, A, N, length );<br>              length *= <span class="hljs-number">2</span>;<br>          &#125;<br>          <span class="hljs-built_in">free</span>( TmpA );<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;空间不足&quot;</span> );<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="排序（下）"><a href="#排序（下）" class="headerlink" title="排序（下）"></a>排序（下）</h2><h3 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h3><p>算法思想：分而治之<br><br>使用主元（pivot）将数据分成两块<br><img src="/img/pics/10.1.1.png" alt=""></p><p>伪码描述：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Quicksort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(N&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    pivot = 从A[]中选一个主元  &lt;- 这一步很关键<br>    将S=&#123;A[]\pivot&#125;分成两个独立子集： &lt;- 这一步也很关键<br>        A1 = &#123; a∈S | a≤pivot &#125; 和<br>        A2 = &#123; a∈S | a≥pivot &#125;;<br>    A[] = <span class="hljs-built_in">Quicksort</span>(A1,N1)∪&#123;pivot&#125;∪<span class="hljs-built_in">Quicksort</span>(A2,N2)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><p>当每次正好中分时，是快排算法的最好情况，此时O(NlogN)</p><h4 id="怎么选择主元"><a href="#怎么选择主元" class="headerlink" title="怎么选择主元"></a>怎么选择主元</h4><ul><li>经典方法：取头、中、尾的中位数（一共就3个元素）（如8、12、3的中位数是8）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">Median3</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right )</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">int</span> Center = (Left+Right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> ( A[Left] &gt; A[Center] )<br>        <span class="hljs-built_in">Swap</span>( &amp;A[Left], &amp;A[Center] );<br>    <span class="hljs-keyword">if</span> ( A[Left] &gt; A[Right] )<br>        <span class="hljs-built_in">Swap</span>( &amp;A[Left], &amp;A[Right] );<br>    <span class="hljs-keyword">if</span> ( A[Center] &gt; A[Right] )<br>        <span class="hljs-built_in">Swap</span>( &amp;A[Center], &amp;A[Right] );<br>    <span class="hljs-comment">/* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span><br>    <span class="hljs-built_in">Swap</span>( &amp;A[Center], &amp;A[Right<span class="hljs-number">-1</span>] ); <span class="hljs-comment">/* 将基准Pivot藏到右边*/</span><br>    <span class="hljs-comment">/* 只需要考虑A[Left+1] … A[Right-2] */</span><br>    <span class="hljs-keyword">return</span>  A[Right<span class="hljs-number">-1</span>];  <span class="hljs-comment">/* 返回基准Pivot */</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="怎么划分子集"><a href="#怎么划分子集" class="headerlink" title="怎么划分子集"></a>怎么划分子集</h4><p>快排之所以快的原因在于子集划分之后，它的主元被一次性地放到了正确的位置上，以后不再移动，而不像插入排序那样之后还可能要移动。</p><p>如果有元素正好等于pivot，则停下来交换，这样可以保证pivot最后会处于比较中心的位置，对于递归来说是有好处的</p><p>初始状态，6为pivot，初始化两个指针i和j，分别往右和往左移<br><br>i所指向的值应该比6小，否则就发出红色警告，j反之。<br><img src="/img/pics/10.1.2.png" alt=""><br>一边发出红色警告则停止，让另一边开始移动；如果两边都发出红色警告，则停止<br><img src="/img/pics/10.1.3.png" alt=""><br>并交换他们所指向的元素。<br><img src="/img/pics/10.1.4.png" alt=""><br>然后进行下一轮的比较，如果没有发出警报就一直右移/左移<br><img src="/img/pics/10.1.5.png" alt=""><br>交换，<br><img src="/img/pics/10.1.6.png" alt=""><br>直到检测到i，j错位，则结束，并将pivot交换到i的位置<br><img src="/img/pics/10.1.7.png" alt=""></p><h4 id="对于小规模数据的处理："><a href="#对于小规模数据的处理：" class="headerlink" title="对于小规模数据的处理："></a>对于小规模数据的处理：</h4><ul><li>快速排序的问题<ul><li>用到递归</li><li>对小规模的数据（例如N不到100）可能还不如插入排序快</li></ul></li><li>解决方案<ul><li>当递归的数据规模小于一个阈值，则停止递归，直接调用简单排序（例如插入排序）</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Qsort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 核心递归函数 */</span> <br>     <span class="hljs-keyword">int</span> Pivot, Cutoff, Low, High;<br>      <span class="hljs-comment">// Cutoff是阈值</span><br>     <span class="hljs-keyword">if</span> ( Cutoff &lt;= Right-Left ) &#123; <span class="hljs-comment">/* 如果序列元素充分多，进入快排 */</span><br>          Pivot = <span class="hljs-built_in">Median3</span>( A, Left, Right ); <span class="hljs-comment">/* 选基准 */</span> <br>          Low = Left; High = Right<span class="hljs-number">-1</span>;<br>          <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*将序列中比基准小的移到基准左边，大的移到右边*/</span><br>               <span class="hljs-keyword">while</span> ( A[++Low] &lt; Pivot ) ;<br>               <span class="hljs-keyword">while</span> ( A[--High] &gt; Pivot ) ;<br>               <span class="hljs-keyword">if</span> ( Low &lt; High ) <span class="hljs-built_in">Swap</span>( &amp;A[Low], &amp;A[High] );<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-built_in">Swap</span>( &amp;A[Low], &amp;A[Right<span class="hljs-number">-1</span>] );   <span class="hljs-comment">/* 将基准换到正确的位置 */</span> <br>          <span class="hljs-built_in">Qsort</span>( A, Left, Low<span class="hljs-number">-1</span> );    <span class="hljs-comment">/* 递归解决左边 */</span> <br>          <span class="hljs-built_in">Qsort</span>( A, Low+<span class="hljs-number">1</span>, Right );   <span class="hljs-comment">/* 递归解决右边 */</span>  <br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-built_in">InsertionSort</span>( A+Left, Right-Left+<span class="hljs-number">1</span> ); <span class="hljs-comment">/* 元素太少，用简单排序 */</span> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 统一接口 */</span><br>     <span class="hljs-built_in">Qsort</span>( A, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span> );<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h3><p>每个元素是具体的，庞大的一个实体（如，一部5G的电影，一个3G的ZIP），这时对其进行任何频繁的swap都是不切实际的。<br><br>表排序不移动元素本身，只移动指针，这种排序方法叫做<strong>间接排序</strong>。</p><p>间接排序</p><ul><li>定义一个指针数组作为表(table)</li><li>只需修改指针数组即可</li><li>输出时直接输出排序后的指针数组所对应的元素<br><img src="/img/pics/10.2.1.png" alt=""><br>如果仅仅要求按顺序输出，则输出：<br><br>A[table[0]],A[table[1]],…,A[table[N-1]]</li></ul><h4 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h4><p>N个数字的排列由若干个独立的环组成，按顺序地移位每一个独立的环。<br><br>如果table[i] == i，则说明这个物体已经在他该待的位置上了（环中只有他一个元素）</p><h3 id="基数排序（Radix-sort）（稳定）"><a href="#基数排序（Radix-sort）（稳定）" class="headerlink" title="基数排序（Radix sort）（稳定）"></a>基数排序（Radix sort）（稳定）</h3><p>只能用于有基数的东西。对于结构体排序，或者只有相对大小关系，没有具体数值（比如你要自己写判断大小的函数），那么基数排序就没法使用（因为它不是基于比较的）。<br><br>基于比较的排序下界就是O(nlogn)，基数排序不是基于比较的排序，而是基于数据分配，所以可以突破下界</p><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>引例：假设我们有N个学生，他们的成绩是0到100之间的整数(于是有M=101个不同的成绩值)。如何在线性时间内将学生按成绩排序?<br><br>由于只有101个不同的成绩值，可以直接分成101个不同的桶，数据便可扫描一遍就对号入座，接入对应的链表里。输出时只需直接按顺序输出链表即可<br><img src="/img/pics/10.3.1.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bucket_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span> </span><br><span class="hljs-function"></span>&#123;  count[]初始化;<br>   <span class="hljs-keyword">while</span> (读入<span class="hljs-number">1</span>个学生成绩grade)<br>      将该生插入count[grade]链表;<br>   <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;M; i++ ) &#123;<br>      <span class="hljs-keyword">if</span> ( count[i] )<br>         输出整个count[i]链表;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是如果M比N大很多怎么办呢？加入M=1000，N=10，那就要建1000个桶，很不划算。这时可以使用基数排序。这里的基数指进制的基数，比如10进制则为10</p><p>如果按照<strong>次位优先(Least Significant Digit, LSD)</strong>，则：<br><img src="/img/pics/10.3.2.png" alt=""></p><p>基数排序的算法复杂度取决于桶的个数。如果桶比较少的话，复杂度接近线性。</p><h4 id="多关键字的排序"><a href="#多关键字的排序" class="headerlink" title="多关键字的排序"></a>多关键字的排序</h4><p>引例：扑克牌的排序，花色是主关键字，面值是次关键字。<br><img src="/img/pics/10.3.3.png" alt=""></p><p>运用基数排序，如果把主关键字作为高位，次关键字作为低位，就用到了<strong>主位优先(Most Significant Digit, MSD)</strong>。</p><ol><li>第一种办法：<br>为4种花色建立4个桶，再在每个花色桶里对数值进行排序——这样效率不高</li><li>第二种方法：用次位优先：<br>先为面值建立13个桶，将结果合并，然后再为花色建立4个桶。—-效率大大提高（实际上在现实生活中，也倾向于用第二种方法分扑克牌。但是相较于第一种方法，显然地，第二种需要占用的桌面，或者说空间，要大得多。）</li></ol><h3 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h3><p><a href="https://www.cnblogs.com/knull/archive/2012/12/11/2813724.html">常见排序算法的代码实例</a></p><div class="table-container"><table><thead><tr><th>排序方法</th><th>平均时间复杂度</th><th>最坏情况下时间复杂度</th><th>额外空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>简单选择排序</td><td>O(N<sup>2</sup>)</td><td>O(N<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(N<sup>2</sup>)</td><td>O(N<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td>插入排序</td><td>O(N<sup>2</sup>)</td><td>O(N<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(N<sup>d</sup>)</td><td>O(N<sup>2</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>快速排序</td><td>O(NlogN)</td><td>O(N<sup>2</sup>)</td><td>O(logN)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(NlogN)</td><td>O(NlogN)</td><td>O(N)</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(P(N+B))</td><td>O(P(N+B))</td><td>O(N+B)</td><td>稳定</td></tr></tbody></table></div><h2 id="散列查找（哈希）"><a href="#散列查找（哈希）" class="headerlink" title="散列查找（哈希）"></a>散列查找（哈希）</h2><p>目前已经学过的查找方法：</p><ol><li>顺序查找 O(N)</li><li>二分查找（静态查找），需要先把数据从小到大排好 O(log<sub>2</sub>N)</li><li>二叉搜索树 O(h) h为二叉查找树的高度</li><li>平衡二叉树(AVL) O(log<sub>2</sub>N)</li></ol><p>对于二叉查找，对于 10亿 的用户，查找30次即可，且只需要1T的连续空间。但是因为账户数据是按大小有序存储的，插入和删除一个新的QQ号码将需要移动大量数据。</p><p><strong>查找的本质：</strong>已知对象，查找位置</p><ul><li>如果是有序安排对象：全序、半序</li><li>直接“算出”对象位置：散列/哈希</li></ul><p>散列查找的两项基本工作：</p><ul><li>计算位置：构造合适的散列函数(哈希函数)来确定关键词的存储位置</li><li>解决冲突：应用某种策略解决多个关键词位置相同的问题</li></ul><p>哈希的时间复杂度几乎是常量：O(1),也就是说查找时间与问题的规模无关！</p><p>以空间换时间</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表的数据结构描述：</p><p>类型名称:符号表（SymbolTable）</p><p>数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合。</p><p>操作集：Table$\in$SymbolTable，Name$\in$NameType，Attr$\in$AttributeType</p><ol><li>SymbolTable InitializeTable( int TableSize )： 创建一个长度为TableSize的符号表；</li><li>Boolean IsIn( SymbolTable Table, NameType Name)： 查找特定的名字Name是否在符号表Table中；</li><li>AttributeType Find( SymbolTable Table, NameType Name)： 获取Table中指定名字Name对应的属性；</li><li>SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)： 将Table中指定名字Name的属性修改为Attr；</li><li>SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)： 向Table中插入一个新名字Name及其属性Attr；</li><li>SymbolTable Delete(SymbolTable Table, NameType Name)： 从Table中删除一个名字Name及其属性。</li></ol><p>“散列（Hashing）” 的基本思想是：</p><ul><li>以关键字key为自变量，通过一个确定的函数 h（散列函数），计算出对应的函数值h(key)，作为数据对象的存储地址。</li><li>可能不同的关键字会映射到同一个散列地址上， 即h(key<sub>i</sub>) = h(key<sub>j</sub>)（当key<sub>&lt;/sub&gt; ≠key<sub>j</sub>），称为“冲突(Collision)”。</li><li>因此需要某种冲突解决策略</li></ul><p>举例：<br><br>有n = 11个数据对象的集合{18，23，11，20，2，7，27，30，<br>42，15，34}。<br><br>符号表的大小用TableSize = 17，选取散列函数h如下：<br>h(key) = key mod TableSize (求余)<br><img src="/img/pics/11.1.1.png" alt=""></p><ol><li><p>存放：<br> h(18)=1, h(23)=6, h(11)=11, h(20)=3, h(2)=2, …….<br><br> 如果新插入35， h(35)=1, 该位置已有对象！冲突！！(潜在解决办法：使用二维数组，先匹配到对应的行的第一列，如果有冲突，加到该行的后续的列)</p></li><li><p>查找：<br>key = 22, h(22)= 5，该地址空，不在表中<br><br>key = 30, h(30)= 13，该地址存放是30，找到！</p></li></ol><p>装填因子（Loading Factor）：设散列表空间大小为m，填入表<br>中元素个数是n，则称α＝ n / m为散列表的装填因子α＝11 / 17 ≈ 0.65</p><h3 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h3><p>一个“好”的散列函数一般应考虑下列两个因素：</p><ol><li>计算简单，以便提高转换速度；</li><li>关键词对应的地址空间分布均匀，以尽量减少冲突。</li></ol><h4 id="数字关键词的哈希函数构造"><a href="#数字关键词的哈希函数构造" class="headerlink" title="数字关键词的哈希函数构造"></a><strong>数字关键词</strong>的哈希函数构造</h4><ol><li>直接定址法<br>取关键词的某个线性函数值为散列地址，即h(key) = a · key + b (a、b为常数)</li><li>除留余数法<br>哈希函数为：h(key) = key mod p</li><li><p>数字分析法<br>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址<br><br>比如：取11位手机号码key的后4位作为地址：散列函数为：h(key) = atoi(key+7) (char *key），atoi是array to integer函数</p></li><li><p>折叠法<br>把关键词分割成位数相同的几个部分，然后叠加：<br><img src="/img/pics/11.1.2.png" alt=""></p></li><li>平方取中法<br><img src="/img/pics/11.1.3.png" alt=""></li></ol><h4 id="字符关键词的哈希函数构造"><a href="#字符关键词的哈希函数构造" class="headerlink" title="字符关键词的哈希函数构造"></a><strong>字符关键词</strong>的哈希函数构造</h4><p>通过求余mod操作来实现大整数向小整数的映射</p><ol><li><p>一个简单的散列函数——ASCII码加和法<br>对字符型关键词key定义散列函数如下：</p><script type="math/tex; mode=display">h(key) = ( \Sigma key[i]) mod TableSize</script><p>但是这个方法在碰到这些字符时冲突严重：a3, b2, c1; eat, tea</p></li><li><p>简单的改进——前3个字符移位法:</p><script type="math/tex; mode=display">h(key)=(key[0] \times 27^2 + key[1] \times 27 + key[2])mod TableSize</script><p>仍然冲突：string、 street、strong、structure等等；空间浪费：3000/263 ≈ 30%</p></li><li><p>好的散列函数——移位法:<br>涉及关键词所有n个字符，并且分布得很好：</p><script type="math/tex; mode=display">h(key) = (\Sigma_{i=0}^{n-1} key[n - i - 1]\times 32^i ) mod TableSize</script></li></ol><p>快速计算：</p><script type="math/tex; mode=display">h(“abcde”)=‘a’*324+’b’*323+’c’*322+’d’*32+’e’</script><p>巧妙的做法：<br><br>( ( (a x 32 + b) x 32 + c) x 32 + d) …<br><br>而这里更巧妙的是，乘以32实际上就是向左移动5位<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Index <span class="hljs-title">Hash</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *Key, <span class="hljs-keyword">int</span> TableSize )</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>; <span class="hljs-comment">// 散列函数值，初始化为0 </span><br>    <span class="hljs-keyword">while</span> ( *Key != <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-comment">// 这里\0代表字符串的末尾，为空</span><br>        h = ( h &lt;&lt; <span class="hljs-number">5</span> ) + *Key++; <span class="hljs-comment">//左移5位就是乘32，因此虽然ascii码字母只有27，我们还是把进制设为32更方便</span><br>    <span class="hljs-keyword">return</span> h % TableSize;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="冲突的处理"><a href="#冲突的处理" class="headerlink" title="冲突的处理"></a>冲突的处理</h3><h4 id="开放地址法（Open-Addressing）"><a href="#开放地址法（Open-Addressing）" class="headerlink" title="开放地址法（Open Addressing）"></a>开放地址法（Open Addressing）</h4><p>若发生了第 i 次冲突，试探的下一个地址将增加di，基本公式是：</p><script type="math/tex; mode=display">h_i(key) = (h(key)+d_i) mod TableSize ( 1≤ i < TableSize )</script><p>di 决定了不同的解决冲突方案：线性探测($d_i=i$)、平方探测($d_i = \pmi^2$)、双散列($d_1 = i\timesh_2(key$)。</p><h5 id="线性探测法（Linear-Probing）"><a href="#线性探测法（Linear-Probing）" class="headerlink" title="线性探测法（Linear Probing）"></a>线性探测法（Linear Probing）</h5><p>线性探测法：以增量序列 1，2，……，TableSize -1）循环试探下一个存储地址。</p><p>[例] 设关键词序列为 {47，7，29，11，9，84，54，20，30}，</p><ul><li>散列表表长TableSize =13 （装填因子 α = 9/13 ≈ 0.69）；</li><li>散列函数为：h(key) = key mod 11。<br>用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能</li></ul><p><img src="/img/pics/11.1.4.png" alt=""></p><p><img src="/img/pics/11.1.5.png" alt=""></p><p><strong>哈希表查找性能分析</strong></p><ul><li>成功平均查找长度(ASLs)</li><li>不成功平均查找长度(ASLu)</li></ul><p>对于散列表：<br><img src="/img/pics/11.1.6.png" alt=""></p><p>ASLs：查找表中关键词的平均查找比较次数（其冲突次数加1）<br><br>ASLs= （1+7+1+1+2+1+4+2+4）/ 9 = 23/9 ≈ 2.56</p><p>ASLu：不在散列表中的关键词的平均查找次数（不成功）<br><br>一般方法：将不在散列表中的关键词分若干类。<br>如：根据H(key)值分类<br><br>ASL u= （3+2+1+2+1+1+1+9+8+7+6）/ 11 = 41/11 ≈ 3.73</p><h5 id="平方探测法（Quadratic-Probing）—-二次探测"><a href="#平方探测法（Quadratic-Probing）—-二次探测" class="headerlink" title="平方探测法（Quadratic Probing）—- 二次探测"></a>平方探测法（Quadratic Probing）—- 二次探测</h5><p>平方探测法：以增量序列$1^2，-1^2，2^2，-2^2，……，q^2，-q^2$且$q ≤ floor(TableSize/2)$(向下取整)循环试探下一个存储地址。</p><p>[例]设关键词序列为 {47，7，29，11，9，84，54，20，30}，</p><ul><li>散列表表长TableSize = 11，</li><li>散列函数为：h(key) = key mod 11。<br>用平方探测法处理冲突，列出依次插入后的散列表，并估算ASLs。<br><img src="/img/pics/11.2.1.png" alt=""></li></ul><p>ASLs = （1+1+2+1+1+3+1+4+4）/ 9 = 18/9 = 2<br><img src="/img/pics/11.2.2.png" alt=""></p><p>但是，对于某些tablesize，平方探测（二次探测）并不能接触到全部的空间。<br><br>如果散列表长度TableSize是某个4k+3（k是正整<br>数）形式的素数时，平方探测法就可以探查到整个散列表空间</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class"><span class="hljs-title">HashTbl</span> *<span class="hljs-title">HashTable</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span>&#123;</span><br>    <span class="hljs-keyword">int</span> TableSize;<br>    Cell *TheCells;<br>&#125;H ;<br><br><span class="hljs-function">HashTable <span class="hljs-title">InitializeTable</span><span class="hljs-params">( <span class="hljs-keyword">int</span> TableSize )</span></span><br><span class="hljs-function"></span>&#123;<br>    HashTable H;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span> ( TableSize &lt; MinTableSize )&#123;<br>        <span class="hljs-built_in">Error</span>( <span class="hljs-string">&quot;散列表太小&quot;</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">/* 分配散列表 */</span><br>    H = (HashTable)<span class="hljs-built_in">malloc</span>( <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( struct HashTbl ) );<br>    <span class="hljs-keyword">if</span> ( H == <span class="hljs-literal">NULL</span> )<br>        <span class="hljs-built_in">FatalError</span>( <span class="hljs-string">&quot;空间溢出!!!&quot;</span> );<br>    H-&gt;TableSize = <span class="hljs-built_in">NextPrime</span>( TableSize );<br>        <span class="hljs-comment">/* 分配散列表 Cells */</span><br>    H-&gt;TheCells=(Cell *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( Cell )*H-&gt;TableSize);<br>    <span class="hljs-keyword">if</span>( H-&gt;TheCells == <span class="hljs-literal">NULL</span> )<br>        <span class="hljs-built_in">FatalError</span>( <span class="hljs-string">&quot;空间溢出!!!&quot;</span> );<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; H-&gt;TableSize; i++ )<br>        H-&gt;TheCells[ i ].Info = Empty;<br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br><br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( ElementType Key, HashTable H )</span> <span class="hljs-comment">/*平方探测*/</span></span><br><span class="hljs-function"></span>&#123; Position CurrentPos, NewPos;<br>    <span class="hljs-keyword">int</span> CNum; <span class="hljs-comment">/* 记录冲突次数 */</span><br>    CNum = <span class="hljs-number">0</span>;<br>    NewPos = CurrentPos = <span class="hljs-built_in">Hash</span>( Key, H-&gt;TableSize ); <br>    <span class="hljs-keyword">while</span>( H-&gt;TheCells[ NewPos ].Info != Empty &amp;&amp;<br>    H-&gt;TheCells[ NewPos ].Element != Key ) &#123;<br>    <span class="hljs-comment">/* 字符串类型的关键词需要 strcmp 函数!! */</span><br>        <span class="hljs-keyword">if</span>(++CNum % <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">/* 判断冲突的奇偶次 */</span><br>            NewPos = CurrentPos + (CNum+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*(CNum+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">//这里的操作很巧妙，看下图！</span><br>            <span class="hljs-keyword">while</span>( NewPos &gt;= H-&gt;TableSize )<br>            NewPos -= H-&gt;TableSize;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NewPos = CurrentPos - CNum/<span class="hljs-number">2</span> * CNum/<span class="hljs-number">2</span>;<span class="hljs-comment">//这里的操作很巧妙，看下图！</span><br>            <span class="hljs-keyword">while</span>( NewPos &lt; <span class="hljs-number">0</span> )<br>            NewPos += H-&gt;TableSize;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NewPos;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p><img src="/img/pics/11.2.3.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">( ElementType Key, HashTable H )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 插入操作 */</span><br>    Position Pos;<br>    Pos = <span class="hljs-built_in">Find</span>( Key, H );<br>    <span class="hljs-keyword">if</span>( H-&gt;TheCells[ Pos ].Info != Legitimate ) &#123;<br>        <span class="hljs-comment">/* 确认在此插入 */</span><br>        H-&gt;TheCells[ Pos ].Info = Legitimate;<br>        H-&gt;TheCells[ Pos ].Element = Key;<br>        <span class="hljs-comment">/*字符串类型的关键词需要 strcpy 函数!! */</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在开放地址散列表中，删除操作要很小心。 通常只能“懒惰删除”，即需要增加一个“删除标记(Deleted)”，而并不是真正删除它。 以便查找时不会“断链”。其空间可以在下次插入时重用</p><h5 id="双散列探测法（Double-Hashing）"><a href="#双散列探测法（Double-Hashing）" class="headerlink" title="双散列探测法（Double Hashing）"></a>双散列探测法（Double Hashing）</h5><p>di 为i*h<sub>2</sub>(key)，h<sub>2</sub>(key)是另一个散列函数探测序列成：h<sub>2</sub>(key)，2h<sub>2</sub>(key)，3h<sub>2</sub>(key)，……</p><ul><li>对任意的key，h2(key) ≠ 0 </li><li>探测序列还应该保证所有的散列存储单元都应该能够被探测到。 选择以下形式有良好的效果：<br>h<sub>2</sub>(key) = p - (key mod p)<br><br>其中：p &lt; TableSize，p、TableSize都是素数。</li></ul><h5 id="再散列（Rehashing）"><a href="#再散列（Rehashing）" class="headerlink" title="再散列（Rehashing）"></a>再散列（Rehashing）</h5><p>当散列表元素太多（即装填因子 α太大）时，查找效率会下降；</p><p>实用最大装填因子一般取 0.5 &lt;= α&lt;= 0.85</p><p>当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫<br>做“再散列（Rehashing）”</p><p>注意：扩大散列表后，原来的元素需要全部重新计算</p><h5 id="分离链接法✔（Separate-Chaining）"><a href="#分离链接法✔（Separate-Chaining）" class="headerlink" title="分离链接法✔（Separate Chaining）"></a>分离链接法✔（Separate Chaining）</h5><p>分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中</p><p>[例] 设关键字序列为 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89, 94, 21;<br><br>散列函数取为：h(key) = key mod 11；<br><br>用分离链接法处理冲突。<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span> &#123;</span><br> <span class="hljs-keyword">int</span> TableSize;<br> List TheLists;<br>&#125; *H;<br></code></pre></div></td></tr></table></figure><br><img src="/img/pics/11.2.4.png" alt=""></p><p>表中有9个结点只需1次查找，5个结点需要2次查找，查找成功的平均查找次数：<br><br> ASLs=（9+5*2）/ 14 ≈ 1.36</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Position</span>, *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    ElementType Element;<br>    Position Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span> *<span class="hljs-title">HashTable</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span> &#123;</span><br>    <span class="hljs-keyword">int</span> TableSize;<br>    List TheLists;<br>&#125;;<br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( ElementType Key, HashTable H )</span></span><br><span class="hljs-function"></span>&#123; <br>    Position P;<br>    <span class="hljs-keyword">int</span> Pos;<br><br>    Pos = <span class="hljs-built_in">Hash</span>( Key, H-&gt;TableSize ); <span class="hljs-comment">/*初始散列位置*/</span><br>    P = H-&gt;TheLists[Pos]. Next; <span class="hljs-comment">/*获得链表头*/</span><br>    <span class="hljs-keyword">while</span>( P != <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(P-&gt;Element, Key) )<br>        P = P-&gt;Next;<br>    <span class="hljs-keyword">return</span> P;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解操作系统学习笔记</title>
    <link href="/2020/11/08/deep_into_operating_system_tsinghua/"/>
    <url>/2020/11/08/deep_into_operating_system_tsinghua/</url>
    
    <content type="html"><![CDATA[<h1 id="Deep-into-Operating-System"><a href="#Deep-into-Operating-System" class="headerlink" title="Deep into Operating System"></a>Deep into Operating System</h1><hr><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote><p>  第一章的主要内容是 : 操作系统的一些知识</p></blockquote><h3 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h3><p>用户角度：操作系统是一个控制软件</p><span id="more"></span><ul><li>管理应用程序</li><li>为应用程序提供服务</li><li>杀死应用程序</li></ul><p>程序角度：操作系统是资源管理器</p><ul><li>管理外设、分配资源</li><li>抽象<ul><li>将CPU抽象成进程</li><li>将磁盘抽象成文件</li><li>将内存抽象成地址空间</li></ul></li></ul><h3 id="操作系统层次"><a href="#操作系统层次" class="headerlink" title="操作系统层次"></a>操作系统层次</h3><p>位于硬件之上，应用程序之下。</p><h3 id="操作系统的界面和内核"><a href="#操作系统的界面和内核" class="headerlink" title="操作系统的界面和内核"></a>操作系统的界面和内核</h3><p>Linux Windows Android 的界面属于外壳(Shell) ，而不是内核(kernel)。操作系统研究的是内核，处于Shell之下。</p><h3 id="操作系统内部组件"><a href="#操作系统内部组件" class="headerlink" title="操作系统内部组件"></a>操作系统内部组件</h3><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h3 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h3><ul><li>并发<ul><li>一段时间内运行多个进程（并行 : 一个时间点运行多个进程，一般要求有多个CPU)</li><li>需要OS管理和调度</li></ul></li><li>共享<ul><li>“同时”共享</li><li>互斥共享</li></ul></li><li>虚拟<ul><li>让每一个用户觉得的有一个计算机专门为他服务</li></ul></li><li>异步<ul><li>程序是走走停停，而不是一直运行</li></ul></li></ul><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><blockquote><p>  第二章的主要内容是 : 操作系统的异常/中断/系统调用</p></blockquote><h2 id="探究计算机启动过程"><a href="#探究计算机启动过程" class="headerlink" title="探究计算机启动过程"></a>探究计算机启动过程</h2><p><strong>作用解析</strong></p><p>Disk : 存放OS和Bootloader</p><p>BOIS : 基于I/O处理系统</p><p>Bootloader : 加载OS，将OS放入内存</p><p><strong>结构</strong></p><p>Disk</p><p>   |<em>_</em> OS</p><p>   |<em>_</em> Bootloader</p><p><strong>开机流程</strong></p><ol><li><p>BIOS</p><ul><li>开机后，寻找显卡和执行BIOS (此时, <code>CS : IP = 0xF000 : 0xFFF0</code>,  CS/IP 两个寄存器) </li><li>将Bootloader从磁盘的引导扇区加载到0x7C00 (Bootloader一共占用512M字节的内存)</li><li>跳转到 <code>CS : IP = 0x0000 : 0x7C00</code></li></ul></li><li><p>Bootloader</p><ul><li>将操作系统的代码和数据从硬盘加载到内存中</li><li>跳转到操作系统的起始地址</li></ul></li></ol><h2 id="中断、异常、系统调用"><a href="#中断、异常、系统调用" class="headerlink" title="中断、异常、系统调用"></a>中断、异常、系统调用</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断来源于外设，来自不同的硬件设备的计时器和网络的中断。</p><p><strong>中断流程</strong></p><p>硬件：设置中断标记（CPU初始化）</p><ol><li>将内部、外部事件设置中断标记</li><li>中断事件的ID</li></ol><p>软件</p><ol><li>保存当前处理状态（寄存器之类的一些数据）</li><li>根据中断事件的ID跳转到中断服务程序，中断服务程序处理</li><li>清楚中断标记</li></ol><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常来源于不良的应用程序，非法指令或者其他坏的处理状态（如：内存出错）。</p><p><strong>异常处理流程</strong></p><ol><li>保存现场</li><li>异常处理<ol><li>杀死了产生异常的程序</li><li>重新执行异常指令</li></ol></li><li>恢复现场</li></ol><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用来源于应用程序，应用程序主动向操作系统发出服务请求。程序访问主要是通过高层次的API，而不是直接调用系统调用函数。</p><p><strong>APIs</strong></p><ul><li>Win32 API 用于Windows</li><li>POSIX API 用于 POSIX-based systems（包括UNIX，LINUX，Mac OS X）</li><li>Java API 用于JAVA虚拟机</li></ul><p><strong>特点</strong></p><ul><li>通常情况下，每个系统调用有对应的序号<ul><li>系统调用接口根据这些序号来维护表的索引</li></ul></li><li>系统调用接口调用内核态中预期的系统调用<ul><li>并返回系统调用的状态和其他任何返回值</li></ul></li><li>用户不需要知道系统调用是如何实现的<ul><li>只需要获取API和了解操作系统将什么作为返回结果</li><li>操作系统接口的细节大部分都隐藏在API中</li></ul></li></ul><p><strong>用户态</strong>：操作系统运行中，CPU处于的特权级别，不能直接执行特权指令</p><p><strong>内核态</strong>：操作系统运行中，CPU处于的特权级别，可以执行任何一条指令</p><p><strong>系统调用</strong>：触发CPU从用户态到内核态的转换，切换程序和内核的堆栈，需要一定的开销</p><p><strong>跨越操作系统边界的开销（值得的且必须的，保证了操作系统的安全性）</strong></p><ul><li>在执行时间上的开销超过程序调用</li><li>开销：<ul><li>建立中断、异常、系统调用号与对应服务例程映射关系的初始化开销</li><li>建立内核堆栈</li><li>验证参数</li><li>内核态映射到用户态的地址空间（更新页面映射权限）</li><li>内核态独立地址空间（TLB）</li></ul></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="table-container"><table><thead><tr><th>类型</th><th>源头</th><th>处理时间</th><th>响应</th></tr></thead><tbody><tr><td>中断</td><td>外设</td><td>异步</td><td>持续，对应用程序透明</td></tr><tr><td>异常</td><td>应用程序意向不到的行为</td><td>同步</td><td>杀死或重新执行指令</td></tr><tr><td>系统调用</td><td>应用程序请求系统提供服务</td><td>同步或异步</td><td>等待和持续</td></tr></tbody></table></div><blockquote><p>  异步：应用程序不知道什么时候会发生中断</p><p>  同步：执行到某一条指令一定会发生该事件</p></blockquote><h3 id="为什么应用程序不能直接访问硬件？"><a href="#为什么应用程序不能直接访问硬件？" class="headerlink" title="为什么应用程序不能直接访问硬件？"></a>为什么应用程序不能直接访问硬件？</h3><ul><li>在计算机运行时，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>为了方便应用程序</li></ul><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><blockquote><p>  第三章的主要内容是 : 操作系统的物理内存管理</p></blockquote><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><ol><li>CPU</li><li>内存</li><li>I/O</li></ol><h2 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><h3 id="内存分层体系-1"><a href="#内存分层体系-1" class="headerlink" title="内存分层体系"></a>内存分层体系</h3><p>运行内存(主存) / 磁盘(虚拟内存). 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.</p><p>CPU可以访问的内存包括两大类 : 寄存器 / cache(L1缓存 / L2缓存)</p><p><strong>层次</strong></p><p>微处理器(CPU访问)</p><p>|___CPU寄存器 / L1缓存</p><p>|___L2缓存</p><p>主存(程序访问)</p><p>磁盘(程序访问)</p><blockquote><p>  从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。</p></blockquote><h3 id="内存管理目标"><a href="#内存管理目标" class="headerlink" title="内存管理目标"></a>内存管理目标</h3><ul><li><p>抽象：逻辑地址空间</p></li><li><p>保护：独立地址空间</p></li><li><p>共享：访问相同内存</p></li><li><p>虚拟：更多的地址空间</p></li></ul><h3 id="内存管理方法"><a href="#内存管理方法" class="headerlink" title="内存管理方法"></a>内存管理方法</h3><ul><li>程序重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li><li>按需分页虚拟内存</li></ul><blockquote><p>  实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求</p></blockquote><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间的定义</p><ul><li>物理地址空间 —— 硬件支持的地址空间( address : [0, Max_sys] )</li><li>逻辑地址空间 —— 一个运行在程序所拥有的的内存范围( address : [0, Max_prog] )</li></ul><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><h3 id="内存碎片问题"><a href="#内存碎片问题" class="headerlink" title="内存碎片问题"></a>内存碎片问题</h3><p>内存碎片问题指的是空闲的内存无法被利用</p><ul><li>外部碎片 : 分配单元间的未使用内存</li><li>内部碎片 : 分配单元内的未使用内存</li></ul><h3 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h3><p>分区的动态分配方式有以下三种 :</p><ol><li>第一匹配分配 : 在内存中找到第一个比需求大的空闲块, 分配给应用程序</li><li>最优适配分配 : 在内存中找到最小的空闲块, 分配给应用程序</li><li>最差适配分配 : 在内存中找到最大的空闲块, 分配给应用程序</li></ol><p>分配方式的区别</p><div class="table-container"><table><thead><tr><th>分配方式</th><th>第一匹配分配</th><th>最优适配分配</th><th>最差适配分配</th></tr></thead><tbody><tr><td>分配方式实现需求</td><td>1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td><td>1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td><td>1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td></tr><tr><td>优势</td><td>简单 / 易于产生更大空闲块</td><td>比较简单 / 大部分分配是小尺寸时高效</td><td>分配很快 / 大部分分配是中尺寸时高效</td></tr><tr><td>劣势</td><td>产生外部碎片 / 不确定性</td><td>产生外部碎片 / 重分配慢 / 产生很多没用的微小碎片</td><td>产生外部碎片 / 重分配慢 / 易于破碎大的空闲块以致大分区无法被分配</td></tr></tbody></table></div><blockquote><p>  三种分配方式并无优劣之分，因为我们无法判断内存请求的大小</p></blockquote><h2 id="碎片整理方法"><a href="#碎片整理方法" class="headerlink" title="碎片整理方法"></a>碎片整理方法</h2><p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p><ol><li><p>压缩式碎片整理</p><ul><li>重置程序以合并碎片</li><li>要求所有程序是动态可重置的</li><li>问题 : <ul><li>何时重置 ? (在程序处于等待状态时才可以重置)</li><li>需要考虑内存拷贝的开销</li></ul></li></ul></li><li><p>交换式碎片整理</p><ul><li><p>运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存</p></li><li><p>问题 :</p><ul><li>哪些程序应该被回收 ?</li></ul></li><li><p>情况 :</p><p>运行中 : P3</p><p>等待中 : P1 P2 P4</p><p>内存分布 -&gt; 主存 : OS / P1 / P3 / P2 / P4 磁盘 : 空</p><p>当P3程序需要更大的内存时 -&gt;</p><p>内存分布 -&gt; 主存 : OS / P1 / P3 / P2         磁盘 : P4</p></li></ul></li></ol><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><blockquote><p>  第四章的主要内容是：操作系统的非连续内存分配</p></blockquote><p>第三章介绍的是连续内存管理, 即 : 操作系统加载到内存以及程序加载到内存中时, 分配一块连续的空闲(内存)块. 但是容易出现碎片问题, 这一章介绍的非连续内存分配可以有效的减少碎片的出现.</p><h2 id="非连续内存分配的必要性"><a href="#非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性</h2><h3 id="连续内存分配的缺点"><a href="#连续内存分配的缺点" class="headerlink" title="连续内存分配的缺点"></a>连续内存分配的缺点</h3><ol><li>分配给一个程序的物理内存是连续的</li><li>内存利用率低</li><li>有外碎片 / 内碎片的问题</li></ol><h3 id="非连续内存分配的优点"><a href="#非连续内存分配的优点" class="headerlink" title="非连续内存分配的优点"></a>非连续内存分配的优点</h3><ol><li><p>一个程序的物理地址空间是非连续的</p></li><li><p>更好的内存利用和管理</p></li><li><p>允许共享代码与数据(共享库等…)</p></li><li><p>支持动态加载和动态链接</p></li></ol><h3 id="非连续内存分配的缺点"><a href="#非连续内存分配的缺点" class="headerlink" title="非连续内存分配的缺点"></a>非连续内存分配的缺点</h3><ol><li><p>建立虚拟地址和物理地址的转换难度大</p><ul><li><p>软件方案</p></li><li><p>硬件方案(采用硬件方案) : 分段 / 分页</p></li></ul></li></ol><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p><strong>段 :</strong> 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 / 栈 / .bss / .data 等</p><p><strong>分段 : </strong> 更好的分离和共享</p><p>程序的分段地址空间如下图所示 : </p><p><img src="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067"/></p><p><strong>分段寻址方案</strong></p><p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.</p><p>一个段 : 一个内存”块”</p><p>程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)</p><p>操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)</p><p>物理地址 : 段表中的起始地址 + 二元组中的偏移地址</p><h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><h4 id="分页地址空间"><a href="#分页地址空间" class="headerlink" title="分页地址空间"></a>分页地址空间</h4><p>划分物理内存至固定大小的帧(Frame)</p><ul><li>大小是2的幂, 512 / 4096 / 8192</li></ul><p>划分逻辑地址空间至相同大小的页(Page)</p><ul><li>大小是2的幂, 512 / 4096 / 8192</li></ul><p>建立方案 → 转换逻辑地址为物理地址(pages to frames)</p><ul><li>页表</li><li>MMU / TLB</li></ul><p><strong>帧(Frame)</strong></p><p>物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)</p><p>帧号 : F位, 共有2^F个帧</p><p>帧内偏移 : S位, 每帧有2^S个字节</p><p>物理地址 = 2^S * f + o</p><p>(例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧 物理地址 = (3,6) 物理地址 = 2^9 * 3 + 6 = 1542)</p><blockquote><p>  分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定</p></blockquote><p><strong>页(Page)</strong></p><p>一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 = 帧内偏移的大小 页号大小 &lt;&gt; 帧号大小</p><p>一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)</p><p>页号 : P位, 共有2^P个页</p><p>页内偏移 : S位, 每页有2^S个字节</p><p>虚拟地址  = 2^S * p + o</p><h4 id="页寻址方案"><a href="#页寻址方案" class="headerlink" title="页寻址方案"></a>页寻址方案</h4><p>操作系统维护一张页表, 页表保存了逻辑地址——物理地址之间的映射关系</p><p>存储 : (页号, 帧号)</p><ul><li>逻辑地址空间应当大于物理内存空间</li><li>页映射到帧</li><li>页是连续的虚拟内存</li><li>帧是非连续的物理内存(有助于减少碎片的产生)</li><li>不是所有的页都有对应的帧</li></ul><h3 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h3><h4 id="页表概述"><a href="#页表概述" class="headerlink" title="页表概述"></a>页表概述</h4><p>每一个运行的程序都有一个页表</p><ul><li>属于程序运行状态, 会动态变化</li><li>PTBR : 页表基址寄存器</li></ul><p><strong>转换流程</strong></p><p>CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址.</p><p>页表中还有一些特殊标志位</p><ul><li>dirty bit,</li><li>resident bit, (0 : 对应的物理页帧在内存中不存在 ; 1 : 存在)</li><li>clock / reference bit</li></ul><p><strong>转换实例</strong></p><p>16位地址的系统</p><ul><li>32KB的物理内存</li><li>每页的 1024 byte</li></ul><p>逻辑地址空间 : (4, 0) … (3, 1023)</p><p>页表 :</p><p>Flags |  Frame nums</p><p>1 0 1    0 0 0 0 0          → 内存访问异常(可能要杀死程序)</p><p>0 1 1    0 0 1 0 0           → 页帧是4 偏移是 1023 → 物理地址 (4, 1023)</p><h4 id="分页机制的性能问题"><a href="#分页机制的性能问题" class="headerlink" title="分页机制的性能问题"></a>分页机制的性能问题</h4><p>访问一个内存单元需要2次内存访问</p><ul><li>一次用于获取页表项</li><li>一次用于访问数据</li></ul><p>页表可能非常大</p><ul><li>64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 / 2^10 = 2^54 存放不下)</li><li>每一个运行的程序都需要有一个页表</li></ul><p>如何处理？</p><ul><li>缓存(Caching)</li><li>间接(Indirection)访问</li></ul><h4 id="转换后备缓冲区-TLB"><a href="#转换后备缓冲区-TLB" class="headerlink" title="转换后备缓冲区(TLB)"></a>转换后备缓冲区(TLB)</h4><p>缓解时间问题</p><p>Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有快表TLB(可以将经常访问的页表存放在这边)</p><p>缓存近期访问的页帧转换表项</p><ul><li>TLB使用关联内存实现, 具备快速访问性能</li><li>如果TLB命中, 物理页号可以很快被获取</li><li>如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现)</li></ul><h4 id="二级-多级页表"><a href="#二级-多级页表" class="headerlink" title="二级/多级页表"></a>二级/多级页表</h4><p>时间换空间</p><p>二级页表</p><ul><li>将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.</li><li>一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号</li><li>节约了一定的空间, 在一级页表中如果resident bit = 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留</li></ul><p>多级页表</p><ul><li>通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”</li></ul><h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>解决大地址空间问题</p><p>目的 : 根据帧号获得页号</p><p>反向页表只需要存在一张即可</p><ul><li>有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表</li><li>不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间</li></ul><h5 id="基于页寄存器-Page-Registers-的方案"><a href="#基于页寄存器-Page-Registers-的方案" class="headerlink" title="基于页寄存器(Page Registers)的方案"></a>基于页寄存器(Page Registers)的方案</h5><p>存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.</p><p>每一个帧和一个寄存器关联, 寄存器内容包括 :</p><ul><li>resident bit : 此帧是否被占用</li><li>occupier : 对应的页号 p</li><li>protection bits : 保护位</li></ul><p>实例 :</p><ul><li>物理内存大小是 : 4096 <em> 4096 = 4K </em> 4KB = 16 MB</li><li>页面大小是 : 4096 bytes = 4 KB</li><li>页帧数 : 4096 = 4 K</li><li>页寄存器使用的空间(假设8 bytes / register) : 8 * 4096 = 32 Kbytes</li><li>页寄存器带来的额外开销 : 32K / 16M = 0.2%</li><li>虚拟内存大小 : 任意</li></ul><p>优势 :</p><ul><li>转换表的大小相对于物理内存来说很小</li><li>转换表的大小跟逻辑地址空间的大小无关</li></ul><p>劣势 :</p><ul><li>需要的信息对调了, 即根据帧号可以找到页号</li><li>如何转换回来? (如何根据页号找到帧号)</li><li>在需要在反向页表中搜索想要的页号</li></ul><h5 id="基于关联内存-associative-memory-的方案"><a href="#基于关联内存-associative-memory-的方案" class="headerlink" title="基于关联内存(associative memory)的方案"></a>基于关联内存(associative memory)的方案</h5><p>硬件设计复杂, 容量不大, 需要放置在CPU中</p><ul><li>如果帧数较少, 页寄存器可以被放置在关联内存中</li><li>在关联内存中查找逻辑页号<ul><li>成功 : 帧号被提取</li><li>失败 : 页错误异常 (page fault)</li></ul></li><li>限制因素:<ul><li>大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)</li></ul></li></ul><h5 id="基于哈希-hash-的方案"><a href="#基于哈希-hash-的方案" class="headerlink" title="基于哈希(hash)的方案"></a>基于哈希(hash)的方案</h5><p>哈希函数 : h(PID, p) 从 PID 标号获得页号</p><p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p><ul><li>对页号做哈希计算, 为了在帧表中获取对应的帧号</li><li>页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数</li><li>为了查找页 i , 执行下列操作 :<ul><li>计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器</li><li>检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败</li></ul></li></ul><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><blockquote><p>  第五章的主要内容是：操作系统的虚拟内存管理技术</p></blockquote><h2 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h2><p>使用硬盘/磁盘使更多的程序在有限的内存中运行</p><p>理想的存储器 : 更大更快更便宜和非易失性的存储区</p><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中</p><p>目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.</p><p>原理 :</p><p>把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.</p><ul><li>必要部分(常用功能)的代码和数据常驻内存;</li><li>可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;</li><li>不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.</li></ul><blockquote><p>  也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.</p></blockquote><p>实例 :</p><p>A(20k) <strong><strong>B(50k) </strong></strong> D(30k)<br>        | <strong><strong> C(30k) </strong></strong> E(20k)<br>                             |<em>__</em> F(40k)</p><p>因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 覆盖区0(50k) 覆盖区1(40k) 压缩至了110k的内存空间使用</p><p>缺点 :</p><ul><li>由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;</li><li>覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.</li></ul><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中</p><p>目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源</p><p>原理 :</p><p>可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.</p><p>存在问题 :</p><ul><li>交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;</li><li>交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取</li><li>程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法</li></ul><h2 id="覆盖技术和交换技术的对比"><a href="#覆盖技术和交换技术的对比" class="headerlink" title="覆盖技术和交换技术的对比"></a>覆盖技术和交换技术的对比</h2><p>特点 :</p><ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.</li><li>交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.</li><li>换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.</li></ul><p>在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :</p><ul><li>覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.</li><li>交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.</li></ul><h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><p>如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术</p><ul><li><p>目标</p><p>像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.</p><p>像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.</p></li><li><p>程序局部性原理</p><p>程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.</p><ul><li>时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;</li><li>空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.</li></ul><p>程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.</p><p>实例 :</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">题目描述 :<br>页面大小为<span class="hljs-number">4</span>k, 分配给每个进程的物理页面是<span class="hljs-number">1.</span> <br>在一个进程中, 定义了如下的二维数组 <span class="hljs-keyword">int</span> A[<span class="hljs-number">1024</span>][<span class="hljs-number">1024</span>]. 该数组按行存放在内存, 每一行放在一个页面中.<br>考虑一下程序的编写方法对缺页率的影响?<br><br>程序编写方法<span class="hljs-number">1</span> : (发生了<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>次缺页中断)<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1024</span>; j++)<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++)<br>A[i][j] = <span class="hljs-number">0</span>;<br><br>程序编写方法<span class="hljs-number">2</span> : (发生了<span class="hljs-number">1024</span>次缺页中断)<br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++)<br><span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1024</span>; j++)<br>A[i][j] = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>基本概念</p><p>可以在页式或段式内存管理的基础上实现</p><ul><li>在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;</li><li>在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;</li><li>另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.</li></ul></li><li><p>基本特征</p><ul><li>大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.</li><li>部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;</li><li>不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.</li></ul></li><li><p>虚拟页式内存管理</p><p>页式内存管理</p><p>页表 : 完成逻辑页到物理页帧的映射</p><p>根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.</p><p>虚拟页式内存管理</p><ul><li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.</p></li><li><p>基本思路</p><ul><li>当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.</li><li>在运行的过程中, 如果发现要运行的程序或要访问的数据不再内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.</li></ul></li><li><p>页表表项</p><p>逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号</p><p>驻留位 : 表示该页是在内存中还是在外存.</p><p>保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等</p><p>修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存</p><p>访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.</p></li><li><p>缺页中断处理过程 :</p><ol><li>如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;</li><li>采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;</li><li>对q所对应的页表项修改, 把驻留位置为0;</li><li>将需要访问的页p装入到物理页面f当中;</li><li>修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;</li><li>重新运行被中断是指令.</li></ol><blockquote><p>  在何处保存未被映射的页?</p><ul><li>能够简单地识别在二级存储器中的页</li><li>交换空间(磁盘或者文件) : 特殊格式, 用于存储未被映射的页面</li></ul></blockquote><p>后备存储(二级存储) :</p><ul><li>一个虚拟地址空间的页面可以被映射到一个文件(在二级存储中)的某个位置</li><li>代码段 : 映射到可执行二进制文件</li><li>动态加载的共享库程序段 : 映射到动态调用的库文件</li><li>其他段 : 可能被映射到交换文件(swap file)</li></ul></li><li><p>虚拟内存性能</p><p>为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)</p><p>EAT = 访存时间 <em> 页表命中几率 + page fault处理时间 </em> page fault几率</p><p>实例 :</p><p>访存时间 : 10 ns</p><p>磁盘访问时间 : 5 ms</p><p>参数 p  = page fault 几率</p><p>参数 q = dirty page 几率(对页面写操作)</p><p>EAT = 10*(1-p) + 5000000*p*(1+q)</p></li></ul></li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><blockquote><p>  第六章的主要内容是：操作系统的虚拟内存管理技术中的页面置换算法</p></blockquote><h2 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h2><p>功能 : 当缺页中断发生, 需要调入新的页面而内存已满时, 选择内存当中哪个物理页面被置换.</p><p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数). 具体来说, 把未来不再使用的或短期内较少使用的页面换出, 通常只能在局部性原理指导下依据过去的统计数据来进行预测.</p><p>页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程. 实现的方式是 : 在页表中添加锁定标记位(lock bit).</p><h2 id="实验设置与评价方法"><a href="#实验设置与评价方法" class="headerlink" title="实验设置与评价方法"></a>实验设置与评价方法</h2><p>实例 :</p><p>记录一个进程对页访问的一个轨迹</p><ul><li>举例 : 虚拟地址跟踪(页号, 偏移)…<ul><li>(3,0) (1,9) (4,1) (2,1) (5,3) (2,0) …</li></ul></li><li>生成的页面轨迹<ul><li>3, 1, 4, 2, 5, 2, 1, …</li></ul></li></ul><p>模拟一个页面置换的行为并且记录产生页缺失数的数量</p><ul><li>更少的缺失, 更好的性能</li></ul><h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.</p><p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p><p>可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)</p><h3 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h3><p>基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.</p><p>性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用.</p><h3 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h3><p>LRU(Least Recently Used)</p><p>基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.</p><p>它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.</p><p>LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.</p><p>两种可能的实现方法是 :</p><ul><li>系统维护一个页面链表, 最近刚刚使用过的页面作为首结点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.</li><li>设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.</li></ul><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>基本思路 :</p><p>需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1;</p><p>把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);</p><p>当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.</p><p>流程 :</p><p>如果访问页在物理内存中, 访问位置1.</p><p>如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.</p><h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.</p><p>used   dirty     →  used   dirty</p><p> 0         0                  replace</p><p> 0         1                  0         0</p><p> 1          0                 0         0 </p><p> 1          1                 0         1 </p><p>相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.</p><h3 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h3><p>Least Frequently used, LFU</p><p>基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.</p><p>实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面.</p><p>LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好.</p><h3 id="Belady现象-科学家名字"><a href="#Belady现象-科学家名字" class="headerlink" title="Belady现象(科学家名字)"></a>Belady现象(科学家名字)</h3><p>在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;</p><p>出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.</p><h3 id="LRU-FIFO-和-Clock-的比较"><a href="#LRU-FIFO-和-Clock-的比较" class="headerlink" title="LRU / FIFO 和 Clock 的比较"></a>LRU / FIFO 和 Clock 的比较</h3><p>LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.</p><p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …</p><h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?</p><ul><li>如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.</li><li>如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.</li></ul><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>工作集 : 一个进程当前正在使用的逻辑页面集合.</p><p>可以使用一个二元函数 W(t, delta) 来表示 :</p><p>t 是当前的执行时刻;</p><p>delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;</p><p>W(t, delta) = 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)</p><p>|W(t, delta)| 是工作集的大小, 即逻辑页的数量.</p><p>工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.</p><h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p><ul><li>工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;</li><li>如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li><li>当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.</li></ul><h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><p>当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.</p><h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p><ul><li>可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.</li><li>优缺点 : 性能较好, 但增加了系统开销.</li><li>具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.</li></ul><p>缺页率 : 表示 “缺页次数 / 内存访问次数”</p><p>影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.</p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><ul><li>如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.</li><li>产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</li></ul><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><blockquote><p>  第七章的主要内容是：进程</p></blockquote><h2 id="进程-process-描述"><a href="#进程-process-描述" class="headerlink" title="进程(process)描述"></a>进程(process)描述</h2><h3 id="进程定义"><a href="#进程定义" class="headerlink" title="进程定义"></a>进程定义</h3><p>进程 : 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.</p><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p>进程包括 :</p><ul><li>程序的代码</li><li>程序处理的数据</li><li>程序计数器中的值, 指示下一条将运行的指令</li><li>一组通用的寄存器的当前值, 堆, 栈</li><li>一组系统资源(如打开的文件)</li></ul><p>进程和程序的联系 :</p><ul><li>程序是产生进程的基础</li><li>程序的每次运行构成不同的进程</li><li>进程是程序功能的体现</li><li>通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.</li></ul><p>进程和程序的区别 :</p><ul><li>进程是动态的,  程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 / 用户态.</li><li>进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.</li><li>进程和程序的组成不同 : 进程的组成包括程序, 数据和进程控制块(进程状态信息)</li></ul><h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><p><strong>动态性</strong> : 可动态地创建, 结果进程;</p><p><strong>并发性</strong> : 进程可以被独立调度并占用处理机运行; (并发:一段, 并行:一时刻)</p><p><strong>独立性</strong> : 不同进程的工作不相互影响;(页表是保障措施之一)</p><p><strong>制约性</strong> : 因访问共享数据, 资源或进程间同步而产生制约.</p><blockquote><p>  抛出了一个问题 : 如果你要设计一个OS, 怎么样来实现其中的进程管理机制?</p></blockquote><h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><p>描述进程的数据结构 : 进程控制块 (Process Control Block)</p><p>操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息.</p><p><strong>进程控制块 :</strong> 操作系统管理控制进程运行所用的信息集合.</p><p>进程的创建 : 为该进程生成一个PCB</p><p><strong>进程的终止 :</strong> 回收它的PCB</p><p><strong>进程的组织管理 :</strong> 通过对PCB的组织管理来实现</p><p>(PCB具体包含什么信息? 如何组织的? 进程的状态转换?)</p><p><strong>PCB有以下三大类信息 :</strong></p><ul><li>进程标志信息. 如本进程的标志, 本进程的产生者标志(父进程标志). 用户标志</li><li>处理机状态信息保存区 : 保存进程的运行现场信息 :<ul><li>用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器</li><li>控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)</li><li>栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它</li></ul></li><li>进程控制信息<ul><li>调度和状态信息. 用于操作系统调度进程并占用处理机使用.</li><li>进程间通信信息. 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.</li><li>存储管理信息. 包含有指向本进程映像存储空间的数据结构.</li><li>进程所用资源. 说明由进程打开, 使用的系统资源. 如打开的文件等.</li><li>有关数据结构的链接信息. 进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB.</li></ul></li></ul><p><strong>进程的组织方式</strong></p><p>链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)</p><p>索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)</p><h2 id="进程状态-state"><a href="#进程状态-state" class="headerlink" title="进程状态(state)"></a>进程状态(state)</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>引起进程创建的3个主要事件 :</p><ul><li>系统初始化;</li><li>用户请求创建一个新进程;</li><li>正在运行的进程执行了创建进程的系统调用.</li></ul><h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p>内核选择一个就绪的进程, 让它占用处理机并执行</p><p>(为何选择?如何选择?)</p><h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待(阻塞)"></a>进程等待(阻塞)</h4><p>在以下情况下, 进程等待(阻塞):</p><ol><li>请求并等待系统服务, 无法马上完成</li><li>启动某种操作, 无法马上完成</li><li>需要的数据没有到达</li></ol><p>进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.</p><h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>唤醒进程的原因 :</p><ol><li>被阻塞进程需要的资源可被满足</li><li>被阻塞进程等待的事件到达</li><li>将该进程的PCB插入到就绪队列</li></ol><p>进程只能被别的进程或操作系统唤醒</p><h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p>在以下四种情况下, 进程结束 :</p><ul><li>正常退出(自愿)</li><li>错误退出(自愿)</li><li>致命错误(强制性)</li><li>被其他进程杀死(强制性)</li></ul><h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><strong>进程的三种基本状态 :</strong> 进程在生命结束前处于三种基本状态之一.</p><p>不同系统设置的进程状态数目不同.</p><p><strong>三种基本状态</strong></p><ol><li>运行状态(Running) : 当一个进程正在处理机上运行时</li><li>就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行</li><li>等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入/输出完成.</li></ol><p><strong>进程其它的基本状态</strong></p><p>创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态</p><p>结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.</p><p><strong>可能的状态变化如下 :</strong></p><p>NULL → New : 一个新进程被产生出来执行一个程序</p><p>New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态</p><p>Ready → Running  : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行</p><p>Running → Exit   : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理</p><p>Running → Ready  : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机</p><p>Running → Blocked: 当进程请求某样东西且必须等待时</p><p>Blocked → Ready  : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态</p><h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>进程挂起, 为了合理且充分地利用系统资源.</p><p>进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上.(把进程放到磁盘上)</p><p><strong>两种挂起状态</strong></p><ol><li>阻塞挂起状态 : 进程在外存并等待某事件的出现;</li><li>就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.</li></ol><p><strong>与挂起相关的状态转换</strong></p><p><strong>挂起 :</strong> 把一个进程从内存转到外存, 可能有以下几种情况 :</p><ul><li>阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.</li><li>就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.</li><li>运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.</li></ul><p><strong>在外存时的状态转换 :</strong></p><ul><li>阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.</li></ul><p><strong>解挂, 激活 :</strong> 把一个进程从外存转到内存; 可能有以下几种情况 :</p><ul><li>就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.</li><li>阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.</li></ul><blockquote><p>  抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程?</p></blockquote><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul><li>由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;</li><li>不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列);</li><li>每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列.</li></ul><h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程?"></a>为什么使用线程?</h3><p>实例 : 编写一个MP3播放软件.</p><p>核心功能 : (1)从MP3音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来.</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//单进程方式</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Read</span>();<br><span class="hljs-built_in">Decompress</span>();<br><span class="hljs-built_in">Play</span>();<br>&#125;<br><span class="hljs-comment">//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率.</span><br></code></pre></div></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//多进程</span><br><span class="hljs-comment">//进程1</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Read</span>();<br>&#125;<br><span class="hljs-comment">//进程2</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Decompress</span>();<br>&#125;<br><span class="hljs-comment">//进程3</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-built_in">Play</span>();<br>&#125;<br><span class="hljs-comment">//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大:</span><br><span class="hljs-comment">//创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息</span><br></code></pre></div></td></tr></table></figure><p>因此需要提出一种新的实体, 满足以下特征:</p><ol><li>实体之间可以并发执行;</li><li>实体之间共享相同的地址空间.</li></ol><p>这实体就是线程.</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程是进程当中的一条执行流程.</p><p>从两个方面重新理解进程:</p><ol><li>从资源组合的角度: 进程把一组相关的资源组合起来,构成了一个资源平台(环境),包括地址空间(代码段,数据段),打开的文件等各种资源;</li><li>从运行的角度: 代码在这个资源平台上的一条执行流程(线程).</li></ol><p>线程 = 进程 - 共享资源</p><h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><p>线程的优点:</p><ul><li>一个进程中可以同时存在多个线程;</li><li>各个线程之间可以并发地执行;</li><li>各个线程之间可以共享地址空间和文件等资源.</li></ul><p>线程的缺点:</p><ul><li><p>一个线程崩溃, 会导致其所属进程的所有线程崩溃.(给它了”权限”就得有更高的”责任”)</p></li><li><p>线程所需的资源</p><p>不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等.</p></li></ul><h3 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h3><ul><li>进程是资源分配单位, 线程是CPU调度单位;</li><li>进程拥有一个完整的资源平台, 而线程只独享必不可少的资源, 如寄存器和栈;</li><li>线程同样具有就绪,阻塞和执行三种基本状态,同样具有状态之间的转换关系;</li><li>线程能减少并发执行的时间和空间开销:<ul><li>线程的创建时间比进程短;(直接利用所属进程的一些状态信息)</li><li>线程的终止时间比进程短;(不需要考虑把这些状态信息给释放)</li><li>同一进程内的线程切换时间比进程短;(同一进程不同线程的切换不需要切换页表)</li><li>由于同一进程的各线程之间共享内存和文件资源, 可直接进行不通过内核的通信.(直接通过内存地址读写资源)</li></ul></li></ul><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式:</p><ul><li>用户线程  : 在用户空间实现; POSIX Pthreads, Mach C-threads, Solaris threads</li><li>内核线程  : 在内核中实现; Windows, Solaris, Linux</li><li>轻量级进程: 在内核中实现,支持用户线程; Solaris</li></ul><p><strong>用户线程</strong></p><p>操作系统只能看到进程, 看不到线程, 线程的TCB在线程库中实现;</p><p>在用户空间实现的线程机制, 它不依赖于操作系统的内核, 由一组用户级的线程库来完成线程的管理, 包括进程的创建,终止,同步和调度等.</p><ul><li>由于用户线程的维护由相应的进程来完成(通过线程库函数),不需要操作系统内核了解用户进程的存在,可用于不支持线程技术的多进程操作系统;</li><li>每个进程都需要它自己私有的线程控制块(TCB)列表,用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器),TCB由线程库函数来维护;</li><li>用户线程的切换也是由线程库函数来完成,无需用户态/核心态切换,所以速度特别快;</li><li>允许每个进程拥有自定义的线程调度算法.</li></ul><p>用户线程的缺点:</p><ul><li>阻塞性的系统调用如何实现?如果一个线程发起系统调用而阻塞,则整个进程在等待;</li><li>当一个线程开始运行时,除非它主动地交出CPU的使用权,否则它所在的进程当中的其他线程将无法运行;</li><li>由于时间片分配给进程,所以与其他进程比,在多线程执行时,每个线程得到的时间片较少,执行会较慢.</li></ul><p><strong>内核线程</strong></p><p>操作系统能够看到进程也可能看到线程,线程在内核中实现;</p><p>内核线程是在操作系统的内核当中实现的一种线程机制,由操作系统的内核来完成线程的创建,终止和管理.</p><ul><li>在支持内核线程的操作系统中,由内核来维护进程和线程的上下文信息(PCB和TCB);</li><li>线程的创建,终止和切换都是通过系统调用,内核函数的方式来进行,由内核来完成,因此系统开销较大;</li><li>在一个进程当中,如果某个内核线程发起系统调用而被阻塞,并不会影响其他内核线程的运行;</li><li>时间片分配给线程,多线程的进程获得更多CPU时间;</li><li>Windows NT 和 Windows 2000/XP 支持内核线程.</li></ul><p><strong>轻量级进程</strong></p><p>它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux)</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态)</p><ul><li>必须在切换之前存储许多部分的进程上下文</li><li>必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过</li><li>必须快速(上下文切换时非常频繁)</li></ul><p>需要存储什么上下文?</p><ul><li>寄存器(PC,SP…),CPU状态等信息</li><li>一些时候可能会费时,所以我们应该尽可能避免</li></ul><p>操作系统为活跃进程准备了进程控制块</p><p>操作系统将进程控制块放置在一个合适的队列中</p><ul><li>就绪队列</li><li>等待IO队列(每个设备的队列)</li><li>僵尸队列</li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork()的简单实现</p><ul><li>对子进程分配内存</li><li>复制父进程的内存和CPU寄存器到子进程</li><li>开销昂贵</li></ul><p>在99%的情况下,我们在调用fork()之后调用exec()</p><ul><li>在fork()操作中内存复制是没有作用的</li><li>子进程将可能关闭打开的文件和连接</li><li>开销因此是最高的</li><li>为什么不能结合它们在一个调用中(OS/2, windows)?</li></ul><p>vfork()</p><ul><li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li><li>一些时候称为轻量级fork()</li><li>子进程应该几乎立即调用exec()</li><li>现在不再使用如果我们使用 copy on write 技术</li></ul><h3 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h3><p>系统调用exec()加载程序取代当前运行的进程</p><p>exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p><p>它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p><p>如果调用成功(相同的进程,不同的程序)</p><p>代码,stack,heap重写</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> pid = fork(); <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;    <span class="hljs-comment">//子进程</span><br>exec_status = <span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;calc&quot;</span>, argc, argv0,argv1,...);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Why would I execute?&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//父进程</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Whose your daddy?&quot;</span>);<br>...<br>child_status = <span class="hljs-built_in">wait</span>(pid);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>wait()系统调用是被父进程用来等待子进程的结束</p><ul><li>一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理</li><li>wait()系统调用担任这个要求<ul><li>它使父进程去睡眠来等待子进程的结束</li><li>当一个子进程调用exit()的时候,操作系统解锁父进程,并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起)如果这里没有子进程存活,wait()立刻返回</li><li>当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态)</li></ul></li><li>进程结束执行之后,它调用exit()</li><li>这个系统调用:<ul><li>将这程序的”结果”作为一个参数</li><li>关闭所有打开的文件,连接等等</li><li>释放内存</li><li>释放大部分支持进程的操作系统结构</li><li>检查是否父进程是存活着的:<ul><li>如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态</li><li>如果没有,它释放所有的数据结构,这个进程死亡</li></ul></li><li>清理所有等待的僵尸进程</li></ul></li><li>进程终止是最终的垃圾收集(资源回收)</li></ul><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><blockquote><p>  第八章的主要内容是：调度算法(感觉清华这门课程前几章比较精彩,后续讲的有点混乱)</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="上下文切换-1"><a href="#上下文切换-1" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul><li>切换CPU的当前任务, 从一个进程/线程到另一个</li><li>保存当前进程/线程在PCB/TCB中的执行上下文(CPU状态)</li><li>读取下一个进程/线程的上下文</li></ul><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><ul><li>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程</li><li>调度程序: 挑选进程/线程的内核函数(通过一些调度策略)</li><li>什么时候进行调度?</li></ul><h3 id="内核运行调度程序的条件-满足一条即可"><a href="#内核运行调度程序的条件-满足一条即可" class="headerlink" title="内核运行调度程序的条件(满足一条即可)"></a>内核运行调度程序的条件(满足一条即可)</h3><ul><li>一个进程从运行状态切换到等待状态</li><li>一个进程被终结</li></ul><h3 id="不可抢占"><a href="#不可抢占" class="headerlink" title="不可抢占"></a>不可抢占</h3><ul><li>调度程序必须等待事件结束</li></ul><h3 id="可以抢占"><a href="#可以抢占" class="headerlink" title="可以抢占"></a>可以抢占</h3><ul><li>调度程序在中断被相应后执行</li><li>当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪</li><li>当前运行的进程可以被换出</li></ul><h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul><li><p>调度策略</p><p>人们通常都需要”更快”的服务</p><p>什么是更快?</p><ul><li>传输文件时的高带宽</li><li>玩游戏时的低延迟</li><li>这两个因素是独立的</li></ul><p>和水管类比</p><ul><li>低延迟: 喝水的时候想要一打开水龙头水就流出来</li><li>高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟</li></ul><p>我们的目标:</p><ul><li>减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户</li><li>减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要</li><li>增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO设备)</li><li>减少等待时间: 减少每个进程的等待时间</li></ul></li><li><p>程序执行模型</p><p>执行模型 : 程序在CPU突发和IO中交替</p><ul><li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li><li>在时间分片机制下,线程可能在结束当前CPU突发前被迫放弃CPU</li></ul></li><li><p>评价指标</p><p>CPU使用率: CPU处于忙状态所占时间的百分比</p><p>吞吐量: 在单位时间内完成的进程数量</p><p>周转时间: 一个进程从初始化到结束,包括所有等待时间所花费的时间</p><p>等待时间: 进程在就绪队列中的总时间</p><p>响应时间: 从一个请求被提交到产生第一次相应所花费的总时间</p><p>各指标在操作系统上的表现:</p><p>低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)</p><p>操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)</p><p>吞吐量是操作系统的计算带宽</p><p>响应时间是操作系统的计算延迟</p></li><li><p>公平的目标</p><p>举例:</p><ul><li>保证每个进程占用相同的CPU时间</li><li>这公平嘛?如果一个用户比其他用户运行更多的进程怎么办</li></ul><p>举例:</p><ul><li>保证每个进程都等待相同的时间</li></ul><p>公平通常会增加平均响应时间</p></li></ul><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul><li><p><strong>FCFS(先来先服务)</strong></p><p>First come, First Served</p><p>如果进程在执行中阻塞,队列中的下一个会得到CPU</p><p>优点: 简单</p><p>缺点:</p><ul><li>平均等待时间波动较大</li><li>花费时间少的任务可能排在花费时间长的任务后面</li><li>可能导致IO和CPU之间的重叠处理(CPU密集型进程会导致IO设备闲置时,IO密集型进程也在等待)</li></ul></li><li><p><strong>SPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间]</strong></p><p>Shortest Process Next(Shortest Job First) Shortest Remaining Time</p><p>选择预测的完成时间来将任务入队</p><p>可以是抢占的或者是不可抢占的</p><p>可能导致饥饿</p><ul><li>连续的短任务流会使场任务饥饿</li><li>短任务可用时的任何场任务的CPU时间都会增加平均等待时间</li></ul><p>需要预测未来</p><ul><li>怎么预估下一个CPU突发的持续时间</li><li>简单的解决: 询问用户</li><li>如果用户欺骗就杀死进程</li><li>如果不知道怎么办?</li></ul></li><li><p><strong>HRRN(最高响应比优先)</strong></p><p>Highest Response Ratio Next</p></li><li><p><strong>Round Robin(轮循)</strong></p><p>使用时间切片和抢占来轮流执行任务</p><p>在叫做量子(或者时间切片)的离散单元中分配处理器</p><p>时间片结束时,切换到下一个准备好的进程</p><p>花销: 额外的上下文切换</p><p>时间量子太大:</p><ul><li>等待时间过长</li><li>极限情况退化成FCFS</li></ul><p>时间量子太小:</p><ul><li>反应迅速</li><li>吞吐量由于大量的上下文切换开销受到影响</li></ul><p>目标:</p><ul><li>选择一个合适的时间量子</li><li>经验规则: 维持上下文切换开销处于1%以内</li></ul></li><li><p><strong>Multilevel Feedback Queues(多级反馈队列)</strong></p><p>优先级队列中的轮循</p><p>就绪队列被划分成独立的队列: 比如前台(交互),后台(批处理)</p><p>每个队列拥有自己的调度策略: 比如前台(RR),后台(FCFS)</p><p>调度必须在队列间进行:</p><ul><li>固定优先级: 先处理前台,然后处理后台;可能导致饥饿</li><li>时间切片: 每个队列都得到一个确定的能够调度其进程的CPU总时间;比如80%使用RR的前台,20%使用FCFS的后台</li></ul><p>一个进程可以在不同的队列中移动</p><p>例如,n级优先级-优先级调度在所有级别中,RR在每个级别中</p><ul><li>时间量子大小随优先级级别增加而增加</li><li>如果任务在当前的时间量子中没有完成,则降到下一个优先级</li></ul><p>优点: CPU密集型任务的优先级下降很快;IO密集型任务停留在高优先级</p></li><li><p><strong>Fair Share Scheduling(公平共享调度)</strong></p><p>FSS控制用户对系统资源的访问</p><ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源</li><li>未使用的资源按照每个组所分配的资源的比例来分配</li><li>没有达到资源使用率目标的组获得更高的优先级</li></ul></li></ul><h2 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h2><p>确定性建模: 确定一个工作量,然后计算每个算法的表现</p><p>队列模型: 用来处理随机工作负载的数学方法</p><p>实现/模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性</p><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><ul><li><p>实时系统</p><p>定义: 正确性依赖于其时间和功能两方面的一个操作系统</p><p>性能指标: 时间约束的及时性;速度和平均性能相对不重要</p><p>主要特征: 时间约束的可预测性</p><p>分类:</p><ul><li>强实时系统: 需要在保证时间内完成重要的任务,必须完成</li><li>弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须</li></ul><p>任务(工作单元): 一次计算,一次文件读取,一次信息传递等</p><p>属性: 去的进展所需要的资源;定时参数.</p></li><li><p>单调速率(RM)</p><ul><li>最佳静态优先级调度</li><li>通过周期安排优先级</li><li>周期越短优先级越高</li><li>执行周期最短的任务</li></ul></li><li><p>截止日期最早优先(EDF)</p><ul><li>最佳的动态优先级调度</li><li>Deadline越早优先级越高</li><li>执行Deadline最早的任务</li></ul></li></ul><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多处理器的CPU调度更复杂:</p><ul><li>多个相同的单处理器组成一个多处理器</li><li>优点: 复杂共享</li></ul><p>对称多处理器(SMP)</p><ul><li>每个处理器运行自己的调度程序</li><li>需要在调度程序中同步</li></ul><h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>可以发生在任务基于优先级的可抢占的调度机制中</p><p>当系统内的环境强制使高优先级任务等待低优先级任务时发生</p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><blockquote><p>  第九章的主要内容是：同步</p></blockquote><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>第一章到第八章内容, 到目前为止</p><ul><li>多道程序设计: 现代操作系统的重要特性</li><li>并行很有用(为什么?) 提示: 多个并发实体: CPU IO 用户 等</li><li>进程,线程: 操作系统抽象出来用于支持多道程序设计</li><li>CPU调度: 实现多道程序设计的机制</li><li>调度算法: 不同的策略</li></ul><p>独立的线程:</p><ul><li>不和其他线程共享资源或状态</li><li>确定性: 输入状态决定结果</li><li>可重现: 能够重现起始条件, IO</li><li>调度顺序不重要</li></ul><p>合作线程:</p><ul><li>在多个线程中共享状态</li><li>不确定性</li><li>不可重现</li></ul><p>不确定性和不可重现意味着bug可能是间歇性发生的</p><p>进程,线程;计算机,设备需要合作</p><p>合作优点:</p><ol><li>共享资源<ul><li>一台电脑,多个用户</li><li>一个银行存款余额,多台ATM机</li><li>嵌入式系统</li></ul></li><li>加速<ul><li>IO操作和计算可以重叠</li><li>多处理器</li></ul></li><li>模块化<ul><li>将大程序分解成小程序 gcc会调用cpp,cc1,cc2,as,ld</li><li>使系统易于扩展</li></ul></li></ol><p>程序可以调用函数fork()来创建一个新的进程</p><ul><li>操作系统需要分配一个新的并且唯一的进程ID</li><li>因此在内核中,这个系统调用会运行 new_pid = next_pid++;</li><li>翻译成机器指令:<ul><li>Load next_pid Reg1</li><li>STORE Reg1 new_pid</li><li>INC Reg1</li><li>STORE Reg1 next_pid</li></ul></li></ul><p>假设两个进程并发执行</p><ul><li>如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102</li><li>可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101</li></ul><p>无论多个线程的指令序列怎样交替执行,程序都必须正常工作</p><ul><li>多线程程序具有不确定性和不可重现的特点</li><li>不经过专门设计,调试难度很高</li></ul><p>不确定性要求并行程序的正确性</p><ul><li>先思考清楚问题,把程序的行为设计清楚</li><li>切忌给予着手编写代码,碰到问题再调试</li></ul><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>前面的现象称为Race Condition(竞态条件)</p><p>系统缺陷: 结果依赖于并发执行或者时间的顺序,时间</p><ul><li>不确定性</li><li>不可重现</li></ul><p>怎么样避免竞态?</p><p>Atomic Operator(原子操作)</p><p>原子操作是指一次不存在任何终端或者失败的执行</p><ul><li>该执行成功结束</li><li>或者根本没有执行</li><li>并且不应发生任何部分执行的状态</li></ul><p>实际上操作往往不是原子的</p><ul><li>有些看上去是原子操作,实际上不是</li><li>连x++这样的简单语句,实际上是由三条指令构成的</li><li>有时候甚至连单条假期指令都不是原子的(Pipeline,super-scalar,out-of-order,pape fault)</li></ul><p>临界区(Critical section)是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域</p><p>互斥(Mutual exclusion)是指当一个 进程处于临界区并访问共享资源时,没有其他进程会处于临界区并且访问任何相同的共享资源</p><p>死锁(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去</p><p>饥饿(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>互斥: 同一时间临界区中最多存在一个线程</p><p>Progress: 如果一个线程想要进入临界区,那么它最终会成功</p><p>有限等待: 如果一个线程i处于入口区,那么在i的请求被接受之前,其他线程进入临界区的时间是有限制的</p><p>无忙等待(可选): 如果一个进程在等待进入临界区,那么在它可以进入之前会被挂起</p><h2 id="方法1-禁用硬件中断"><a href="#方法1-禁用硬件中断" class="headerlink" title="方法1:禁用硬件中断"></a>方法1:禁用硬件中断</h2><p>没有中断,没有上下文切换,因此没有并发</p><ul><li>硬件将中断处理延迟到中断被启用之后</li><li>大多数现代计算机体系结构都提供指令来完成</li></ul><p>进入临界区</p><ul><li>禁用中断</li></ul><p>离开临界区</p><ul><li>开启中断</li></ul><p>一旦中断被禁用,线程就无法被停止</p><ul><li>整个系统都会为你停下来</li><li>可能导致其他线程处于饥饿状态</li></ul><p>要是临界区可以任意长怎么办?</p><ul><li>无法限制响应中断所需的时间(可能存在硬件影响)</li></ul><p>要小心使用,适合于较小的操作</p><h2 id="方法2-基于软件的解决方案"><a href="#方法2-基于软件的解决方案" class="headerlink" title="方法2:基于软件的解决方案"></a>方法2:基于软件的解决方案</h2><p>满足进程Pi和Pj之间互斥的经典的基于软件的解决方法(1981年)</p><p>使用两个共享数据项</p><ul><li>int turn; //指示该谁进入临界区</li><li>bool flag[]; //指示进程是否准备好进入临界区</li></ul><p>进入临界区:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">flag[i] = <span class="hljs-literal">true</span>;<br>turn = j;<br><span class="hljs-keyword">while</span>(flag[j] &amp;&amp; turn == j);<br></code></pre></div></td></tr></table></figure><p>退出临界区:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">flag[i] = <span class="hljs-literal">false</span>;<br></code></pre></div></td></tr></table></figure><p>实例:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">do</span>&#123;<br>flag[i] = <span class="hljs-literal">true</span>;<br>turn = j;<br><span class="hljs-keyword">while</span>(flag[j] &amp;&amp; turn == j);<br>CRITICAL SECTION<br>flag[i] = <span class="hljs-literal">false</span>;<br>REMAINDER SECTION<br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br></code></pre></div></td></tr></table></figure><p>Bakery 算法(N个进程的临界区)</p><ul><li>进入临界区之前,进程接收一个数字</li><li>得到的数字最小的进入临界区</li><li>如果进程Pi和Pj收到相同的数字,那么如果i&lt;j,Pi先进入临界区,否则Pj先进入临界区</li><li>编号方案总是按照枚举的增加顺序生成数字</li></ul><p>Dekker算法(1965): 第一个针对双线程例子的正确解决方案</p><p>Bakery算法(1979): 针对n线程的临界区问题解决方案</p><p>复杂: 需要两个进程的共享数据项</p><p>需要忙等待: 浪费CPU时间</p><p>没有硬件保证的情况下无真正的软件解决方案: Perterson算法需要原子的LOAD和STORE指令</p><h2 id="方法3-更高级的抽象"><a href="#方法3-更高级的抽象" class="headerlink" title="方法3:更高级的抽象"></a>方法3:更高级的抽象</h2><p>硬件提供了一些原语</p><ul><li>像中断禁用, 原子操作指令等</li><li>大多数现代体系结构都这样</li></ul><p>操作系统提供更高级的编程抽象来简化并行编程</p><ul><li>例如,锁,信号量</li><li>从硬件原语中构建</li></ul><p>锁是一个抽象的数据结构</p><ul><li>一个二进制状态(锁定,解锁),两种方法</li><li>Lock::Acquire() 锁被释放前一直等待,然后得到锁</li><li>Lock::Release() 锁释放,唤醒任何等待的进程</li></ul><p>使用锁来编写临界区</p><ul><li><p>前面的例子变得简单起来:</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">lock_next_pid-&gt;<span class="hljs-built_in">Acquire</span>();<br>new_pid = next_pid++;<br>lock_next_pid-&gt;<span class="hljs-built_in">Release</span>();<br></code></pre></div></td></tr></table></figure></li></ul><p>大多数现代体系结构都提供特殊的原子操作指令</p><ul><li>通过特殊的内存访问电路</li><li>针对单处理器和多处理器</li></ul><p>Test-and-Set 测试和置位</p><ul><li>从内存中读取值</li><li>测试该值是否为1(然后返回真或假)</li><li>内存值设置为1</li></ul><p>交换</p><ul><li>交换内存中的两个值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">TestandSet</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> *target)</span></span>&#123;<br><span class="hljs-keyword">bool</span> rv = *target;<br>*target = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> rv;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Exchange</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> *a, <span class="hljs-keyword">bool</span> *b)</span></span>&#123;<br><span class="hljs-keyword">bool</span> tmp = *a;<br>*a = *b;<br>*b = tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>总结</p><p>锁是更高等级的编程抽象</p><ul><li>互斥可以使用锁来实现</li><li>通常需要一定等级的硬件支持</li></ul><p>常用的三种实现方法</p><ul><li>禁用中断(仅限于单处理器)</li><li>软件方法(复杂)</li><li>原子操作指令(单处理器或多处理器均可)</li></ul><p>可选的实现内容:</p><ul><li>有忙等待</li><li>无忙等待</li></ul></li></ul><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><blockquote><p>  第十章的主要内容是：信号量和管程</p></blockquote><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量的抽象数据类型</p><ul><li>一个整形(sem),具有两个原子操作</li><li>P(): sem减一,如果sem&lt;0,等待,否则继续</li><li>V(): sem加一,如果sem≤0,唤醒一个等待的P</li></ul><p>信号量是整数</p><p>信号量是被保护的变量</p><ul><li>初始化完成后,唯一改变一个信号量的值的办法是通过P()和V()</li><li>操作必须是原子</li></ul><p>P()能够阻塞,V()不会阻塞</p><p>我们假定信号量是公平的</p><ul><li>没有线程被阻塞在P()仍然堵塞如果V()被无限频繁调用(在同一个信号量)</li><li>在实践中,FIFO经常被使用</li></ul><p>两个类型信号量</p><ul><li>二进制信号量: 可以是0或1</li><li>计数信号量: 可以取任何非负数</li><li>两者相互表现(给定一个可以实现另一个)</li></ul><p>信号量可以用在2个方面</p><ul><li>互斥</li><li>条件同步(调度约束——一个线程等待另一个线程的事情发生)</li></ul><h2 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h2><ol><li><p>用二进制信号量实现的互斥</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">mutex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(<span class="hljs-number">1</span>);<br><br>mutex-&gt;<span class="hljs-built_in">P</span>();<br>...<br>mutex-&gt;<span class="hljs-built_in">V</span>();<br></code></pre></div></td></tr></table></figure></li><li><p>用二进制信号量实现的调度约束</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">condition = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//Thread A</span><br>...<br>condition-&gt;<span class="hljs-built_in">P</span>(); <span class="hljs-comment">//等待线程B某一些指令完成之后再继续运行,在此阻塞</span><br>...<br><br><span class="hljs-comment">//Thread B</span><br>...<br>condition-&gt;<span class="hljs-built_in">V</span>(); <span class="hljs-comment">//信号量增加唤醒线程A</span><br>...<br></code></pre></div></td></tr></table></figure></li><li><p>一个线程等待另一个线程处理事情</p><p>比如生产东西或消费东西(生产者消费者模式),互斥(锁机制)是不够的</p><p>有界缓冲区的生产者-消费者问题</p><ul><li>一个或者多个生产者产生数据将数据放在一个缓冲区里</li><li>单个消费者每次从缓冲区取出数据</li><li>在任何一个时间只有一个生产者或消费者可以访问该缓冲区</li></ul><p>正确性要求</p><ul><li>在任何一个时间只能有一个线程操作缓冲区(互斥)</li><li>当缓冲区为空时,消费者必须等待生产者(调度,同步约束)</li><li>当缓存区满,生产者必须等待消费者(调度,同步约束)</li></ul><p>每个约束用一个单独的信号量</p><ul><li>二进制信号量互斥</li><li>一般信号量 fullBuffers</li><li>一般信号了 emptyBuffers</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedBuffer</span>&#123;</span><br>mutex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(<span class="hljs-number">1</span>);<br>fullBuffers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(<span class="hljs-number">0</span>);   <span class="hljs-comment">//说明缓冲区初始为空</span><br> emptyBuffers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(n);  <span class="hljs-comment">//同时可以有n个生产者来生产</span><br>&#125;;<br><br>BoundedBuffer::<span class="hljs-built_in">Deposit</span>(c)&#123;<br>emptyBuffers-&gt;<span class="hljs-built_in">P</span>();<br>mutex-&gt;<span class="hljs-built_in">P</span>();<br>Add c to the buffer;<br>mutex-&gt;<span class="hljs-built_in">V</span>();<br>fullBuffers-&gt;<span class="hljs-built_in">V</span>();<br>&#125;<br><br>BoundedBuffer::<span class="hljs-built_in">Remove</span>(c)&#123;<br>fullBuffers-&gt;<span class="hljs-built_in">P</span>();<br>mutex-&gt;<span class="hljs-built_in">P</span>();<br>Remove c from buffer;<br>mutex-&gt;<span class="hljs-built_in">V</span>();<br>emptyBuffers-&gt;<span class="hljs-built_in">V</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h2><p>使用硬件原语</p><ul><li>禁用中断</li><li>原子指令</li></ul><p>类似锁</p><ul><li>禁用中断</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Semaphore</span>&#123;</span><br><span class="hljs-keyword">int</span> sem;<br>WaitQueue q;<br>&#125;;<br><br>Semaphore::<span class="hljs-built_in">P</span>()&#123;<br>--sem;<br><span class="hljs-keyword">if</span>(sem &lt; <span class="hljs-number">0</span>)&#123;<br>Add <span class="hljs-keyword">this</span> thread t to q;<br><span class="hljs-built_in">block</span>(p);<br>&#125;<br>&#125;;<br><br>Semaphore::<span class="hljs-built_in">V</span>()&#123;<br>++sem;<br><span class="hljs-keyword">if</span>(sem &lt;= <span class="hljs-number">0</span>)&#123;<br>Remove a thread t from q;<br><span class="hljs-built_in">wakeup</span>(t);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>信号量的双用途</p><ul><li>互斥和条件同步</li><li>但等待条件是独立的互斥</li></ul><p>读,开发代码比较困难</p><ul><li>程序员必须非常精通信号量</li></ul><p>容易出错</p><ul><li>使用的信号量已经被另一个线程占用</li><li>忘记释放信号量</li></ul><p>不能够处理死锁问题</p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>目的: 分离互斥和条件同步的关注</p><p>什么是管程</p><ul><li>一个锁: 指定临界区</li><li>0或者多个条件变量: 等待,通知信号量用于管程并发访问共享数据</li></ul><p>一般方法</p><ul><li>收集在对象,模块中的相关共享数据</li><li>定义方法来访问共享数据</li></ul><p>Lock</p><ul><li>Lock::Acquire() 等待直到锁可用,然后抢占锁</li><li>Lock::Release() 释放锁,唤醒等待者如果有</li></ul><p>Condition Variable</p><ul><li>允许等待状态进入临界区<ul><li>允许处于等待(睡眠)的线程进入临界区</li><li>某个时刻原子释放锁进入睡眠</li></ul></li><li>Wait() operation<ul><li>释放锁,睡眠,重新获得锁放回</li></ul></li><li>Signal() operation(or broadcast() operation)<ul><li>唤醒等待者(或者所有等待者),如果有</li></ul></li></ul><p>实现</p><ul><li>需要维持每个条件队列</li><li>线程等待的条件等待signal()</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Condition</span>&#123;</span><br><span class="hljs-keyword">int</span> numWaiting = <span class="hljs-number">0</span>;<br>WaitQueue q;<br>&#125;;<br><br>Condition::<span class="hljs-built_in">Wait</span>(lock)&#123;<br>numWaiting++;<br>Add <span class="hljs-keyword">this</span> thread t to q;<br><span class="hljs-built_in">release</span>(lock);<br><span class="hljs-built_in">schedule</span>(); <span class="hljs-comment">//need mutex</span><br><span class="hljs-built_in">require</span>(lock);<br>&#125;<br><br>Condition::<span class="hljs-built_in">Signal</span>()&#123;<br><span class="hljs-keyword">if</span>(numWaiting &gt; <span class="hljs-number">0</span>)&#123;<br>Remove a thread t from q;<br><span class="hljs-built_in">wakeup</span>(t); <span class="hljs-comment">//need mutex</span><br>numWaiting--;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>管程解决生产者-消费者问题</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoundedBuffer</span>&#123;</span><br>Lock lock;<br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">//buffer 为空</span><br>Condition notFull, notEmpty;<br>&#125;;<br><br>BoundedBuffer::<span class="hljs-built_in">Deposit</span>(c)&#123;<br>lock-&gt;<span class="hljs-built_in">Acquire</span>();    <span class="hljs-comment">//管程的定义:只有一个线程能够进入管程</span><br><span class="hljs-keyword">while</span>(count == n)<br>notFull.<span class="hljs-built_in">Wait</span>(&amp;lock); <span class="hljs-comment">//释放前面的锁</span><br>Add c to the buffer;<br>count++;<br>notEmpty.<span class="hljs-built_in">Signal</span>();<br>lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br><br>BoundedBuffer::<span class="hljs-built_in">Remove</span>(c)&#123;<br>lock-&gt;<span class="hljs-built_in">Acquire</span>();<br><span class="hljs-keyword">while</span>(count == <span class="hljs-number">0</span>)<br>notEmpty.<span class="hljs-built_in">Wait</span>(&amp;lock);<br>Remove c from buffer;<br>count--;<br>notFull.<span class="hljs-built_in">Signal</span>();<br>lock-&gt;<span class="hljs-built_in">Release</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>开发,调试并行程序很难</p><ul><li>非确定性的交叉指令</li></ul><p>同步结构</p><ul><li>锁: 互斥</li><li>条件变量: 有条件的同步</li><li>其他原语: 信号量</li></ul><p>怎么样有效地使用这些结构</p><ul><li>制定并遵循严格的程序设计风格,策略</li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ol><li><p>读者-写者问题</p><p>动机: 共享数据的访问</p><p>两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据)</p><p>问题的约束:</p><ul><li>允许同一时间有多个读者,但在任何时候只有一个写者</li><li>当没有写者时,读者才能访问数据</li><li>当没有读者和写者时,写者才能访问数据</li><li>在任何时候只能有一个线程可以操作共享变量</li></ul><p>多个并发进程的数据集共享</p><ul><li>读者: 只读数据集;他们不执行任何更新</li><li>写者: 可以读取和写入</li></ul><p>共享数据</p><ul><li>数据集</li><li>信号量CountMutex初始化为1</li><li>信号量WriteMutex初始化为1</li><li>整数Rcount初始化为0(当前读者个数)</li></ul><p>读者优先设计</p><p>只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态.</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//信号量实现</span><br><span class="hljs-comment">//writer</span><br><span class="hljs-built_in">sem_wait</span>(WriteMutex);<br>write;<br><span class="hljs-built_in">sem_post</span>(WriteMutex);<br><br><span class="hljs-comment">//reader</span><br><span class="hljs-built_in">sem_wait</span>(CountMutex);<br><span class="hljs-keyword">if</span>(Rcount == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">sem_wait</span>(WriteMutex); <span class="hljs-comment">//确保后续不会有写者进入</span><br>++Rcount;<br>read;<br>--Rcount;<br><span class="hljs-keyword">if</span>(Rcount == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">sem_post</span>(WriteMutex); <span class="hljs-comment">//全部读者全部离开才能唤醒写者</span><br><span class="hljs-built_in">sem_post</span>(CountMutex);<br></code></pre></div></td></tr></table></figure><p>写者优先设计</p><p>一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态.</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//writer</span><br>Database::<span class="hljs-built_in">Write</span>()&#123;<br>Wait until readers/writers;<br>write database;<br>check out - wake up waiting readers/writers;<br>&#125;<br><span class="hljs-comment">//reader</span><br>Database::<span class="hljs-built_in">Read</span>()&#123;<br>Wait until no writers;<br>read database;<br>check out - wake up waiting writers;<br>&#125;<br><br><span class="hljs-comment">//管程实现</span><br>AR = <span class="hljs-number">0</span>; <span class="hljs-comment">// # of active readers</span><br>AW = <span class="hljs-number">0</span>; <span class="hljs-comment">// # of active writers</span><br>WR = <span class="hljs-number">0</span>; <span class="hljs-comment">// # of waiting readers</span><br>WW = <span class="hljs-number">0</span>; <span class="hljs-comment">// # of waiting writers</span><br>Condition okToRead;<br>Condition okToWrite;<br>Lock lock;<br><span class="hljs-comment">//writer</span><br><span class="hljs-function">Public <span class="hljs-title">Database::Write</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//Wait until no readers/writers;</span><br><span class="hljs-built_in">StartWrite</span>();<br>write database;<br><span class="hljs-comment">//check out - wake up waiting readers/writers;</span><br><span class="hljs-built_in">DoneWrite</span>();<br>&#125;<br><br><span class="hljs-function">Private <span class="hljs-title">Database::StartWrite</span><span class="hljs-params">()</span></span>&#123;<br>lock.<span class="hljs-built_in">Acquire</span>();<br><span class="hljs-keyword">while</span>((AW + AR) &gt; <span class="hljs-number">0</span>)&#123;<br>WW++;<br>okToWrite.<span class="hljs-built_in">wait</span>(&amp;lock);<br>WW--;<br>&#125;<br>AW++;<br>lock.<span class="hljs-built_in">Release</span>();<br>&#125;<br><br><span class="hljs-function">Private <span class="hljs-title">Database::DoneWrite</span><span class="hljs-params">()</span></span>&#123;<br>lock.<span class="hljs-built_in">Acquire</span>();<br>AW--;<br><span class="hljs-keyword">if</span>(WW &gt; <span class="hljs-number">0</span>)&#123;<br>okToWrite.<span class="hljs-built_in">signal</span>();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WR &gt; <span class="hljs-number">0</span>)&#123;<br>okToRead.<span class="hljs-built_in">broadcast</span>(); <span class="hljs-comment">//唤醒所有reader </span><br>&#125;<br>lock.<span class="hljs-built_in">Release</span>();<br>&#125;<br><br><span class="hljs-comment">//reader</span><br><span class="hljs-function">Public <span class="hljs-title">Database::Read</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//Wait until no writers;</span><br><span class="hljs-built_in">StartRead</span>();<br>read database;<br><span class="hljs-comment">//check out - wake up waiting writers;</span><br><span class="hljs-built_in">DoneRead</span>();<br>&#125;<br><br><span class="hljs-function">Private <span class="hljs-title">Database::StartRead</span><span class="hljs-params">()</span></span>&#123;<br>lock.<span class="hljs-built_in">Acquire</span>();<br><span class="hljs-keyword">while</span>(AW + WW &gt; <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//关注等待的writer,体现出写者优先</span><br>WR++;<br>okToRead.<span class="hljs-built_in">wait</span>(&amp;lock);<br>WR--;<br>&#125;<br>AR++;<br>lock.<span class="hljs-built_in">Release</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Database::DoneRead</span><span class="hljs-params">()</span></span>&#123;<br>lock.<span class="hljs-built_in">Acquire</span>();<br>AR--;<br><span class="hljs-keyword">if</span>(AR == <span class="hljs-number">0</span> &amp;&amp; WW &gt; <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//只有读者全部没有了,才需要唤醒</span><br>okToWrite.<span class="hljs-built_in">signal</span>();<br>&#125;<br>lock.<span class="hljs-built_in">Release</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>哲学家就餐问题(学习自 <a href="http://github.com/cyc2018">github.com/cyc2018</a>)</p><p>共享数据:</p><ul><li>Bowl of rice(data set)</li><li>Semaphone fork [5] initialized to 1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT (i + N - 1) % N <span class="hljs-comment">// 左邻居</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT (i + 1) % N    <span class="hljs-comment">// 右邻居</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THINKING 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUNGRY   1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EATING   2</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<br><span class="hljs-keyword">int</span> state[N];                <span class="hljs-comment">// 跟踪每个哲学家的状态</span><br>semaphore mutex = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span><br>semaphore s[N];              <span class="hljs-comment">// 每个哲学家一个信号量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(TRUE) &#123;<br>        <span class="hljs-built_in">think</span>(i);<br>        <span class="hljs-built_in">take_two</span>(i);<br>        <span class="hljs-built_in">eat</span>(i);<br>        <span class="hljs-built_in">put_two</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">take_two</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-built_in">down</span>(&amp;mutex);<br>    state[i] = HUNGRY;<br>    <span class="hljs-built_in">check</span>(i);<br>    <span class="hljs-built_in">up</span>(&amp;mutex);<br>    <span class="hljs-built_in">down</span>(&amp;s[i]); <span class="hljs-comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put_two</span><span class="hljs-params">(i)</span> </span>&#123;<br>    <span class="hljs-built_in">down</span>(&amp;mutex);<br>    state[i] = THINKING;<br>    <span class="hljs-built_in">check</span>(LEFT); <span class="hljs-comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span><br>    <span class="hljs-built_in">check</span>(RIGHT);<br>    <span class="hljs-built_in">up</span>(&amp;mutex);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-built_in">down</span>(&amp;mutex);<br>    state[i] = EATING;<br>    <span class="hljs-built_in">up</span>(&amp;mutex);<br>&#125;<br><br><span class="hljs-comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(i)</span> </span>&#123;         <br>    <span class="hljs-keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;<br>        state[i] = EATING;<br>        <span class="hljs-built_in">up</span>(&amp;s[i]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1><blockquote><p>  第十一章的主要内容是：死锁和进程通信</p></blockquote><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源</p><p>示例:</p><ul><li>系统有2个磁带驱动器</li><li>P1和P2各有一个,都需要另外一个</li></ul><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>资源类型R1,R2,..,Rm(CPU, memory space, IO devices)</p><p>每个资源类型Ri有Wi个实例.</p><p>每个进程使用资源如下:</p><ul><li>require,get ← free resource</li><li>use,hold    ← requested,used resource</li><li>release     ← free resource</li></ul><p>可重复使用的资源</p><ul><li>在一个时间只能有一个进程使用且不能被删除</li><li>进程获得资源,后来释放由其他进程重用</li><li>处理器,IO通道,主和副存储器,设备和数据结构,如文件,数据库和信号量</li><li>如果每个进程拥有一个资源并请求其他资源,死锁可能发生</li></ul><p>使用资源</p><ul><li>创建和销毁</li><li>在IO缓存区的中断,信号,消息,信息</li><li>如果接收消息阻塞可能会发生死锁</li><li>可能少见的组合事件会引起死锁</li></ul><p>资源分配图</p><p>一组顶点V和边E的集合</p><ul><li>V有两种类型:<ul><li>P={P1,P2,…,Pn},集合包括系统中的所有进程</li><li>R={R1,R2,…,Rm},集合包括系统中的所有资源类型</li></ul></li><li>requesting,claiming edge - directed edge Pi → Rj</li><li>assignment,holding  edge - directed edge Rj → Pi</li></ul><p>基本情况</p><p>如果图中不包含循环:</p><ul><li>没有死锁</li></ul><p>如果图中包含循环:</p><ul><li>如果每个资源类只有一个实例,那么死锁</li><li>如果每个资源类有几个实例,可能死锁</li></ul><h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><p>死锁出现一定会出现以下四个条件,但是出现以下四个条件不一定死锁:</p><ul><li>互斥: 在一个时间只能有一个进程使用资源</li><li>持有并等待: 进程保持至少一个资源正在等待获取其他进程持有的额外资源</li><li>无抢占: 一个资源只能被进程资源释放,进程已经完成了它的任务之后</li><li>循环等待: 存在等待进程集合{P0,P1,…,Pn},P0正在等待P1所占用的资源,P1正在等待P2占用的资源…Pn-1在等待Pn的资源,Pn正在等待P0所占用的资源</li></ul><h2 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h2><p>常见方法</p><ul><li>确保系统永远不会进入死锁状态</li><li>运行系统进入死锁状态,然后恢复.</li><li>忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX</li></ul><h3 id="Deadlock-Prevention-预防"><a href="#Deadlock-Prevention-预防" class="headerlink" title="Deadlock Prevention    预防"></a>Deadlock Prevention    预防</h3><p>限制申请方式</p><ul><li>互斥 - 共享资源不是必须的,必须占用非共享资源</li><li>占用并等待 - 必须保证当一个进程请求的资源,它不持有任何其他资源<ul><li>需要进程请求并分配其所有资源,它开始执行之前或允许进程请求资源仅当进程没有资源</li><li>资源利用率低,可能发生饥饿</li></ul></li><li>无抢占 -<ul><li>如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源</li><li>被抢占资源添加到资源列表中</li><li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li></ul></li><li>循环等待 - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请</li></ul><h3 id="Deadlock-Avoidance-避免"><a href="#Deadlock-Avoidance-避免" class="headerlink" title="Deadlock Avoidance     避免"></a>Deadlock Avoidance     避免</h3><p>需要系统具有一些额外的先验信息提供</p><ul><li>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目</li><li>资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求</li><li>死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态</li><li>当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态</li><li>系统处于安全状态指: 针对所有进程,存在安全序列</li><li>序列<P1,P2,...,Pn>是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i.<ul><li>如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成</li><li>当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止.</li><li>用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源.</li></ul></li><li>如果系统处于安全状态→无死锁</li><li>如果系统处于不安全状态→可能死锁</li><li>避免死锁: 确保系统永远不会进入不安全状态</li></ul><h3 id="Deadlock-Detection-检测"><a href="#Deadlock-Detection-检测" class="headerlink" title="Deadlock Detection     检测"></a>Deadlock Detection     检测</h3><p>每个资源类型单一实例</p><p>Maintain wait-for graph</p><ul><li>结点是进程</li><li>Pi→Pj: Pi等待Pj</li></ul><p>定期调用检测算法来搜索图中是否存在循环</p><p>算法需要n^2次操作,n是图中顶点的数目</p><p>数据结构:</p><ul><li>Available: 长度为M的向量表示每种类型可用资源的数量</li><li>Allocation: 一个nxm矩阵定义了当前分配给各个进程每种类型资源的数量,如果Alocation[i, j] = k, 进程Pi拥有资源Rj的k个实例</li><li>Request: 一个nxm矩阵表示各进程的当前请求.如果Request[i, j] = k,表示进程Pi请求k个资源Pj的实例</li></ul><p>具体算法(跳过了,看视频)</p><p>检查算法使用</p><p>何时,使用什么样的频率来检测依赖于:</p><ul><li>死锁多久可能会发生?</li><li>多少进程需要被回滚? one for each disjoint cycle</li></ul><p>如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁</p><h3 id="Recovery-from-Deadlock-恢复"><a href="#Recovery-from-Deadlock-恢复" class="headerlink" title="Recovery from Deadlock 恢复"></a>Recovery from Deadlock 恢复</h3><p>终止所有的死锁进程</p><p>在一个时间内终止一个进程直到死锁消除</p><p>终止进程的顺序应该是:</p><ul><li>进程的优先级</li><li>进程运行了多久以及需要多少时间才能完成</li><li>进程占用的资源</li><li>进程完成需要的资源</li><li>多少进程需要被终止</li><li>进程是交互还是批处理</li></ul><p>选择一个受孩子 - 最小的成本</p><p>回滚 - 返回到一些安全状态,重启进程到安全状态</p><p>饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程通信的机制及同步</p><p>不使用共享变量的进程通信</p><p>IPC facility 提供2个操作:</p><ul><li>send(message) - 消息大小固定或者可变</li><li>receive(message)</li></ul><p>如果P和Q想通信,需要:</p><ul><li>在它们之间建立通信链路</li><li>通过send/recevie交换消息</li></ul><p>通信链路的实现</p><ul><li>物理(例如,共享内存,硬件总线)</li><li>逻辑(例如,逻辑属性)</li></ul><h3 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h3><p>进程必须正确的命名对方:</p><ul><li>send(P, message) - 发送消息到进程P</li><li>receive(Q, message) - 从进程Q接收信息</li></ul><p>通信链路的属性</p><ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链路存在</li><li>链路可以是单向的,但通常是双向的</li></ul><h3 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h3><p>定向从消息队列接收消息</p><ul><li>每个消息对垒都有一个唯一的ID</li><li>只有它们共享了一个消息队列,进程才能够通信</li></ul><p>通信链路的属性</p><ul><li>只有进程共享一个共同的消息队列,才建立链路</li><li>链接可以与许多进程相关联</li><li>每对进程可以共享多个通信链路</li><li>链接可以是单向或者双向</li></ul><p>操作</p><ul><li>创建一个新的消息队列</li><li>通过消息队列发送和接收消息</li><li>销毁消息队列</li></ul><p>原语的定义如下:</p><ul><li>send(A, message)</li><li><p>receive(A, message)</p></li><li><p>通信链路缓冲</p><p>  通信链路缓存大小:</p><ol><li>0容量 - 0 message : 发送方必须等待接收方</li><li>有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满</li><li>无限容量 - 无限长度 : 发送方不需要等待</li></ol></li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号Signal</p><ul><li>软件中断通知事件处理</li><li>Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT</li></ul><p>接收到信号时会发生什么?</p><ul><li>catch:  指定信号处理函数被调用</li><li>ignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)</li><li>mask:   闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)</li></ul><p>不足:</p><ul><li>不能传输要交换的任何数据</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>数据交换</p><p>子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr)</p><p>进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.</p><p>例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列按FIFO来管理消息</p><ul><li>message: 作为一个字节序列存储</li><li>message queues: 消息数组</li><li>FIFO &amp;  FILO configuration</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程</p><ul><li>每个进程都有私有地址空间</li><li>在每个地址空间内,明确地设置了共享内存段</li></ul><p>优点</p><ul><li>快速,方便地共享数据</li></ul><p>不足</p><ul><li>必须同步数据访问</li></ul><p>最快的方法</p><p>一个进程写另一个进程立即可见</p><p>没有系统调用干预</p><p>没有数据复制</p><p>不提供同步</p><ul><li>Socket</li></ul><h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1><blockquote><p>  第十二章的主要内容是：文件管理</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="文件系统和文件"><a href="#文件系统和文件" class="headerlink" title="文件系统和文件"></a>文件系统和文件</h3><p>文件系统: 一种用于持久性存储的系统抽象</p><ul><li>在存储上: 组织,控制,导航,访问和检索数据</li><li>在大多数计算机系统包含文件系统</li><li>个人电脑,服务器,笔记本电脑</li><li>ipod,tivo,机顶盒,手机,电脑</li><li>google可能也是由一个文件系统构成的</li></ul><p>文件: 文件系统中的一个单元的相关数据在操作系统中的抽象</p><p>文件系统的功能:</p><ul><li>分配文件磁盘空间<ul><li>管理文件块(哪一块属于哪一个文件)</li><li>管理空闲空间(哪一块是空闲的)</li><li>分配算法(策略)</li></ul></li><li>管理文件集合<ul><li>定位文件及其内容</li><li>命名: 通过名字找到文件的接口</li><li>最常见: 分层文件系统</li><li>文件系统类型(组织文件的不同方式)</li></ul></li><li>提供的便利及特征<ul><li>保护: 分层来保护数据安全</li><li>可靠性,持久性: 保持文件的持久即使发生崩溃,媒体错误,攻击等</li></ul></li></ul><p>文件和块:</p><p>文件属性: 名称,类型,位置,大小,保护,创建者,创建时间,最久修改时间…</p><p>文件头: 在存储元数据中保存了每个文件的信息,保存文件的属性,跟踪哪一块存储块属于逻辑上文件结构的哪个偏移</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件使用模式:</p><p>使用程序必须在使用前先”打开”文件</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">f = <span class="hljs-built_in">open</span>(name, flag);<br>...<br>... = <span class="hljs-built_in">read</span>(f, ...);<br>...<br><span class="hljs-built_in">close</span>(f);<br></code></pre></div></td></tr></table></figure><p>内核跟踪每个进程打开的文件:</p><ul><li>操作系统为每个进程维护一个打开文件表</li><li>一个打开文件描述符是这个表中的索引</li></ul><p>需要元数据来管理打开文件:</p><p>文件指针: 指向最近的一次读写位置,每个打开了这个文件的进程都这个指针</p><p>文件打开计数: 记录文件打开的次数 - 当最后一个进程关闭了文件时,允许将其从打开文件表中移除</p><p>文件磁盘位置: 缓存数据访问信息</p><p>访问权限: 每个程序访问模式信息</p><p>用户视图: 持久的数据结构</p><p>系统访问接口:</p><p>字节的集合(UNIX)</p><p>系统不会关心你想存储在磁盘上的任何的数据结构</p><p>操作系统内部视角:</p><p>块的集合(块是逻辑转换单元,而扇区是物理转换单元)</p><p>块大小&lt;&gt; 扇区大小: 在UNIX中, 块的大小是 4KB</p><p>当用户说: 给我2-12字节空间时会发生什么?</p><p>获取字节所在的快</p><p>返回快内对应部分</p><p>如果要写2-12字节?</p><p>获取块</p><p>修改块内对应部分</p><p>写回块</p><p>在文件系统中的所有操作都是在整个块空间上进行的: <code>getc()</code> <code>putc()</code> 即使每次只访问1字节的数据,也会缓存目标数据4096字节(一个磁盘块)</p><p>用户怎么访问文件: 在系统层面需要知道用户的访问模式</p><p>顺序访问: 按字节依次读取(几乎所有的访问都是这种方式)</p><p>随机访问: 从中间读写(不常用,但是仍然重要,如: 虚拟内存支持文件,内存页存储在文件中;更加快速,不希望获取文件中间的内容的时候也必须先获取块内所有字节)</p><p>内容访问: 通过特征</p><p>文件内部结构:</p><p>无结构: 单词,比特的队列</p><p>简单记录结构: 列,固定长度,可变长度</p><p>复杂结构: 格式化的文档(word, PDF), 可执行文件, …</p><p>多用户系统中的文件共享是很必要的</p><p>访问控制:</p><p>谁能够获得哪些文件的哪些访问权限</p><p>访问模式: 读,写,执行,删除,列举等</p><p>文件访问控制列表(ACL):</p><p>&lt;文件实体, 权限&gt;</p><p>UNIX模式:</p><p>&lt;用户|组|所有人,读|写|可执行&gt;</p><p>用户ID识别用户,表明每个用户所允许的权限及保护模式</p><p>组ID允许用户组成组,并指定了组访问权限</p><p>指定多用户,客户如何同时访问共享文件:</p><p>和过程同步算法相似</p><p>因磁盘IO和网络延迟而设计简单</p><p>UNIX文件系统(UFS)语义:</p><p>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</p><p>共享文件指针允许多用户同时读取和写入文件</p><p>会话语义:</p><p>写入内容只有当文件关闭时可见</p><p>锁:</p><p>一些操作系统和文件系统提供该功能</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>文件以目录的方式组织起来</p><p>目录是一类特殊的文件: 每个目录都包含了一张表<name, pointer to file header></p><p>目录和文件的树形结构: 早期的文件系统是扁平的(只有一层目录)</p><p>层次名称空间: /spell/mail/prt/first  /programs/p/list</p><p>典型操作:</p><p>搜索文件</p><p>创建文件</p><p>删除文件</p><p>枚举目录</p><p>重命名文件</p><p>在文件系统中遍历一个路径</p><p>操作系统应该只允许内核模式修改目录: 确保映射的完整性,应用程序能够读目录(ls)</p><p>文件名的线性列表,包含了指向数据块的指针: 编程简单,执行耗时</p><p>Hash表 - hash数据结构的线性表: 减少目录搜索时间,碰撞,固定大小</p><p>名字解析: 逻辑名字转换成物理资源(如文件)的过程:</p><p>在文件系统中: 到实际文件的文件名(路径)</p><p>遍历文件目录直到找到目标文件</p><p>举例: 解析”/bin/ls”:</p><p>读取root的文件头(在磁盘固定位置)</p><p>读取root的数据块: 搜索bin项</p><p>读取bin的文件头</p><p>读取bin的数据块: 搜索ls项</p><p>读取ls的文件头</p><p>当前工作目录:</p><p>每个进程都会指向一个文件目录用于解析文件名</p><p>允许用户指定相对路径来代替绝对路径</p><p>一个文件系统需要先挂载才能被访问</p><p>一个未挂载的文件系统被挂载在挂载点上</p><h3 id="文件别名"><a href="#文件别名" class="headerlink" title="文件别名"></a>文件别名</h3><p>两个或多个文件名关联同一个文件:</p><p>硬链接: 多个文件项指向一个文件</p><p>软链接: 以快捷方式指向其他文件</p><p>通过存储真实文件的逻辑名称来实现</p><p>如果删除一个有别名的文件会如何呢? : 这个别名将成为一个悬空指针</p><p>Backpointers 方案:</p><p>每个文件有一个包含多个backpointers的列表,所以删除所有的Backpointers</p><p>backpointers使用菊花链管理</p><p>添加一个间接层: 目录项数据结构</p><p>链接: 已存在文件的另外一个名字(指针)</p><p>链接处理: 跟随指针来定位文件</p><p>我们如何保证没有循环呢?</p><p>只允许到文件的链接, 不允许在子目录的链接</p><p>每增加一个新的链接都用循环检测算法确定是否合理</p><p>限制路径可遍历文件目录的数量</p><h3 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h3><p>磁盘文件系统: 文件存储在数据存储设备上,如磁盘; 例如: FAT,NTFS,ext2,3,ISO9660等</p><p>数据库文件系统: 文件根据其特征是可被寻址的; 例如: WinFS</p><p>日志文件系统: 记录文件系统的修改,事件; 例如: journaling file system</p><p>网络,分布式文件系统: 例如: NFS,SMB,AFS,GFS</p><p>特殊,虚拟文件系统</p><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>分层结构:</p><p>顶层: 文件,文件系统API</p><p>上层: 虚拟(逻辑)文件系统 (将所有设备IO,网络IO全抽象成为文件,使得接口一致)</p><p>底层: 特定文件系统模块</p><p>目的: 对所有不同文件系统的抽象</p><p>功能:</p><p>提供相同的文件和文件系统接口</p><p>管理所有文件和文件系统关联的数据结构</p><p>高效查询例程,遍历文件系统</p><p>与特定文件系统模块的交互</p><p>数据结构:</p><p>卷[第四声]控制块(UNIX: “superblock”)</p><p>每个文件系统一个</p><p>文件系统详细信息</p><p>块,块大小,空余块,计数,指针等</p><p>文件控制块(UNIX: “vnode” or “inode”)</p><p>每个文件一个</p><p>文件详细信息</p><p>许可,拥有者,大小,数据库位置等</p><p>目录结点(Linux: “dentry”)</p><p>每个目录项一个(目录和文件)</p><p>将目录项数据结构及树形布局编码成树形数据结构</p><p>指向文件控制块,父结点,项目列表等</p><p>其中: 卷控制块(每个文件系统一个),文件控制块(每个文件一个),目录结点(每个目录项一个)</p><p>持续存储在二级存储中: 在分配在存储设备中的数据块中</p><p>当需要时加载进内存:</p><p>卷控制块: 当文件系统挂载时进入内存</p><p>文件控制块: 当文件被访问时进入内存</p><p>目录结点: 在遍历一个文件路径时进入内存</p><h2 id="数据块缓存"><a href="#数据块缓存" class="headerlink" title="数据块缓存"></a>数据块缓存</h2><p>数据块按需读入内存:</p><p>提供 <code>read()</code> 操作</p><p>预读: 预先读取后面的数据块</p><p>数据块使用后被缓存:</p><p>假设数据将会再次被使用</p><p>写操作可能被缓存和延迟写入</p><p>两种数据块缓存方式:</p><p>普通缓冲区缓存</p><p>页缓存: 同一缓存数据块和内存页</p><p>分页要求: 当需要一个页时才将其载入内存</p><p>支持存储: 一个页(在虚拟地址空间中)可以被映射到一个本地文件中(在二级存储中)</p><h2 id="打开文件的数据结构"><a href="#打开文件的数据结构" class="headerlink" title="打开文件的数据结构"></a>打开文件的数据结构</h2><p>打开文件描述:</p><p>每个被打开的文件一个</p><p>文件状态信息</p><p>目录项,当前文件指针,文件操作设置等</p><p>打开文件表:</p><p>一个进程一个</p><p>一个系统级的</p><p>每个卷控制块也会保存一个列表</p><p>所以如果有文件被打开将不能被卸载</p><p>一些操作系统和文件系统提供该功能</p><p>调节对文件的访问</p><p>强制和劝告:</p><p>强制 - 根据锁保持情况和需求拒绝访问</p><p>劝告 - 进程可以查找锁的状态来决定怎么做</p><h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p>大多数文件都很小:</p><p>需要对小文件提供强力的支持</p><p>块空间不能太小</p><p>一些文件非常大:</p><p>必须支持大文件(64-bit 文件偏移)</p><p>大文件访问需要相当高效</p><p>如何为一个文件分配数据块</p><p>分配方式:</p><p>连续分配</p><p>链式分配</p><p>索引分配</p><p>指标:</p><p>高效: 如存储利用(外部碎片)</p><p>表现: 如访问速度</p><p>连续分配:</p><p>文件头指定起始块和长度</p><p>位置,分配策略: 最先匹配,最佳匹配,…</p><p>优势: 文件读取表现好;高效的顺序和随机访问</p><p>劣势: 碎片;文件增长问题</p><p>链式分配:</p><p>文件以数据块链表方式存储</p><p>文件头包含了到第一块和最后一块的指针</p><p>优势: 创建,增大,缩小很容易;没有碎片</p><p>劣势: 不可能进行真正的随机访问;可靠性</p><p>索引分配:</p><p>为每个文件创建一个名为索引数据块的非数据数据块(到文件数据块的指针列表)</p><p>文件头包含了索引数据块</p><p>优势: 创建,增大,缩小很容易;没有碎片;支持直接访问</p><p>劣势: 当文件很小时,存储索引的开销大;处理大文件难</p><h2 id="空闲空间列表"><a href="#空闲空间列表" class="headerlink" title="空闲空间列表"></a>空闲空间列表</h2><p>跟踪在存储中的所有未分配的数据块</p><p>空闲空间列表存储在哪里?</p><p>空闲空间列表的最佳数据结构怎么样?</p><p>用位图代表空闲数据块列表: 11111101101110111 如果 i = 0表明数据块i是空闲的,反之是分配的</p><p>使用简单但是可能会是一个big vector:</p><p>160GB disk → 40M blocks → 5MB worth of bits</p><p>然而,如果空闲空间在磁盘中均匀分布,那么再找到”0”之前需要扫描 磁盘上数据块总数 / 空闲块的数目</p><p>需要保护:</p><p>指向空闲列表的指针</p><p>位图:</p><p>必须保存在磁盘上;在内存和磁盘拷贝可能有所不同;不允许block[i]在内存中的状态为bit[i]=1而在磁盘中bit[i]=0</p><p>解决:</p><p>在磁盘上设置bit[i] = 1; 分配block[i]; 在内存中设置bit[i] = 1</p><h2 id="多磁盘管理-RAID"><a href="#多磁盘管理-RAID" class="headerlink" title="多磁盘管理 - RAID"></a>多磁盘管理 - RAID</h2><p>通常磁盘通过分区来最大限度减小寻道时间:</p><p>一个分区是一个柱面的集合</p><p>每个分区都是逻辑上独立的磁盘</p><p>分区: 硬件磁盘的一种适合操作系统指定格式的划分</p><p>卷: 一个拥有一个文件系统实例的可访问的存储空间(通常常驻在磁盘的单个分区上)</p><p>使用多个并行磁盘来增加: 吞吐量(通过并行),可靠性和可用性(通过冗余)</p><p>RAID - 冗余磁盘阵列: 各种磁盘管理技术;RAID levels: 不同RAID分类,如RAID-0,RAID-1,RAID-5</p><p>实现: 在操作系统内核: 存储,卷管理; RAID硬件控制器(IO)</p><p>RAID-0</p><p>数据块分成多个子块, 存储在独立的磁盘中: 和内存交叉相似</p><p>通过更大的有效块大小来提供更大的磁盘带宽</p><p>RAID-1</p><p>可靠性成倍增长</p><p>读取性能线性增加(向两个磁盘写入,从任何一个读取)</p><p>RAID-4</p><p>数据块级磁带配有专用奇偶校验磁盘: 允许从任意一个故障磁盘中恢复</p><p>条带化和奇偶校验按byte-by-byte或者bit-by-bit: RAID-0,4,5: block-wise ;RAID-3: bit-wise</p><p>RAID-5</p><p>每个条带快有一个奇偶校验块,允许有一个磁盘错误</p><p>RAID-6</p><p>两个冗余块,有一种特殊的编码方式,允许两个磁盘错误</p><h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>读取或写入时,磁头必须被定位在期望的磁道,并从所期望的扇区开始</p><p>寻道时间: 定位到期望的磁道所花费的时间</p><p>旋转延迟: 从扇区的开始处到到达目的处花费的时间</p><p>平均旋转延迟时间 = 磁盘旋转一周时间的一半</p><p>寻道时间是性能上区别的原因</p><p>对单个磁盘,会有一个IO请求数目</p><p>如果请求是随机的,那么会表现很差</p><p>FIFO:</p><p>按顺序处理请求</p><p>公平对待所有进程</p><p>在有很多进程的情况下,接近随机调度的性能</p><p>最短服务优先:</p><p>选择从磁臂当前位置需要移动最少的IO请求</p><p>总是选择最短寻道时间</p><p>skan:</p><p>磁臂在一个方向上移动,满足所有为完成的请求,直到磁臂到达该方向上最后的磁道</p><p>调换方向</p><p>c-skan:</p><p>限制了仅在一个方向上扫描</p><p>当最后一个磁道也被访问过了后,磁臂返回到磁盘的另外一端再次进行扫描</p><p>c-loop(c-skan改进):</p><p>磁臂先到达该方向上最后一个请求处,然后立即反转</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡尔曼滤波</title>
    <link href="/2020/06/08/KalmanFilter/"/>
    <url>/2020/06/08/KalmanFilter/</url>
    
    <content type="html"><![CDATA[<h1 id="卡尔曼滤波的基本原理和代码实现-python"><a href="#卡尔曼滤波的基本原理和代码实现-python" class="headerlink" title="卡尔曼滤波的基本原理和代码实现(python)"></a>卡尔曼滤波的基本原理和代码实现(python)</h1><h3 id="通俗易懂的卡尔曼滤波推导和解释："><a href="#通俗易懂的卡尔曼滤波推导和解释：" class="headerlink" title="通俗易懂的卡尔曼滤波推导和解释："></a>通俗易懂的卡尔曼滤波推导和解释：</h3><p><a href="https://www.zhihu.com/question/23971601?sort=created">https://www.zhihu.com/question/23971601?sort=created</a></p><h3 id="数学原理："><a href="#数学原理：" class="headerlink" title="数学原理："></a>数学原理：</h3><p>source: <a href="https://courses.engr.illinois.edu/ece420/sp2017/UnderstandingKalmanFilter.pdf">https://courses.engr.illinois.edu/ece420/sp2017/UnderstandingKalmanFilter.pdf</a></p><p><img src="/img/pics/6C16B1CE696E6E9637B9F0A764F1FD10.png" alt=""><br><img src="/img/pics/1ED2D1AE1776F40D7806B72825B0A682.png" alt=""><br><img src="/img/pics/10A43B16D935315E96FCBAADE2AD3ED6.png" alt=""></p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><p><a href="https://github.com/mabhisharma/Multi-Object-Tracking-with-Kalman-Filter">https://github.com/mabhisharma/Multi-Object-Tracking-with-Kalman-Filter</a><br><a href="https://github.com/Myzhar/simple-opencv-kalman-tracker">https://github.com/Myzhar/simple-opencv-kalman-tracker</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KalmanFilter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, dt=<span class="hljs-number">1</span>,stateVariance=<span class="hljs-number">1</span>,measurementVariance=<span class="hljs-number">1</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">method=<span class="hljs-string">&quot;Velocity&quot;</span> </span>):</span><br><span class="hljs-built_in">super</span>(KalmanFilter, self).__init__()<br>self.method = method<br>self.stateVariance = stateVariance<br>self.measurementVariance = measurementVariance<br>self.dt = dt<br>self.initModel()<br><br><span class="hljs-string">&quot;&quot;&quot;init function to initialise the model&quot;&quot;&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initModel</span>(<span class="hljs-params">self</span>):</span> <br><span class="hljs-keyword">if</span> self.method == <span class="hljs-string">&quot;Accerelation&quot;</span>:<br>self.U = <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>: <br>self.U = <span class="hljs-number">0</span><br>self.A = np.matrix( [[<span class="hljs-number">1</span> ,self.dt, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <br>     [<span class="hljs-number">0</span> , <span class="hljs-number">1</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span>], <br>     [<span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span> , self.dt],  <br>     [<span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">1</span>]] )<br><br>self.B = np.matrix( [[self.dt**<span class="hljs-number">2</span>/<span class="hljs-number">2</span>], <br>     [self.dt], <br>     [self.dt**<span class="hljs-number">2</span>/<span class="hljs-number">2</span>], <br>     [self.dt]] )<br><br>self.H = np.matrix( [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] ) <br>self.P = np.matrix(self.stateVariance*np.identity(self.A.shape[<span class="hljs-number">0</span>]))<br>self.R = np.matrix(self.measurementVariance*np.identity(self.H.shape[<span class="hljs-number">0</span>]))<br><br>self.Q = np.matrix( [[self.dt**<span class="hljs-number">4</span>/<span class="hljs-number">4</span> ,self.dt**<span class="hljs-number">3</span>/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <br>     [self.dt**<span class="hljs-number">3</span>/<span class="hljs-number">2</span>, self.dt**<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <br>     [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.dt**<span class="hljs-number">4</span>/<span class="hljs-number">4</span> ,self.dt**<span class="hljs-number">3</span>/<span class="hljs-number">2</span>],<br>     [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, self.dt**<span class="hljs-number">3</span>/<span class="hljs-number">2</span>,self.dt**<span class="hljs-number">2</span>]])<br><br>self.erroCov = self.P<br>self.state = np.matrix([[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>]])<br><br><br><span class="hljs-string">&quot;&quot;&quot;Predict function which predicst next state based on previous state&quot;&quot;&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self</span>):</span><br>self.predictedState = self.A*self.state + self.B*self.U<br>self.predictedErrorCov = self.A*self.erroCov*self.A.T + self.Q<br>temp = np.asarray(self.predictedState)<br><span class="hljs-keyword">return</span> temp[<span class="hljs-number">0</span>], temp[<span class="hljs-number">2</span>]<br><br><span class="hljs-string">&quot;&quot;&quot;Correct function which correct the states based on measurements&quot;&quot;&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">correct</span>(<span class="hljs-params">self, currentMeasurement</span>):</span><br>       <span class="hljs-comment">#pinv:求广义逆</span><br>self.kalmanGain = self.predictedErrorCov*self.H.T*np.linalg.pinv(<br>self.H*self.predictedErrorCov*self.H.T+self.R)<br>self.state = self.predictedState + self.kalmanGain*(currentMeasurement<br>     - (self.H*self.predictedState))<br><br><br>self.erroCov = (np.identity(self.P.shape[<span class="hljs-number">0</span>]) - <br>self.kalmanGain*self.H)*self.predictedErrorCov<br><br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Cybernetics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>控制理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
