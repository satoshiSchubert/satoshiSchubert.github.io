

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Satoshi">
  <meta name="keywords" content="">
  <meta name="description" content="Notebook for DataStructure 数据结构复习题 第一讲 基本概念数据结构是什么？个人认为比较确切的定义：  “数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定以相关的函数来给出。” —Sartaj Sahni, 《数据结构、算法与应用》  举例：如何摆放图书？ 随便放 找书的时候累死   按照书名的拼音字母顺序排放 新书要如何插">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记">
<meta property="og:url" content="http://example.com/2021/08/10/DataStructure/index.html">
<meta property="og:site_name" content="Satoshi">
<meta property="og:description" content="Notebook for DataStructure 数据结构复习题 第一讲 基本概念数据结构是什么？个人认为比较确切的定义：  “数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定以相关的函数来给出。” —Sartaj Sahni, 《数据结构、算法与应用》  举例：如何摆放图书？ 随便放 找书的时候累死   按照书名的拼音字母顺序排放 新书要如何插">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/pics/child_sibling_1.png">
<meta property="og:image" content="http://example.com/img/pics/child_sibling_2.png">
<meta property="og:image" content="http://example.com/img/pics/3.2_1.png">
<meta property="og:image" content="http://example.com/img/pics/3.2_2.png">
<meta property="og:image" content="http://example.com/img/pics/3.2_3.png">
<meta property="og:image" content="http://example.com/img/pics/3.2_4.png">
<meta property="og:image" content="http://example.com/img/pics/3.3_1.png">
<meta property="og:image" content="http://example.com/img/pics/3.3_2.png">
<meta property="og:image" content="http://example.com/img/pics/3.3_3.png">
<meta property="og:image" content="http://example.com/img/pics/3.3_4.png">
<meta property="og:image" content="http://example.com/img/pics/3.3_5.png">
<meta property="og:image" content="http://example.com/img/pics/3.3_6.png">
<meta property="og:image" content="http://example.com/img/pics/4.1_1.png">
<meta property="og:image" content="http://example.com/img/pics/4.2_1.png">
<meta property="og:image" content="http://example.com/img/pics/4.2_2.png">
<meta property="og:image" content="http://example.com/img/pics/4.2_3.png">
<meta property="og:image" content="http://example.com/img/pics/4.2_4.png">
<meta property="og:image" content="http://example.com/img/pics/4.2_5.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-1.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-2.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-3.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-4.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-5.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-6.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-7.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-8.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-9.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-10.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-11.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-12.png">
<meta property="og:image" content="http://example.com/img/pics/BRT-13.png">
<meta property="og:image" content="http://example.com/img/pics/5.1_1.png">
<meta property="og:image" content="http://example.com/img/pics/5.1_2.png">
<meta property="og:image" content="http://example.com/img/pics/5.1_3.png">
<meta property="og:image" content="http://example.com/img/pics/5.1_4.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_1.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_2.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_3.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_4.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_5.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_6.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_7.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_8.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_9.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_10.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_11.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_12.png">
<meta property="og:image" content="http://example.com/img/pics/5.2_13.png">
<meta property="og:image" content="http://example.com/img/pics/5.3.1.png">
<meta property="og:image" content="http://example.com/img/pics/5.3.2.png">
<meta property="og:image" content="http://example.com/img/pics/5.3.4.png">
<meta property="og:image" content="http://example.com/img/pics/6.1.1.png">
<meta property="og:image" content="http://example.com/img/pics/6.1.5.png">
<meta property="og:image" content="http://example.com/img/pics/6.1.6.png">
<meta property="og:image" content="http://example.com/img/pics/8.2.1.png">
<meta property="og:image" content="http://example.com/img/pics/8.2.2.png">
<meta property="og:image" content="http://example.com/img/pics/8.2.3.png">
<meta property="og:image" content="http://example.com/img/pics/8.2.4.png">
<meta property="og:image" content="http://example.com/img/pics/8.2.5.png">
<meta property="og:image" content="http://example.com/img/pics/9.1.1.png">
<meta property="og:image" content="http://example.com/img/pics/9.1.2.png">
<meta property="og:image" content="http://example.com/img/pics/9.2.1.png">
<meta property="og:image" content="http://example.com/img/pics/9.2.2.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.1.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.2.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.3.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.4.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.5.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.6.png">
<meta property="og:image" content="http://example.com/img/pics/10.1.7.png">
<meta property="og:image" content="http://example.com/img/pics/10.2.1.png">
<meta property="og:image" content="http://example.com/img/pics/10.3.1.png">
<meta property="og:image" content="http://example.com/img/pics/10.3.2.png">
<meta property="og:image" content="http://example.com/img/pics/10.3.3.png">
<meta property="og:image" content="http://example.com/img/pics/11.1.1.png">
<meta property="og:image" content="http://example.com/img/pics/11.1.2.png">
<meta property="og:image" content="http://example.com/img/pics/11.1.3.png">
<meta property="og:image" content="http://example.com/img/pics/11.1.4.png">
<meta property="og:image" content="http://example.com/img/pics/11.1.5.png">
<meta property="og:image" content="http://example.com/img/pics/11.1.6.png">
<meta property="og:image" content="http://example.com/img/pics/11.2.1.png">
<meta property="og:image" content="http://example.com/img/pics/11.2.2.png">
<meta property="og:image" content="http://example.com/img/pics/11.2.3.png">
<meta property="og:image" content="http://example.com/img/pics/11.2.4.png">
<meta property="article:published_time" content="2021-08-10T13:26:00.000Z">
<meta property="article:modified_time" content="2021-12-03T07:15:27.740Z">
<meta property="article:author" content="Satoshi">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/pics/child_sibling_1.png">
  
  <title>数据结构笔记 - Satoshi</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CYBERNETICS</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-10 21:26" pubdate>
        2021年8月10日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      48k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      151 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构笔记</h1>
            
            <div class="markdown-body">
              <h1 id="Notebook-for-DataStructure"><a href="#Notebook-for-DataStructure" class="headerlink" title="Notebook for DataStructure"></a>Notebook for DataStructure</h1><hr>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43751983/article/details/103411097">数据结构复习题</a></p>
<h2 id="第一讲-基本概念"><a href="#第一讲-基本概念" class="headerlink" title="第一讲 基本概念"></a>第一讲 基本概念</h2><h3 id="数据结构是什么？"><a href="#数据结构是什么？" class="headerlink" title="数据结构是什么？"></a>数据结构是什么？</h3><p>个人认为比较确切的定义：</p>
<blockquote>
<p>“数据结构是数据对象，以及存在于该对象的实例和组成实例的数据元素之间的各种联系。这些联系可以通过定以相关的函数来给出。” —Sartaj Sahni, 《数据结构、算法与应用》</p>
</blockquote>
<h4 id="举例：如何摆放图书？"><a href="#举例：如何摆放图书？" class="headerlink" title="举例：如何摆放图书？"></a>举例：如何摆放图书？</h4><ul>
<li>随便放<ul>
<li>找书的时候累死</li>
</ul>
</li>
<li>按照书名的拼音字母顺序排放<ul>
<li>新书要如何插入？<ul>
<li>比如《阿Q正传》</li>
</ul>
</li>
<li>怎么找到指定的书？<ul>
<li>二分查找？</li>
</ul>
</li>
</ul>
</li>
<li>把书架分成几块，每块区域摆放指定类别的书；每种类别内按照拼音顺序排序<ul>
<li>新书怎么插入？<ul>
<li>先定类别，二分查找确定位置，<strong>移出空位</strong></li>
</ul>
</li>
<li>怎么找到某本指定的书？<ul>
<li>先定类别，再二分查找</li>
</ul>
</li>
<li>空间如何分配？类别应该分多细？</li>
</ul>
</li>
</ul>
<p><strong>解决问题的效率，跟数据的组织方式有关。</strong> </p>
<p>相较于循环算法，递归算法很占空间，效率很低。<br><!--补充二分法的知识--></p>
<p><strong>计时模板：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-comment">/* clock_t是clock()函数返回的变量类型*/</span><br><span class="hljs-keyword">clock_t</span> start,stop;<br><span class="hljs-keyword">double</span> duration;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    start = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-built_in">MyFunction</span>();<br>    stop = <span class="hljs-built_in">clock</span>();<br>    duration = ((<span class="hljs-keyword">double</span>)(stop - start))/CLK_TCK;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="数据对象的组织方式"><a href="#数据对象的组织方式" class="headerlink" title="数据对象的组织方式"></a>数据对象的组织方式</h4><ul>
<li>逻辑结构<ul>
<li>线性结构，一对一</li>
<li>树，一对多</li>
<li>图，多对多</li>
</ul>
</li>
<li>物理存储结构<ul>
<li>数组</li>
<li>链表</li>
</ul>
</li>
</ul>
<h4 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h4><ul>
<li>数据类型（面向对象语言中对象集和操作集是可以合并的，比如类）<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
</li>
<li>抽象：<strong>描述</strong>数据类型的方法<strong>不依赖于具体实现</strong><ul>
<li>与存放的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言无关</li>
</ul>
</li>
</ul>
<p><strong>只描述</strong>数据对象集和相关操作集<strong>是什么</strong>，并不涉及<strong>如何做到</strong>的问题。比如定义<strong>抽象</strong>数据类型：<code>ElementType</code>，之后在具体调用时只要<code>define ElementType xxx</code>即可，方便很多。</p>
<h3 id="算法是什么"><a href="#算法是什么" class="headerlink" title="算法是什么"></a>算法是什么</h3><h4 id="选择排序算法的伪码描述"><a href="#选择排序算法的伪码描述" class="headerlink" title="选择排序算法的伪码描述"></a>选择排序算法的伪码描述</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SelectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> List[],<span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*非递减排序*/</span><br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;N;i++&gt;)&#123;<br>        MinPosition = <span class="hljs-built_in">ScanForMin</span>(List,i,N<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">/*找list中从i到N-1的index中的最小元，并将其index返回*/</span><br>        <span class="hljs-comment">/*注意，这里是伪码，List看起来很香数组，但是它也可以是链表*/</span><br>        Swap（List[i],List[MinPosition]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="什么是好的算法"><a href="#什么是好的算法" class="headerlink" title="什么是好的算法"></a>什么是好的算法</h4><ul>
<li>空间复杂度S(n)<ul>
<li>根据算法写成的程序在执行时<strong>占用存储单元的长度</strong></li>
<li>S(n)过高的算法可能导致内存超限，导致非正常中断</li>
<li>比如递归算法，为了执行下一个递归需暂存目前函数的状态，比如为了<code>PrintN(9999)</code>需要先暂存<code>PrintN(10000)</code>的状态，而为了<code>PrintN(9998)</code>又需要暂存<code>PrintN(9999)</code>的状态，以此递推，需要占用很大的空间来暂存状态，S(n) = C·N </li>
</ul>
</li>
<li>时间复杂度T(n)<ul>
<li>根据算法写成的程序在执行时<strong>耗费时间的长度</strong></li>
<li>T(n)过高可能导致有生之年都没法执行完程序</li>
<li>比如计算多项式的值，若使用简单的循环<code>p += (a[i] * pow(x,i))</code>则需要(1+2+···+n = C<sub>1</sub>·n<sup>2</sup>+C<sub>2</sub>·n 次乘法)</li>
</ul>
</li>
</ul>
<h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>1</th>
<th>2</th>
<th>4</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>log n</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>n</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>n log n</td>
<td>0</td>
<td>2</td>
<td>8</td>
<td>24</td>
</tr>
<tr>
<td>n<sup>2</sup></td>
<td>1</td>
<td>4</td>
<td>6</td>
<td>64</td>
</tr>
<tr>
<td>2<sup>n</sup></td>
<td>2</td>
<td>4</td>
<td>16</td>
<td>256</td>
</tr>
<tr>
<td>n!</td>
<td>1</td>
<td>2</td>
<td>24</td>
<td>40326</td>
</tr>
</tbody>
</table>
</div>
<p><strong>复杂度分析窍门</strong></p>
<ul>
<li>对于加性的组合，算法复杂度取两个中最大的，T<sub>1</sub>+T<sub>2</sub> = max(O(f<sub>1</sub>(n)),O(f<sub>2</sub>(n)))</li>
<li>对于嵌套的组合（乘性），算法复杂度为两个的积的复杂度，T<sub>1</sub>xT<sub>2</sub> = O(f<sub>1</sub>(n)xf<sub>2</sub>(n))</li>
<li>若T(n)是关于n的k阶多项式，那么T(n)=O(n<sup>k</sup>)，也就是去最大的那一项</li>
<li>一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度</li>
<li>if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大</li>
</ul>
<h4 id="最大子列和"><a href="#最大子列和" class="headerlink" title="最大子列和"></a>最大子列和</h4><p>如下：</p>
<script type="math/tex; mode=display">f(i,j) = max(0,\Sigma_{k=i}^jA_k)</script><p>对于O(n<sup>2</sup>)的算法，应考虑是否能化成O(nlogn)</p>
<p><strong>分治法</strong>，分而治之</p>
<blockquote>
<p>把一个大而复杂的问题切分成小的块，并分别解决他们，最后再进行综合。</p>
</blockquote>
<hr>
<h2 id="第二讲-线性结构"><a href="#第二讲-线性结构" class="headerlink" title="第二讲 线性结构"></a>第二讲 线性结构</h2><h3 id="线性表及其实现"><a href="#线性表及其实现" class="headerlink" title="线性表及其实现"></a>线性表及其实现</h3><h4 id="多项式的表示"><a href="#多项式的表示" class="headerlink" title="多项式的表示"></a>多项式的表示</h4><ol>
<li><strong>顺序存储结构直接表示</strong><ul>
<li>值为系数，下标为指数</li>
<li>对于x+3x<sup>2000</sup>，则需要用2001个分量的数组来表示，效率很低</li>
<li>是否能只保存非零项？</li>
</ul>
</li>
<li><strong>顺序存储结构表示非零项</strong><ul>
<li>使用结构数组P<sub>1</sub>(x) = (a<sub>i</sub>,i),其中a<sub>i</sub>是系数，i是指数</li>
<li>为了计算方便，应按照指数大小有序存储</li>
<li>相加时只需从高到低分别滑动比较两个二元组的指数，copy指数更大的；若两个指数相同，则相加即可。</li>
</ul>
</li>
<li><p><strong>链表结构存储非零项</strong></p>
<ul>
<li>链表中每个<strong>结点</strong>存储多项式中的一个非零项，包括系数和指数两个数据域和一个指针域。</li>
</ul>
<p>| coef | expon | link |<br>| —— | ——- | —— |</p>
<p>定义一个结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span> *<span class="hljs-title">Polynominal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> coef;<br>    <span class="hljs-keyword">int</span> expon;<br>    Polynominal link;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h4 id="线性表，List"><a href="#线性表，List" class="headerlink" title="线性表，List"></a>线性表，List</h4><blockquote>
<p>由同类型<strong>数据元素</strong>构成<strong>有序序列</strong>的线性结构</p>
</blockquote>
</li>
</ol>
<ul>
<li>表中元素个数称为其长度</li>
<li>没有元素时，成为空表</li>
<li>起始位置是表头，结束位置是表尾</li>
</ul>
<h4 id="线性表的抽象数据类型描述"><a href="#线性表的抽象数据类型描述" class="headerlink" title="线性表的抽象数据类型描述"></a>线性表的抽象数据类型描述</h4><ul>
<li>类型名称：线性表（List）</li>
<li>数据对象集：线性表是n（&gt;=0）个元素构成的有序序列</li>
<li>操作集：对于L $\in$ List,整数i表示位置，元素X $\in$ ElementType，线性表基本操作如下：<ol>
<li>List MakeEmpty():返回一个初始化的空线性表</li>
<li>ElementType FindKth(int K, List L):返回第K位元素</li>
<li>int Find(ElementType X, List L):在L中查找X<strong>第一次</strong>出现的位置</li>
<li>void Insert(ElementType X, int i, List L):在第i位前插入X</li>
<li>void Delete(int i, List L):删除第i位元素</li>
<li>int Length(List L):返回长度</li>
</ol>
</li>
</ul>
<h4 id="线性表的顺序存储实现"><a href="#线性表的顺序存储实现" class="headerlink" title="线性表的顺序存储实现"></a>线性表的顺序存储实现</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    <span class="hljs-comment">//这里定义一个数组Data，最大长度是MAXSIZE，元素类型是ElementType</span><br>    ElementType Data[MAXSIZE]<br>    <span class="hljs-comment">//我们还要知道这个数组的末端在哪里噢</span><br>    <span class="hljs-keyword">int</span> Last;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">L</span>;</span><span class="hljs-comment">//构建了一个结构体L</span><br>List PtrL;<span class="hljs-comment">//构建了一个结构体指针PtrL</span><br><br><span class="hljs-comment">//若要访问下标为i的元素，下面两种方法都可以：</span><br>L.Data[i];<span class="hljs-comment">//或者</span><br>PtrL-&gt;Data[i];<br><span class="hljs-comment">//若要访问线性表的长度，则：</span><br>L.Last+<span class="hljs-number">1</span>;<span class="hljs-comment">//或者</span><br>Ptrl-&gt;Last+<span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>结构体和结构体指针的理解和使用：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36209467/article/details/82261286">https://blog.csdn.net/weixin_36209467/article/details/82261286</a></p>
<h4 id="线性表顺序存储的主要操作的实现"><a href="#线性表顺序存储的主要操作的实现" class="headerlink" title="线性表顺序存储的主要操作的实现"></a>线性表顺序存储的主要操作的实现</h4><p>（这里为什么要用结构体指针呢？可能是因为使用结构体进行操作的时候，比如作为函数参数，就要<strong>复制</strong>整个结构体，占内存？如果用指针，只需要复制4个字节（指针长度）即可，节省性能？）</p>
<ol>
<li>初始化<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">List <span class="hljs-title">MakeEmpty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    List PtrL;<br>    PtrL = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct LNode));<span class="hljs-comment">//分配空间</span><br>    PtrL-&gt;Last = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> PtrL;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>查找<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=PtrL-&gt;Last&amp;&amp;Ptrl-&gt;Data[i]!=X)<br>        i++;<br>    <span class="hljs-keyword">if</span>(i&gt;PtrL-&gt;Last) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//如果没找到</span><br>    <span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>插入<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//要先把每个元素往后挪</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X, <span class="hljs-keyword">int</span> i, List PrtL)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> j;<br>    <span class="hljs-keyword">if</span>(PtrL-&gt;Last == MAXSIZE<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;表已经满了&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;PtrL-&gt;Last+<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;位置不合法&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=PtrL-&gt;Last;j&gt;=i<span class="hljs-number">-1</span>;j++)<br>        PtrL-&gt;Data[j+<span class="hljs-number">1</span>]=PtrL-&gt;Data[j];<br>    PtrL-&gt;Data[i<span class="hljs-number">-1</span>] = X;<br>    PtrL-&gt;Last++;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>删除<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    inr j;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;PtrL-&gt;Last+<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;元素不存在&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(j=i;j&lt;=PtrL-&gt;Last;j++)<br>        PtrL-&gt;Data[j<span class="hljs-number">-1</span>]=PtrL-&gt;Data[j];<br>    PtrL-&gt;Last--;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="线性表链式存储的实现"><a href="#线性表链式存储的实现" class="headerlink" title="线性表链式存储的实现"></a>线性表链式存储的实现</h4><blockquote>
<p>只需逻辑上相邻，不需物理上相邻。通过<strong>链</strong>建立起数据元素之间的逻辑关系。<br>因此，插入或删除不需要移动元素，只需要修改<strong>链</strong>即可。</p>
</blockquote>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>$\sigma_1$</th>
<th>-&gt;</th>
<th>$\sigma_2$</th>
<th>-&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>链表定义</strong><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span>&#123;</span><br>    ElementType Data;<br>    List Next<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LNode</span> <span class="hljs-title">L</span>;</span><br>List PtrL;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="链表主要操作的实现"><a href="#链表主要操作的实现" class="headerlink" title="链表主要操作的实现"></a>链表主要操作的实现</h4><ol>
<li>求表长<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Length</span><span class="hljs-params">(List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p = PtrL; <span class="hljs-comment">//p指向链表的第一个结点</span><br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        <span class="hljs-comment">//对链表进行一次遍历，当遍历到最后一个元素时，指针p=NULL，就会终止循环。</span><br>        p = p-&gt;Next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j++;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>查找<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//1.按序号查找</span><br><span class="hljs-function">List <span class="hljs-title">FindKth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> K, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p = PtrL;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p !=NUll&amp;&amp; i&lt;K)&#123;<br>        p = p-&gt;Next;<span class="hljs-comment">//指向链表下一个</span><br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i == K)<br>         <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//找到第K个的指针值，返回p，否则返回空。</span><br>&#125;<br><br><span class="hljs-comment">//2.按值查找</span><br><span class="hljs-function">List <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p = PtrL;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span> &amp;&amp; p-&gt;Data!=X)&#123;<br>        p=p-&gt;Next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>插入<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.先构造一个新结点，用s指向</span><br><span class="hljs-comment">2.再找到第i-1个结点，用p指向</span><br><span class="hljs-comment">3.s-&gt;Next = p-&gt;Next</span><br><span class="hljs-comment">4.p-&gt;Next = s</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X, <span class="hljs-keyword">int</span> i, = List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p,s;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//新结点若插在表头，要单独考虑</span><br>        s = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct LNode));<span class="hljs-comment">//先分配空间</span><br>        s-&gt;Data = X;<br>        s-&gt;Next = PtrL;<span class="hljs-comment">//插在表头</span><br>        <span class="hljs-keyword">return</span> s;<span class="hljs-comment">//同时，返回新表的表头（已经变了）</span><br>    &#125;<br>    p = <span class="hljs-built_in">FindKth</span>(i<span class="hljs-number">-1</span>, PtrL);<span class="hljs-comment">//找到指向这个序号所对应结点的指针值</span><br>    <span class="hljs-keyword">if</span>(p = <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        s = (List)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct LNode));<br>        s-&gt;Data = X;<br>        s-&gt;Next = p-&gt;Next;<br>        p-&gt;Next = s;<br>        <span class="hljs-keyword">return</span> PtrL;<span class="hljs-comment">//表头位置不变</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>删除<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">1.若要删除第i个结点，先p指向第i-1个结点</span><br><span class="hljs-comment">2.然后s指向第i个结点</span><br><span class="hljs-comment">3.修改指针，p-&gt;Next=s-&gt;Next,第i个元素被丢出链表</span><br><span class="hljs-comment">4.free(s),释放空间</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">List <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,List PtrL)</span></span><br><span class="hljs-function"></span>&#123;<br>    List p,s;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//单独处理删除表头的情况</span><br>        s = PtrL;<br>        <span class="hljs-keyword">if</span>(PtrL!=<span class="hljs-literal">NULL</span>)&#123;<br>            PtrL = PtrL-&gt;Next;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">free</span>(s);<br>        <span class="hljs-keyword">return</span> PtrL;<br>    &#125;<br>    p = <span class="hljs-built_in">FindKth</span>(i<span class="hljs-number">-1</span>,PtrL);<br>    <span class="hljs-keyword">if</span>(p = <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error:%dth&quot;</span>,i<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;Next == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;argument error:%dth&quot;</span>,i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        s = p-&gt;Next;<br>        p-&gt;Next = s-&gt;Next;<br>        <span class="hljs-built_in">free</span>(s);<br>        <span class="hljs-keyword">return</span> PtrL;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4>广义表中，元素不仅可以是单元素也可以是另一个广义表。</li>
</ol>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">GList</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Tag; <span class="hljs-comment">//需要一个标签来标注这个结点是单元素(0)还是广义表(1)</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span>&#123;</span> <span class="hljs-comment">//cpp用union来组合不同类型的数据，这个数中可以是不一样的类型的数据</span><br>    ElementType Data;<span class="hljs-comment">//既可以是这种</span><br>    GList SubList;<span class="hljs-comment">//也可是这种指针</span><br>    &#125;URegion；<br>    GList Next;<span class="hljs-comment">//指向后续结点</span><br>&#125;；<br></code></pre></div></td></tr></table></figure>
<h4 id="多重链表"><a href="#多重链表" class="headerlink" title="多重链表"></a>多重链表</h4><p>链表中的结点可能同时隶属于多个链。</p>
<ul>
<li>多重链表中结点的指针域会有多个，如上一例中包含了Next和SubList两个指针。</li>
<li>然而，包含两个指针域并不一定就是多重链表，比如双向链表。</li>
</ul>
<p>树结构，图结构可以用多重链表来实现存储。</p>
<p>举例：可以使用<strong>十字链表</strong>来存储稀疏矩阵：</p>
<ul>
<li>只存储非零项，其中数据域包括：行R，列C，值V；</li>
<li>通过向右指针Right和向下指针Down来把这些结点串起来。</li>
</ul>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>后入先出</p>
<h4 id="栈的顺序存储实现"><a href="#栈的顺序存储实现" class="headerlink" title="栈的顺序存储实现"></a>栈的顺序存储实现</h4><p>通过一个一维数组来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxSize <span class="hljs-meta-string">&lt;12&gt;</span></span><br><span class="hljs-keyword">typedef</span> struch SNode *Stack;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span>&#123;</span><br>    ElementType Data[MaxSize];<br>    <span class="hljs-keyword">int</span> Top;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>入栈<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(Stack PtrS, ElemenType item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(PtrS-&gt;Top == MaxSize<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack full&quot;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        PtrS-&gt;Data[++(PtrS-&gt;Top)] = item; <span class="hljs-comment">// topp++</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>出栈</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">(Stack PtrS)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(Ptrs-&gt;Top == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack empty&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//ERROR是ElementType的特殊值，标志错误！</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">return</span></span>(PtrS-&gt;Data[(Ptrs-&gt;Top)--]);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="栈的链式存储实现"><a href="#栈的链式存储实现" class="headerlink" title="栈的链式存储实现"></a>栈的链式存储实现</h4><p>注意：链表尾端无法作为栈顶，因为不能对尾端进行删除操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Stack</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span>&#123;</span><br>    ElementType Data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SNode</span> *<span class="hljs-title">Next</span>;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>构建一个空堆栈：</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Stack <span class="hljs-title">CreateStack</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//构建一个堆栈的头结点，返回指针</span><br>    Stack S;<br>    S = (Stack)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct SNode)); <span class="hljs-comment">//这里也可以用new(c++)</span><br>    S = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SNode</span>();<br>    S-&gt;Next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(Stack S)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (S-&gt;Next == <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//链式堆栈只能在链表头插入删除，因此如果后面是NULL则表示这个链表(堆栈)空了</span><br>&#125; <br></code></pre></div></td></tr></table></figure>
<p> Tips：malloc和new的区别：</p>
<ul>
<li>malloc/free是标准库函数，new/delete是C++运算符</li>
<li>new/delete会调用构造、析构函数，malloc/free不会，所以他们无法满足动态对象的要求。</li>
<li>new返回有类型的指针，malloc返回无类型的指针。malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。</li>
<li>malloc内存分配失败后返回NULL；new分配内存失败则会抛异常（bac_alloc）。</li>
<li>reference: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40840459/article/details/81268252">https://blog.csdn.net/qq_40840459/article/details/81268252</a></li>
</ul>
</li>
</ol>
<ol>
<li>插入 <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">( Stack S, ElementType X )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将元素X压入堆栈S */</span><br>    PtrToSNode TmpCell;<br><br>    TmpCell = (PtrToSNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct SNode));<br>    TmpCell-&gt;Data = X;<br>    TmpCell-&gt;Next = S-&gt;Next;<br>    S-&gt;Next = TmpCell;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>删除 <figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">Pop</span><span class="hljs-params">( Stack S )</span>  </span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 删除并返回堆栈S的栈顶元素 */</span><br>    PtrToSNode FirstCell;<br>    ElementType TopElem;<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">IsEmpty</span>(S) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆栈空&quot;</span>); <br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FirstCell = S-&gt;Next; <br>        TopElem = FirstCell-&gt;Data;<br>        S-&gt;Next = FirstCell-&gt;Next;<br>        <span class="hljs-built_in">free</span>(FirstCell);<br>        <span class="hljs-keyword">return</span> TopElem;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4>详见浙大数据结构ppt</li>
<li><p>中缀表达式利用堆栈转换为后缀表达式</p>
<ul>
<li>运算数：直接输出；</li>
<li>左括号：压入堆栈；</li>
<li>右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）；</li>
<li>运算符：<ul>
<li>若优先级大于栈顶运算符时，则把它压栈；</li>
<li>若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；</li>
</ul>
</li>
<li>若各对象处理完毕，则把堆栈中存留的运算符一并输出。</li>
</ul>
</li>
<li><p>利用堆栈求后缀表达式的值</p>
<ul>
<li>字符序列的后缀表达式 -&gt; 分割 -&gt; 对象序列的后缀表达式 -&gt; 利用堆栈求值</li>
<li>6 2 / 3 - 4 2 * + =  8:</li>
<li>6/2=3,3-3=0,4*2=8,0+8=8</li>
</ul>
</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>是一种具有操作约束的线性表。<br><br>只能在后端(rear)插入，前端(front)删除，因此是先进先出（FIFO）。<br>| data(front) | data | data(rear) | -&gt; |<br>| —- | —- | —- | —- |</p>
<p>定义：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    ElementType *Data;     <span class="hljs-comment">/* 存储元素的数组 */</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-keyword">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br></code></pre></div></td></tr></table></figure></p>
<h4 id="队列的顺序存储实现"><a href="#队列的顺序存储实现" class="headerlink" title="队列的顺序存储实现"></a>队列的顺序存储实现</h4><p>循环队列，善用取余操作<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Queue <span class="hljs-title">CreateQueue</span><span class="hljs-params">( <span class="hljs-keyword">int</span> MaxSize )</span></span><br><span class="hljs-function"></span>&#123;<br>    Queue Q = (Queue)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct QNode));<br>    Q-&gt;Data = (ElementType *)<span class="hljs-built_in">malloc</span>(MaxSize * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElementType));<br>    Q-&gt;Front = Q-&gt;Rear = <span class="hljs-number">0</span>;<br>    Q-&gt;MaxSize = MaxSize;<br>    <span class="hljs-keyword">return</span> Q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((Q-&gt;Rear+<span class="hljs-number">1</span>)%(Q-&gt;MaxSize) == Q-&gt;Front);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">AddQ</span><span class="hljs-params">( Queue Q, ElementType X )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsFull</span>(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列满&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Q-&gt;Rear = (Q-&gt;Rear+<span class="hljs-number">1</span>)%(Q-&gt;MaxSize); <br>        Q-&gt;Data[Q-&gt;Rear] = X;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (Q-&gt;Front == Q-&gt;Rear);<br>&#125;<br><br><span class="hljs-function">ElementType <span class="hljs-title">DeleteQ</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">IsEmpty</span>(Q) ) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  &#123;<br>        Q-&gt;Front =(Q-&gt;Front+<span class="hljs-number">1</span>)%Q-&gt;MaxSize;<br>        <span class="hljs-keyword">return</span>  Q-&gt;Data[Q-&gt;Front];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h4><p>注意，front只能是链表头，rear只能是链表尾，因为只有链表头可以删除结点</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">PtrToNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">/* 队列中的结点 */</span><br>    ElementType Data;<br>    PtrToNode Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToNode Position;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> &#123;</span><br>    Position Front, Rear;  <span class="hljs-comment">/* 队列的头、尾指针 */</span><br>    <span class="hljs-keyword">int</span> MaxSize;           <span class="hljs-comment">/* 队列最大容量 */</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">Queue</span>;</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ( Q-&gt;Front == <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function">ElementType <span class="hljs-title">DeleteQ</span><span class="hljs-params">( Queue Q )</span></span><br><span class="hljs-function"></span>&#123;<br>    Position FrontCell; <br>    ElementType FrontElem;<br>    <br>    <span class="hljs-keyword">if</span>  ( <span class="hljs-built_in">IsEmpty</span>(Q) ) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;队列空&quot;</span>);<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        FrontCell = Q-&gt;Front;<br>        <span class="hljs-keyword">if</span> ( Q-&gt;Front == Q-&gt;Rear ) <span class="hljs-comment">/* 若队列只有一个元素 */</span><br>            Q-&gt;Front = Q-&gt;Rear = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 删除后队列置为空 */</span><br>        <span class="hljs-keyword">else</span>                     <br>            Q-&gt;Front = Q-&gt;Front-&gt;Next;<br>        FrontElem = FrontCell-&gt;Data;<br><br>        <span class="hljs-built_in">free</span>( FrontCell );  <span class="hljs-comment">/* 释放被删除结点空间  */</span><br>        <span class="hljs-keyword">return</span>  FrontElem;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<h3 id="多项式加法运算"><a href="#多项式加法运算" class="headerlink" title="多项式加法运算"></a>多项式加法运算</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Polynomial <span class="hljs-title">PolyAdd</span> <span class="hljs-params">(Polynomial P1, Polynomial P2)</span></span><br><span class="hljs-function"></span>&#123;<br>    Polynomial front, rear, temp;<br>    <span class="hljs-keyword">int</span> sum;<br>    rear = (Polynomial) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct PolyNode)); <br>    front = rear; <span class="hljs-comment">/* 由front 记录结果多项式链表头结点 */</span><br>    <span class="hljs-keyword">while</span> ( P1 &amp;&amp; P2 ) <span class="hljs-comment">/* 当两个多项式都有非零项待处理时 */</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( <span class="hljs-built_in">Compare</span>(P1-&gt;expon, P2-&gt;expon) ) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <br>            <span class="hljs-built_in">Attach</span>( P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>            P1 = P1-&gt;link;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <br>            <span class="hljs-built_in">Attach</span>(P2-&gt;coef, P2-&gt;expon, &amp;rear); <br>            P2 = P2-&gt;link;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <br>            sum = P1-&gt;coef + P2-&gt;coef;<br>            <span class="hljs-keyword">if</span> ( sum ) <span class="hljs-built_in">Attach</span>(sum, P1-&gt;expon, &amp;rear);<br>            P1 = P1-&gt;link; <br>            P2 = P2-&gt;link;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-comment">/* 将未处理完的另一个多项式的所有结点依次复制到结果多项式中去 */</span><br>    <span class="hljs-keyword">for</span> ( ; P1; P1 = P1-&gt;link ) <span class="hljs-built_in">Attach</span>(P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>    <span class="hljs-keyword">for</span> ( ; P2; P2 = P2-&gt;link ) <span class="hljs-built_in">Attach</span>(P2-&gt;coef, P2-&gt;expon, &amp;rear);<br>    rear-&gt;link = <span class="hljs-literal">NULL</span>; <br>    temp = front;<br>    front = front-&gt;link; <span class="hljs-comment">/*令front指向结果多项式第一个非零项 */</span><br>    <span class="hljs-built_in">free</span>(temp); <span class="hljs-comment">/* 释放临时空表头结点 */</span><br>    <span class="hljs-keyword">return</span> front;<br></code></pre></div></td></tr></table></figure>
<h2 id="第三讲-树（上）"><a href="#第三讲-树（上）" class="headerlink" title="第三讲 树（上）"></a>第三讲 树（上）</h2><h3 id="树与树的表示"><a href="#树与树的表示" class="headerlink" title="树与树的表示"></a>树与树的表示</h3><p>为什么要用树？<br><br>因分层次的组织在管理上具有更高的效率。<br><br>用树可以实现有效率的查找</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>查找分为<strong>动态查找</strong>和<strong>静态查找</strong></p>
<ul>
<li>静态查找<ul>
<li>集合中记录是固定的</li>
<li>没有插入和删除操作</li>
<li>方法：<ul>
<li>顺序查找。按顺序查找，平均找n/2次，复杂度O(n)</li>
<li>二分查找。<ul>
<li>假设n个数据元素的关键字满足有序（比如：从小到大）并且是连续存放的（数组），那么可以进行二分查找</li>
<li>二分查找流程(假设数据从小到大排列)：<ul>
<li>设定初始左右边界(left,right)</li>
<li>迭代入口&gt;&gt;&gt;while(left&lt;=right)</li>
<li>计算中间坐标(mid)对应元素的值</li>
<li>若中间元素比给定值大，调整右边边界等于中间坐标-1，right=mid-1，并进行下一轮迭代</li>
<li>若中间元素比给定值小，调整左边边界等于中间坐标+left=mid+1，并进行下一轮迭代</li>
<li>若中间元素等于给定值，return中间元素的下标，寻找成功</li>
<li>&lt;&lt;&lt;若跳出while循环，代表左右边界错位，不存在待查早数据，return-1</li>
</ul>
</li>
<li>时间复杂度是O(logN)，事先进行有序化排序是效率提升的关键</li>
<li>实际上这种二分查找流程就构成了一个树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>动态查找<ul>
<li>集合中记录是动态变化的</li>
<li>除了查找还可能发现插入和删除</li>
</ul>
</li>
</ul>
<p>技巧：在边界设定“哨兵”（sentinel），这样可以规避edge case，避免进行麻烦的边界情况的判断。参考<a href="algorithmNotes.md">算法笔记</a>中的82. Remove Duplicates from Sorted List II</p>
<h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><p>树(Tree) :n (n $\geq$ 0)个结点构成的有限集合。<br><br>当n=0时，称为空树; <br><br>对于任一棵非空树(n&gt;0)，它具备以下性质:</p>
<ul>
<li>树中有一个称为“根(Root) ”的特殊结点，用r表示;</li>
<li>其余结点可分为m(m&gt;0)个<strong>互不相交</strong>的有限集T，T2, …，Tm，其中每个集合本身又是一棵树，称为原来树的“子树(SubTree)”。<br><br><strong>子树是不相交的</strong></li>
<li>除了根结点外，<strong>每个结点有且仅有一个父结点</strong>;一棵N个结点的树有N-1条边，因此<strong>树是保证链接数最小的结点连接方式</strong></li>
</ul>
<p>关于树的基本术语：</p>
<ul>
<li>结点的度(Degree)：结点的子树个数</li>
<li>树的度：树的所有结点中最大的度数</li>
<li>叶结点(Leaf)：度为0的结点</li>
<li>父结点(Parent)：有子树的结点是其子树的根结点的父结点</li>
<li>子结点(Child)：若A是B的父结点，则B是A的子结点</li>
<li>兄弟结点(Sibling)：具有同一父结点的各结点之间是兄弟结点</li>
<li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1,n2,…,nk, ni是ni+1的父结点。路径所包含边的个数为路径的长度。</li>
<li>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</li>
<li>子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。</li>
<li>结点的层次（Level）：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。</li>
<li>树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度</li>
</ul>
<h4 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h4><p>树难以用数组表示，也不太好用链表表示(每个Node结构不同，因为next指针域的数量不同)</p>
<p>可以使用儿子-兄弟表示法：<br>这样每一个链表结点的构造都是相同的。<br><br>这种树结构称为二叉树。</p>
<p><img src="/img/pics/child_sibling_1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="/img/pics/child_sibling_2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="二叉树及存储结构"><a href="#二叉树及存储结构" class="headerlink" title="二叉树及存储结构"></a>二叉树及存储结构</h3><h4 id="几种特殊二叉树"><a href="#几种特殊二叉树" class="headerlink" title="几种特殊二叉树"></a>几种特殊二叉树</h4><ol>
<li>斜二叉树(实际上就是链表)<br><img src="/img/pics/3.2_1.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>完美/满二叉树<br><img src="/img/pics/3.2_2.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li><strong>完全二叉树</strong><br>完全二叉树可以不是完美二叉树，可以缺结点，但是必须是按照一定规则（从上到下，从左到右）排序之后的尾端的连续结点序列。<br><br>比如，下面这个是完全二叉树：<br><br><img src="/img/pics/3.2_3.png" srcset="/img/loading.gif" lazyload alt=""><br>而下面这个不是：<br><br><img src="/img/pics/3.2_4.png" srcset="/img/loading.gif" lazyload alt=""><br>完全二叉树是很重要的一种树。</li>
</ol>
<h4 id="二叉树的重要性质"><a href="#二叉树的重要性质" class="headerlink" title="二叉树的重要性质"></a>二叉树的重要性质</h4><ul>
<li>一个二叉树第i层的最大结点数为：2<sup>i-1</sup>, i $\geq$ 1</li>
<li>深度为k的二叉树有最大结点总数为2<sup>k</sup>-1, k $\geq$ 1</li>
<li>对任何非空二叉树T，若n<sub>0</sub>表示叶结点的个数,n<sub>2</sub>是度为2的非叶结点个数，那么两者满足关系n<sub>0</sub>=n<sub>2</sub>+1。</li>
</ul>
<h4 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h4><p>对于完全二叉树（需按照上面的规则编号），可以用数组实现，而且非常方便：</p>
<ul>
<li>非根结点(序号i&gt;1)的父结点的序号是int(i/2)（向下取整—）;</li>
<li>结点(序号为i)的左孩子结点的序号是2i,(若2i&lt;=n，否则没有左孩子) ;</li>
<li>结点(序号为i )的右孩子结点的序号是2i+1,(若2i+1&lt;=n， 否则没有右孩子);<br>一般二叉树也可以这样处理，但是在没有值的位置需要把对应的位置空出来。这样会造成空间浪费</li>
</ul>
<h4 id="二叉树链式存储结构"><a href="#二叉树链式存储结构" class="headerlink" title="二叉树链式存储结构"></a>二叉树链式存储结构</h4><div class="table-container">
<table>
<thead>
<tr>
<th>Left</th>
<th>Data</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">BinTree</span>;</span><br><span class="hljs-keyword">typedef</span> BinTree Position;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    ElementType Data;<br>    BinTree Left;<br>    BinTree Right;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a><strong>二叉树的递归遍历</strong></h4><ol>
<li><p>先序遍历<br><img src="/img/pics/3.3_1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li>访问根结点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraversal</span><span class="hljs-params">(BinTree BT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(BT)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, BT-&gt;Data);<br>        <span class="hljs-built_in">PreOrderTraversal</span>(BT-&gt;Left);<br>        <span class="hljs-built_in">PreOrderTraversal</span>(BT-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>中序遍历<br><img src="/img/pics/3.3_2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li>中序遍历其左子树</li>
<li>访问根结点</li>
<li>中序遍历其右子树<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraversal</span><span class="hljs-params">(BinTree BT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(BT)&#123;<br>        <span class="hljs-built_in">InOrderTraversal</span>(BT-&gt;Left);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, BT-&gt;Data);<br>        <span class="hljs-built_in">InOrderTraversal</span>(BT-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ol>
</li>
<li>后序遍历<br><img src="/img/pics/3.3_3.png" srcset="/img/loading.gif" lazyload alt=""><ol>
<li>后序遍历其左子树</li>
<li>后序遍历其右子树</li>
<li>访问根结点<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraversal</span><span class="hljs-params">(BinTree BT)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(BT)&#123;<br>        <span class="hljs-built_in">PostOrderTraversal</span>(BT-&gt;Left);<br>        <span class="hljs-built_in">PostOrderTraversal</span>(BT-&gt;Right);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, BT-&gt;Data);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><strong>二叉树遍历的核心问题：二维结构的线性化</strong><br><img src="/img/pics/3.3_4.png" srcset="/img/loading.gif" lazyload alt=""><br>因此需要一个存储结构保存暂时不访问的结点（堆栈或者队列），否则扫描经过之后就无法访问了。</li>
</ol>
</li>
</ol>
<p>队列实现:遍历从根结点开始，首先将根结点入队，然后开始执行循环:1.结点出队、2.访问该结点、3.其左右儿子入队.</p>
<p>举例：对于下面的树：<br><img src="/img/pics/3.3_5.png" srcset="/img/loading.gif" lazyload alt=""><br><br>有：<br><br>| A    | out: <br><br>| B C  | out:A<br><br>| C D F | out:AB<br><br>| D F G I| out:ABC<br><br>| F G I E | out:ABCD<br><br>| G I E H | out:ABCDF<br><br>out: ABCDFGIEH<br></p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LevelOrderTraversal</span> <span class="hljs-params">( BinTree BT )</span></span><br><span class="hljs-function"></span>&#123; Queue Q; BinTree T;<br>    <span class="hljs-keyword">if</span> ( !BT ) <span class="hljs-keyword">return</span>; <span class="hljs-comment">/* 若是空树则直接返回 */</span><br>    Q = <span class="hljs-built_in">CreatQueue</span>( MaxSize ); <span class="hljs-comment">/*创建并初始化队列Q*/</span><br>    <span class="hljs-built_in">AddQ</span>( Q, BT );<br>    <span class="hljs-keyword">while</span> ( !<span class="hljs-built_in">IsEmptyQ</span>( Q ) ) &#123;<br>        T = <span class="hljs-built_in">DeleteQ</span>( Q );<br>        <span class="hljs-built_in">printf</span>(“%d\n”, T-&gt;Data); <span class="hljs-comment">/*访问取出队列的结点*/</span><br>        <span class="hljs-keyword">if</span> ( T-&gt;Left ) <span class="hljs-built_in">AddQ</span>( Q, T-&gt;Left );<br>        <span class="hljs-keyword">if</span> ( T-&gt;Right ) <span class="hljs-built_in">AddQ</span>( Q, T-&gt;Right );<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure></p>
<h4 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h4><ol>
<li>输出二叉树中的叶子结点<br>只需要在二叉树遍历算法中增加检测结点的“左右子树是都否为空”即可。<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderPrintLeaves</span><span class="hljs-params">( BinTree BT )</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span>( BT ) &#123;<br>         <span class="hljs-keyword">if</span> ( !BT-Left &amp;&amp; !BT-&gt;Right )<br>             <span class="hljs-built_in">printf</span>(“%d”, BT-&gt;Data );<br>         <span class="hljs-built_in">PreOrderPrintLeaves</span> ( BT-&gt;Left );<br>         <span class="hljs-built_in">PreOrderPrintLeaves</span> ( BT-&gt;Right );<br>     &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure></li>
<li>求二叉树的高度<br>假设左子树高度为HL，右子树高度为HR，则<br><br>Height=max(HL, HR)+1（根结点）<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">PostOrderGetHeight</span><span class="hljs-params">( BinTree BT )</span></span><br><span class="hljs-function"> </span>&#123;   <span class="hljs-keyword">int</span> HL, HR, MaxH;<br>     <span class="hljs-keyword">if</span>( BT ) &#123;<br>         HL = <span class="hljs-built_in">PostOrderGetHeight</span>(BT-&gt;Left); <span class="hljs-comment">/*求左子树的深度*/</span><br>         HR = <span class="hljs-built_in">PostOrderGetHeight</span>(BT-&gt;Right); <span class="hljs-comment">/*求右子树的深度*/</span><br>         MaxH = （HL &gt; HR）? HL : HR; <span class="hljs-comment">/*取左右子树较大的深度*/</span><br>         <span class="hljs-keyword">return</span> ( MaxH + <span class="hljs-number">1</span> ); <span class="hljs-comment">/*返回树的深度*/</span><br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 空树深度为0 */</span><br> &#125;<br></code></pre></div></td></tr></table></figure></li>
<li>通过中序遍历+前序/后序遍历，唯一确定一颗二叉树</li>
</ol>
<h4 id="判断树的同构"><a href="#判断树的同构" class="headerlink" title="判断树的同构"></a>判断树的同构</h4><p>运用链表的思想，构造结构数组来表示下面的树：<br><br><img src="/img/pics/3.3_6.png" srcset="/img/loading.gif" lazyload alt=""><br><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 来学习一下怎么构造结构数组吧！</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MaxTree 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ElementType char</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Tree int</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Null -1</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElementType Element;<br>    Tree Left;<br>    Tree Right;<br>&#125;T1[MaxTree], T2[MaxTree]<br></code></pre></div></td></tr></table></figure><br>需要完成：1.读入两个二叉树；2.二叉树同构判别<br><br>输入样例：<br><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment">### 输入样例:</span><br><span class="hljs-attribute">8</span><br><span class="hljs-attribute">A</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">C</span> <span class="hljs-number">5</span> -<br><span class="hljs-attribute">D</span> - -<br><span class="hljs-attribute">E</span> <span class="hljs-number">6</span> -<br><span class="hljs-attribute">G</span> <span class="hljs-number">7</span> -<br><span class="hljs-attribute">F</span> - -<br><span class="hljs-attribute">H</span> - -<br><span class="hljs-attribute">8</span><br><span class="hljs-attribute">G</span> - <span class="hljs-number">4</span><br><span class="hljs-attribute">B</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">F</span> - -<br><span class="hljs-attribute">A</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">H</span> - -<br><span class="hljs-attribute">C</span> <span class="hljs-number">0</span> -<br><span class="hljs-attribute">D</span> - -<br><span class="hljs-attribute">E</span> <span class="hljs-number">2</span> -<br></code></pre></div></td></tr></table></figure><br>结构：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree R1, R2;<br>    R1 = <span class="hljs-built_in">BuildTree</span>(T1); <span class="hljs-comment">// T1，T2就是上面的结构数组，返回的是根结点的index</span><br>    R2 = <span class="hljs-built_in">BuildTree</span>(T2);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Isomorphic</span>(R1,R2))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">BuildTree</span><span class="hljs-params">( struct TreeNode T[] )</span></span><br><span class="hljs-function"></span>&#123;...<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">if</span> (N) &#123;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) check[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %c %c\n&quot;</span>, &amp;T[i].Element, &amp;cl, &amp;cr);<br>            <span class="hljs-keyword">if</span> (cl != <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                T[i].Left = cl-<span class="hljs-string">&#x27;0&#x27;</span>;<br>                check[T[i].Left] = <span class="hljs-number">1</span>; <span class="hljs-comment">//原理是，如果一个元素没有指向被指向，则它就是根结点</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> T[i].Left = Null;<br>            ... <span class="hljs-comment">/*对cr的对应处理 */</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>            <span class="hljs-keyword">if</span> (!check[i]) <span class="hljs-keyword">break</span>;<br>        Root = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Root;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Isomorphic</span> <span class="hljs-params">( Tree R1, Tree R2 )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> ( (R1==Null )&amp;&amp; (R2==Null) ) <span class="hljs-comment">/* both empty */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> ( ((R1==Null)&amp;&amp;(R2!=Null)) || ((R1!=Null)&amp;&amp;(R2==Null)) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* one of them is empty */</span><br>    <span class="hljs-keyword">if</span> ( T1[R1].Element != T2[R2].Element )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* roots are different */</span><br>    <span class="hljs-keyword">if</span> ( ( T1[R1].Left == Null )&amp;&amp;( T2[R2].Left == Null ) )<br>        <span class="hljs-comment">/* both have no left subtree */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Isomorphic</span>( T1[R1].Right, T2[R2].Right );<br>    <span class="hljs-keyword">if</span> ( ((T1[R1].Left!=Null)&amp;&amp;(T2[R2].Left!=Null))&amp;&amp;<br>        ((T1[T1[R1].Left].Element)==(T2[T2[R2].Left].Element)) )<br>        <span class="hljs-comment">/* no need to swap the left and the right */</span><br>        <span class="hljs-keyword">return</span> ( <span class="hljs-built_in">Isomorphic</span>( T1[R1].Left, T2[R2].Left ) &amp;&amp;<br>        <span class="hljs-built_in">Isomorphic</span>( T1[R1].Right, T2[R2].Right ) );<br><br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* need to swap the left and the right */</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> ( <span class="hljs-built_in">Isomorphic</span>( T1[R1].Left, T2[R2].Right) &amp;&amp;<br>        <span class="hljs-built_in">Isomorphic</span>( T1[R1].Right, T2[R2].Left ) );<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h2 id="第四讲-树（中）"><a href="#第四讲-树（中）" class="headerlink" title="第四讲 树（中）"></a>第四讲 树（中）</h2><h3 id="二叉搜索树-BST-Binary-Search-Tree"><a href="#二叉搜索树-BST-Binary-Search-Tree" class="headerlink" title="二叉搜索树(BST, Binary Search Tree)"></a>二叉搜索树(BST, Binary Search Tree)</h3><p><strong>也成为二叉排序树和二叉查找树</strong></p>
<p>满足以下性质：</p>
<ol>
<li>非空左子树的所有键值小于其根结点的键值 （运用二分查找的思想，需要先排序）</li>
<li>非空右子树的所有键值大于于其根结点的键值</li>
<li>左、右子树都是二叉搜索树</li>
</ol>
<p><img src="/img/pics/4.1_1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="查找操作：Find"><a href="#查找操作：Find" class="headerlink" title="查找操作：Find"></a>查找操作：Find</h4><ul>
<li>查找从根结点开始，如果树为空，返回NULL</li>
<li>若搜索树非空，则根结点关键字和X进行比较，并进行不同处理:<ul>
<li>若X小于根结点键值，只需在左子树中继续搜索;</li>
<li>如果X大于根结点的键值，在右子树中进行继续搜索;</li>
<li>若两者比较结果是相等，搜索完成，返回指向此结点的指针。<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-number">1.</span>使用尾递归的方法：<br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">(ElementType X, BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//failure</span><br>    <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, BST-&gt;Right); <span class="hljs-comment">//在右子树中继续查找</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Find</span>(X, BST-&gt;Left);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-comment">//X == Bst-&gt;Data&#123;</span><br>        <span class="hljs-keyword">return</span> BST; <span class="hljs-comment">//查找成功，返回找到的结点的位置</span><br>    &#125;<br>&#125;<br><br><span class="hljs-number">2.</span>使用迭代循环的方法（推荐）：<br><span class="hljs-function">Position <span class="hljs-title">IterFind</span><span class="hljs-params">(ElementType X, BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(BST)&#123;<br>        <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)&#123;<br>            BST = BST-&gt;Right; <span class="hljs-comment">//向右移动</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)&#123;<br>            BST = BST-&gt;Left; <span class="hljs-comment">//向左移动</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> BST；<br>        &#125;<br>    &#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>若树往一边倒，比如全都只有左儿子，或者都只有右儿子，那算法效率就很低，达不到二分的log2n。因此需要平衡二叉树</li>
</ul>
</li>
</ul>
<h4 id="查找最值操作：FindMin，FindMax2"><a href="#查找最值操作：FindMin，FindMax2" class="headerlink" title="查找最值操作：FindMin，FindMax2"></a>查找最值操作：FindMin，FindMax2</h4><p>FindMin:最小值肯定在最左边<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Position <span class="hljs-title">FindMin</span><span class="hljs-params">(BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 递归方法</span><br>    <span class="hljs-keyword">if</span>(!BST)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!BST-&gt;Left)<br>        <span class="hljs-keyword">return</span> BST; <span class="hljs-comment">//找到最左边结点并返回</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">FindMin</span>(BST-&gt;Left);<br>&#125;<br></code></pre></div></td></tr></table></figure><br>FindMin:最大值肯定在最右边<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Position <span class="hljs-title">FindMax</span><span class="hljs-params">(BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 迭代方法</span><br>    <span class="hljs-keyword">if</span>(BST)&#123;<br>        <span class="hljs-keyword">while</span>(BST-&gt;Right)&#123;<br>            BST = BST-&gt;Right;<br>        &#125;<br>    &#125;<span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>找到一个数的排序位置，并将其作为叶结点插入<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">BinTree <span class="hljs-title">Insert</span><span class="hljs-params">(ElementType X, BinTree BST)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!BST)&#123;<br>        <span class="hljs-comment">// 若原树为空，则生成并返回一个结点的二叉搜索树</span><br>        BST = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct TreeNode))<br>        BST-&gt;Data = X;<br>        BST-&gt;Left = BST-&gt;Right = <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//开始找插入的位置</span><br>        <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data)<br>            BST-&gt;Left = <span class="hljs-built_in">Insert</span>(X, BST-&gt;Left);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>            BST-&gt;Right = <span class="hljs-built_in">Insert</span>(X,BST-&gt;Right);<br>    &#125;<span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>三种情况：</p>
<ol>
<li>要删除的是叶结点：直接删除，再修改其父结点指针为NULL</li>
<li>要删除的结点<strong>只有一个孩子结点</strong>：将其父结点的指针指向要删除结点的孩子结点即可，也就是直接把删除结点的子结点挂在删除结点的父结点的对应位置</li>
<li>要删除的结点有左、右、两棵子树：用另一结点替代被删除结点—右子树的最小元素，或者左子树的最大元素（因为左子树的最大值和右子树的最小值一定不会有两个儿子，这样只需参照1和2修改即可）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">BinTree <span class="hljs-title">Delete</span><span class="hljs-params">( BinTree BST, ElementType X )</span> </span><br><span class="hljs-function"></span>&#123; <br>    Position Tmp; <br><br>    <span class="hljs-keyword">if</span>( !BST ) <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>); <br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>( X &lt; BST-&gt;Data ) <br>            BST-&gt;Left = <span class="hljs-built_in">Delete</span>( BST-&gt;Left, X );   <span class="hljs-comment">/* 从左子树递归删除 */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data ) <br>            BST-&gt;Right = <span class="hljs-built_in">Delete</span>( BST-&gt;Right, X ); <span class="hljs-comment">/* 从右子树递归删除 */</span><br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* BST就是要删除的结点 */</span><br>            <span class="hljs-comment">/* 如果被删除结点有左右两个子结点 */</span> <br>            <span class="hljs-keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;<br>                <span class="hljs-comment">/* 从右子树中找最小的元素填充删除结点，也可以左子树找最大元素 */</span><br>                Tmp = <span class="hljs-built_in">FindMin</span>( BST-&gt;Right );<br>                BST-&gt;Data = Tmp-&gt;Data; <span class="hljs-comment">//用右子树中最小元素替换被删除结点</span><br>                <span class="hljs-comment">/* 从右子树中删除最小元素 */</span><br>                BST-&gt;Right = <span class="hljs-built_in">Delete</span>( BST-&gt;Right, BST-&gt;Data );<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 被删除结点有一个或无子结点 */</span><br>                Tmp = BST; <br>                <span class="hljs-keyword">if</span>( !BST-&gt;Left )       <span class="hljs-comment">/* 只有右孩子或无子结点 */</span><br>                    BST = BST-&gt;Right;  <span class="hljs-comment">//把当前结点的下一个结点桥接上来，等于删除当前结点 </span><br>                <span class="hljs-keyword">else</span>                   <span class="hljs-comment">/* 只有左孩子 */</span><br>                    BST = BST-&gt;Left;<br>                <span class="hljs-built_in">free</span>( Tmp );<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>搜索树结点不同的插入次序，将导致不同的<strong>深度</strong>和<strong>平均查找长度</strong>ASL</p>
<p>平衡因子（BF）：左子树和右子树的高度差<br><br>BF(T) = h<sub>L</sub> - h<sub>R</sub></p>
<p>平衡二叉树(Balanced Binary Tree), 或AVL树（AVL是提出的科学家的名字缩写）：<br></p>
<ul>
<li>空树，或者;</li>
<li><strong>任 一 结 点</strong>左、右子树的高度差绝对值不超过1，即|BF(T)| $\leq$  1<br><br><img src="/img/pics/4.2_1.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>给定结点数为n的AVL树的最大高度为O(log<sub>2</sub>n)</li>
</ul>
<h4 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h4><p>分为四种情况</p>
<ol>
<li>RR插入，RR旋转<br><img src="/img/pics/4.2_2.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>LL插入，LL选择<br><img src="/img/pics/4.2_3.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>LR插入，LR选择<br><img src="/img/pics/4.2_4.png" srcset="/img/loading.gif" lazyload alt=""></li>
<li>RL插入，RL旋转<br><img src="/img/pics/4.2_5.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ol>
<h4 id="如何判断是同一颗二叉搜索树"><a href="#如何判断是同一颗二叉搜索树" class="headerlink" title="如何判断是同一颗二叉搜索树"></a>如何判断是同一颗二叉搜索树</h4><p>给定一个插入序列就可以唯一确定一棵二叉搜索树，但反之则不然。<br><br>尝试根据输入的队列来确定是否能生成一样的二叉搜索树</p>
<ol>
<li>搜索树的表示<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">Tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> v;<br>    Tree Left, Right;<br>    <span class="hljs-keyword">int</span> flag; <span class="hljs-comment">// 用来记录结点是否有被遍历到</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>程序主要框架：<ol>
<li>读入N和L</li>
<li>根据第一个序列建树T</li>
<li>判别之后的L个序列是否能形成和T一样的树，并返回结果<br><br>构建部分：<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> N,L,i;<br>    Tree T;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">while</span>(N)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;L);<br>        T = <span class="hljs-built_in">MakeTree</span>(N);<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;L;i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Judge</span>(T,N)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>            <span class="hljs-built_in">ResetT</span>(T);<br>        &#125;<br>        <span class="hljs-built_in">FreeTree</span>(T);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">MakeTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree T;<br>    <span class="hljs-keyword">int</span> i, V;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V);<br>    T = <span class="hljs-built_in">NewNode</span>(V);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;N;i++&gt;)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V);<br>        T = <span class="hljs-built_in">Insert</span>(T,V);<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">NewNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree T = (Tree)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct TreeNode));<br>    T-&gt;v = T;<br>    T-&gt;Left = T-&gt;Right = <span class="hljs-literal">NULL</span>;<br>    T-&gt;frag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-function">Tree <span class="hljs-title">Insert</span><span class="hljs-params">(Tree T, <span class="hljs-keyword">int</span> V)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!T)<br>         T = <span class="hljs-built_in">NewNode</span>(V);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(V&gt;T-&gt;v)<br>             T-&gt;Right = <span class="hljs-built_in">Insert</span>(T-&gt;Right, V);<br>        <span class="hljs-keyword">else</span><br>             T-&gt;Left = <span class="hljs-built_in">Insert</span>(T-&gt;Left, V);<br>     &#125;<br>     <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ol>
</li>
<li><strong>判别方法</strong><ul>
<li>在构建好的树T中按顺序搜索序列3 2 4 1中的每一个数：</li>
<li><strong>如果每次搜索所经过的结点在前面均出现过</strong>，则一致；</li>
<li>否则（某次搜索中遇到未经过，即flag=0的结点），则不一致<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(Tree T, <span class="hljs-keyword">int</span> V)</span> <span class="hljs-comment">// 单个元素的判别</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;flag)&#123; <span class="hljs-comment">// 目前遍历到的结点是之前有标记的，继续迭代</span><br>        <span class="hljs-keyword">if</span>(V &lt; T-&gt;v)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(T-&gt;Left, V);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(V &gt; T-&gt;v)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(T-&gt;Right, V);<br>        &#125;<span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-keyword">if</span>(V == T-&gt;v)&#123; <span class="hljs-comment">// 碰到了新结点，康康值是否相等呢？</span><br>            T-&gt;flag = <span class="hljs-number">1</span>; <span class="hljs-comment">// 是正确的结点，把他标记一下就return</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 碰到了未经过的结点，判断出来不是同一棵树</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Judge</span><span class="hljs-params">(Tree, <span class="hljs-keyword">int</span> N)</span> <span class="hljs-comment">// 循环调用check来判断整个序列</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i, V, flag = <span class="hljs-number">0</span>; <span class="hljs-comment">// flag=1:代表(可能序列还没检查完就已经)碰到不一致了</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>    <span class="hljs-keyword">if</span>( V!=T-&gt;v) flag=<span class="hljs-number">1</span>; <span class="hljs-comment">// 根节点就不同了</span><br>    <span class="hljs-keyword">else</span> T-&gt;flag = <span class="hljs-number">1</span> <span class="hljs-comment">// 注意区分flag和T的flag！</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;N;i++）&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>        <span class="hljs-keyword">if</span>((!flag)&amp;&amp;(!<span class="hljs-built_in">check</span>(T,V))) flag=<span class="hljs-number">1</span>; <span class="hljs-comment">// 如果check返回0，则flag=1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>( flag ) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">ResetT</span>(Tree T)<br>&#123;<br>    <span class="hljs-keyword">if</span> (T-&gt;Left) <span class="hljs-built_in">Reset</span>(T-&gt;Left);<br>    <span class="hljs-keyword">if</span> (T-&gt;Right) <span class="hljs-built_in">Reset</span>(T-&gt;Right);<br>    T-&gt;falg = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">FreeTree</span>(Tree T)<br>&#123;<br>    <span class="hljs-keyword">if</span>(T-&gt;Left) <span class="hljs-built_in">FreeTree</span>(T-&gt;Left);<br>    <span class="hljs-keyword">if</span>(T-&gt;Right) <span class="hljs-built_in">FreeTree</span>(T-&gt;Right;<br>    <span class="hljs-built_in">free</span>(T))<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="（补充）红黑树"><a href="#（补充）红黑树" class="headerlink" title="（补充）红黑树"></a>（补充）红黑树</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143396578">https://zhuanlan.zhihu.com/p/143396578</a></p>
<p>为了解决二叉树多次插入结点后可能产生的不平衡现象，提出了红黑树。<br><br>那么红黑树和平衡二叉树(AVL树)有什么区别呢？</p>
<ul>
<li>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</li>
<li>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</li>
</ul>
<h4 id="红黑树的具体概念"><a href="#红黑树的具体概念" class="headerlink" title="红黑树的具体概念"></a>红黑树的具体概念</h4><p><strong>红黑树是一种自平衡的二叉查找树，它具有以下特点：</strong></p>
<ol>
<li><strong>结点是红色或黑色。</strong></li>
<li><strong>根结点是黑色。</strong></li>
<li><strong>每个叶子结点都是黑色的空结点（NIL结点）。</strong></li>
<li><strong>每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</strong></li>
<li><strong>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</strong><br><img src="/img/pics/BRT-1.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ol>
<ul>
<li>因为这五条规则的限制，红黑树能够保证自平衡，且<strong>从根到叶子的最长路径不会超过最短路径的2倍。</strong></li>
<li>而ALVL树是严格平衡的二叉树，要求<strong>每个节点的左右子树高度差不超过1</strong></li>
<li>AVL树查找效率更高，需要频繁查找时，可以选用AVL树</li>
<li>频繁插入删除时，则可以使用红黑树</li>
</ul>
<p>比如，这种情况插入之后就还是正常的：<br><img src="/img/pics/BRT-2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>但是这种就需要做出调整了：<br><img src="/img/pics/BRT-3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>调整的方法：</p>
<ol>
<li>变色</li>
<li>旋转<ol>
<li>左旋</li>
<li>右旋</li>
</ol>
</li>
</ol>
<h5 id="1-变色"><a href="#1-变色" class="headerlink" title="1. 变色"></a>1. 变色</h5><p><img src="/img/pics/BRT-4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>但是凭空多出来一个黑色节点会打破规则5，因此需要进一步的调整。</p>
<h5 id="2-1-左旋"><a href="#2-1-左旋" class="headerlink" title="2.1. 左旋"></a>2.1. 左旋</h5><p>父节点下沉，右孩子上浮，父节点的链接转移给右孩子；他们三的子节点继续按原顺序依次排列：<br><img src="/img/pics/BRT-5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h5 id="2-2-右旋"><a href="#2-2-右旋" class="headerlink" title="2.2. 右旋"></a>2.2. 右旋</h5><p>也是同样地，父节点下沉，左孩子上浮，父节点的链接转移给右左孩子；他们三的子节点继续按原顺序依次排列：</p>
<p>就像下象棋一样，不同的局面对应着不同的搞法。而对于插入新结点来说，又可以归结为5种不同局面：</p>
<h5 id="局面1：新结点（A）位于树根，没有父结点。"><a href="#局面1：新结点（A）位于树根，没有父结点。" class="headerlink" title="局面1：新结点（A）位于树根，没有父结点。"></a>局面1：新结点（A）位于树根，没有父结点。</h5><p><img src="/img/pics/BRT-6.png" srcset="/img/loading.gif" lazyload alt=""><br>直接让新节点变成黑色即可，能够满足5条规则。</p>
<h5 id="局面2：新结点（B）的父结点是黑色。"><a href="#局面2：新结点（B）的父结点是黑色。" class="headerlink" title="局面2：新结点（B）的父结点是黑色。"></a>局面2：新结点（B）的父结点是黑色。</h5><p><img src="/img/pics/BRT-7.png" srcset="/img/loading.gif" lazyload alt=""><br>此时插入没有打破任何规则，不用做任何调整</p>
<h5 id="局面3：新结点（D）的父结点和叔叔结点都是红色。"><a href="#局面3：新结点（D）的父结点和叔叔结点都是红色。" class="headerlink" title="局面3：新结点（D）的父结点和叔叔结点都是红色。"></a>局面3：新结点（D）的父结点和叔叔结点都是红色。</h5><p><img src="/img/pics/BRT-8.png" srcset="/img/loading.gif" lazyload alt=""><br>这种局面，两个红色结点B和D连续，违反了规则4。因此我们先让结点B变为黑色；但这样一来，结点B所在路径凭空多了一个黑色结点，打破了规则5。因此我们让结点A变为红色：<br><img src="/img/pics/BRT-9.png" srcset="/img/loading.gif" lazyload alt=""><br>这时候，结点A和C又成为了连续的红色结点，我们再让结点C变为黑色：<br><img src="/img/pics/BRT-10.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>即可。</p>
<h5 id="局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"><a href="#局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。"></a>局面4：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的右孩子，父结点（B）是祖父结点的左孩子。</h5><p><img src="/img/pics/BRT-11.png" srcset="/img/loading.gif" lazyload alt=""><br>做一次左旋，进入局面5.</p>
<h5 id="局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"><a href="#局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。" class="headerlink" title="局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。"></a>局面5：新结点（D）的父结点是红色，叔叔结点是黑色或者没有叔叔，且新结点是父结点的左孩子，父结点（B）是祖父结点的左孩子。</h5><p>我们以结点A为轴，做一次右旋转，使得结点B成为祖父结点，结点A成为结点B的右孩子：<br><img src="/img/pics/BRT-12.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>接下来，我们让结点B变为黑色，结点A变为红色：<br><img src="/img/pics/BRT-13.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>即可。</p>
<p>如果局面4中的父结点B是右孩子，则成为了局面5的镜像，原本的右旋操作改为左旋；如果局面5中的父结点B是右孩子，则成为了局面4的镜像，原本的左旋操作改为右旋。</p>
<p>对于删除，也有三种不同的局面，这里就不再赘述</p>
<h2 id="第五讲-树（下）"><a href="#第五讲-树（下）" class="headerlink" title="第五讲 树（下）"></a>第五讲 树（下）</h2><h3 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h3><h4 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h4><p><strong>优先队列(Priority Queue)</strong>: 特殊的“队列”，取出元素的顺序是依照元素的<strong>优先权（关键字）</strong>大小，而不是元素进入队列的先后顺序.</p>
<p>采用数组或链表实现优先队列，则他们的复杂度：</p>
<ul>
<li>数组<ul>
<li>插入：元素总是插在尾部 — O(1)</li>
<li>删除：<ul>
<li>先找到最大、最小的关键字 — O(n)</li>
<li>数组删除还需要移动逐个元素 — O(n)</li>
</ul>
</li>
</ul>
</li>
<li>链表<ul>
<li>插入：元素总是插在链表头部 — O(1)</li>
<li>删除：<ul>
<li>先找到最大、最小的关键字 — O(n)</li>
<li>链表删去结点不需逐个移动 — O(1)</li>
</ul>
</li>
</ul>
</li>
<li>有序数组<ul>
<li>插入：<ul>
<li>找到合适的位置 — O(n)或者O(log2n) (二分法？)</li>
<li>移动元素并插入 — O(n)</li>
</ul>
</li>
<li>删除：删去最后一个元素 — O(1)</li>
</ul>
</li>
<li>有序链表<ul>
<li>插入：<ul>
<li>找到合适位置 — O(n)<ul>
<li>插入元素 — O(1)</li>
</ul>
</li>
<li>删除：首个元素或最后的元素 — O(1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>尝试使用二叉树来存储？</p>
<p>由于删除比插入更加复杂，因此可以把最大值放在树根，并且使得其他的根节点都是相对的子节点的最大值，并使用完全二叉树来构造，这样就构成了堆。<br><br>堆的两个特性：</p>
<ul>
<li>结构性：用数组表示的完全二叉树</li>
<li>有序性：任一结点的关键字是其子树所有节点的最大值或最小值<ul>
<li>“最大堆（MaxHeap）”也成为“大顶堆”</li>
<li>“最小堆（MinHeap）”也成为“小顶堆”</li>
</ul>
</li>
</ul>
<p>堆的有序性在于它从上到下的任何一条路径都是单调的。</p>
<p><img src="/img/pics/5.1_1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="最大堆的实现"><a href="#最大堆的实现" class="headerlink" title="最大堆的实现"></a>最大堆的实现</h4><ol>
<li>最大堆的定义<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapStruct</span> *<span class="hljs-title">MaxHeap</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeadStruct</span>&#123;</span><br>    ElementType *Elements;<br>    <span class="hljs-keyword">int</span> Size;<br>    <span class="hljs-keyword">int</span> Capacity;<br>&#125;;<br><br><span class="hljs-function">MaxHeap <span class="hljs-title">Create</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> MaxSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    MaxHeap H = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct HeapStruct));<br>    H-&gt;Elements = <span class="hljs-built_in">malloc</span>((MaxSize+<span class="hljs-number">1</span>) * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(ElementType)); <span class="hljs-comment">//这里+1是因为下标为0处并不用来存放数据</span><br>    H-&gt;Size = <span class="hljs-number">0</span>;<br>    H-&gt;Capacity = MaxSize;<br>    H-&gt;Elements[<span class="hljs-number">0</span>] = MaxData; <span class="hljs-comment">// 定义‘哨兵’为大于堆中所有可能元素的值，便于以后更快操作。</span><br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li>最大堆的插入</li>
</ol>
<p>假设需要在[6]的位置上插入一个新节点，根据最大堆的性质进行判断：若该结点值比它的上一个结点大，则他们需要交换，在这里58&gt;31，交换一次；58&gt;44，再交换一次，最后新插入的58被交换到了[1]的位置。</p>
<p><img src="/img/pics/5.1_2.png" srcset="/img/loading.gif" lazyload alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(MaxHeap H, ElementType item)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">// O(logN)</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">IsFull</span>(H))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Heap is Full&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    i = ++ H-&gt;Size; <span class="hljs-comment">// i指向插入后堆中最后一个元素的位置</span><br>    <span class="hljs-keyword">for</span>(; H-&gt;Elements[i/<span class="hljs-number">2</span>]&lt;item ; i/=<span class="hljs-number">2</span> )&#123;<br>        H -&gt; Elements[i] = H -&gt; Elements[i/<span class="hljs-number">2</span>]; <span class="hljs-comment">//路径上碰到更小的元素将其逐个下移一位（如果item更大的话）</span><br>    &#125;<br>    H -&gt; Elements[i] = item; <span class="hljs-comment">// item 插入移位后上面空出来的位置</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    注意，如果比到树的第一个元素</span><br><span class="hljs-comment">    （比如说：将25 插入 1000[0,哨兵]-&gt;20[1]-&gt;15[2]-&gt;12[3]-&gt;2[4] 这棵树,)</span><br><span class="hljs-comment">    在0位置设定一个很大的数作为正式数据之外的哨兵，保证其比插入的元素大，这样可以保证插入的这个25不会越界，巧妙地规避edge case。</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<ol>
<li>最大堆的删除</li>
</ol>
<p><img src="/img/pics/5.1_3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>假设要删除58(最大值，在根的位置)：</p>
<ul>
<li>先把31移动到根的位置</li>
<li>然后找到31 的较大的孩子，交换位置</li>
<li>然后再往下迭代，交换位置</li>
</ul>
<p><img src="/img/pics/5.1_4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">DeleteMax</span><span class="hljs-params">(MaxHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//从最大堆H中取出键值最大的元素，并删除一个结点</span><br>    <span class="hljs-keyword">int</span> Parent, Child;<br>    ElementType MaxIten, temp;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(H))&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;MaxHeap is empty&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    MaxItem = H-&gt;ELements[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 取出根节点最大值</span><br>    <span class="hljs-comment">// 然后，用最大堆中的最后一个元素从根节点开始向上过滤下层结点，也就是逐个比较，移位。</span><br>    temp = H-&gt;Elements[H-&gt;Size--] <span class="hljs-comment">// 取出H的最后一个元素（要删除的），暂时储存，再让Size-1</span><br>    <span class="hljs-keyword">for</span>(Parent=<span class="hljs-number">1</span>; Parent*<span class="hljs-number">2</span> &lt;= H-&gt;Size; Parent = Child)&#123;<br>        Child = Parent*<span class="hljs-number">2</span>; <span class="hljs-comment">//子节点位置,注意，父节点的两个子节点:i*2 and i*2+1</span><br>        <span class="hljs-keyword">if</span>( (Child != H-&gt;Size) &amp;&amp; (H-&gt;Element[Child] &lt; H-&gt;Elements[Child+<span class="hljs-number">1</span>]) )&#123;<br>            Child +=<span class="hljs-number">1</span>; <span class="hljs-comment">//指向两个孩子中的较大者</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp &gt;= H-&gt;Elements[Child]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 移位完成</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            H -&gt; Elements[Parents] = H-&gt;Elements[Child] <span class="hljs-comment">//更大的子节点上移</span><br>        &#125;<br>    &#125;<br>    H -&gt; Elements[Parent] = temp;<br>    <span class="hljs-keyword">return</span> MaxItem;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>最大堆的建立</li>
</ol>
<p>建立最大堆是指将<strong>给定的N个元素</strong>按照最大堆的要求存放在一个一维数组中。</p>
<ul>
<li>方法一：通过插入操作一个一个插入到初始为空的堆中去 — O(nlongn)</li>
<li>方法二：在线性时间复杂度下建立最大堆：<ul>
<li>先将N个元素按顺序存入，先满足完全二叉树的结构特性</li>
<li>再调节各节点的位置，以满足最大堆的有序特性</li>
</ul>
</li>
</ul>
<p>方法二的具体逻辑：<br><br>在堆删除中，根节点的底下是两个最大堆，以此类推，往下每个结点的两边都是最大堆<br><br>如果将其反过来，从最底层起，不断往上迭代地构筑最大堆，到根节点就是一个完整的最大堆了。</p>
<h3 id="哈夫曼树与哈夫曼编码-Huffman"><a href="#哈夫曼树与哈夫曼编码-Huffman" class="headerlink" title="哈夫曼树与哈夫曼编码 Huffman"></a>哈夫曼树与哈夫曼编码 Huffman</h3><p>根据数据出现的频率来建立更具效率的匹配<br><br>比如将100分制转化为5分制，可以score&lt;60 ==grade 1; 60&lt;=score&lt;70 ==grade 2,以此类推，这样会形成如下一颗判定树：</p>
<p><img src="/img/pics/5.2_1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>可以通过不同的方法构造搜索树，但不同搜索树的搜索效率又是不一样的（比如把频率最大的元素放在根节点）</p>
<h4 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h4><p><strong>带权路径长度(WPL)</strong>：设二叉树有n个叶子结点，每个叶子结点带有权值W<sub>k</sub>,从根结点到每个叶子结点的长度为l<sub>k</sub>，则每个叶子结点的带权路径长度之和就是:</p>
<script type="math/tex; mode=display">\Sigma_{k=1}^{n} w_kl_k</script><p><strong>最优二叉树/哈夫曼树</strong>：WPL最小的二叉树</p>
<p>例如下面的二叉树：<br><img src="/img/pics/5.2_2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>WPL = 5x1+4x2+3x3+2x4+1x4 = 34</p>
<p>而下面这棵树：<br><img src="/img/pics/5.2_3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>WPL = 1x3+2x3+3x2+4x2+5x2 = 33</p>
<h4 id="如何构造哈夫曼树"><a href="#如何构造哈夫曼树" class="headerlink" title="如何构造哈夫曼树"></a>如何构造哈夫曼树</h4><p>每次把<strong>权值最小的两棵树合并</strong>即可。（可以利用最小堆）<br><img src="/img/pics/5.2_4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">HuffmanTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Weight;<br>    HuffmanTree Left, Right;<br>&#125;<br><br><span class="hljs-function">HuffmanTree <span class="hljs-title">Huffman</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">O</span>(NlogN)<br>    <span class="hljs-keyword">int</span> i; HuffmanTree T;<br>    <span class="hljs-built_in">BuildMinHeap</span>(H); <span class="hljs-comment">//将 H-&gt;Element[]按权值调整为最小堆</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i; i&lt; H-&gt;Size; i++)&#123; <span class="hljs-comment">//做H.Size - 1次的合并</span><br>        T = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct TreeNode));<br>        T-&gt;Left = <span class="hljs-built_in">DeletMin</span>(H); <span class="hljs-comment">// 从最小堆中删除一个结点，作为新T的左子节点</span><br>        T-&gt;Right = <span class="hljs-built_in">DeletMin</span>(H); <span class="hljs-comment">// 从最小堆中删除一个结点，作为新T的右子节点</span><br>        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;<br><br>        <span class="hljs-built_in">Insert</span>(H,T);<br>    &#125;<br>    T = <span class="hljs-built_in">DeletMin</span>(H);<br>    <span class="hljs-keyword">return</span> T; <span class="hljs-comment">//返回的是合并之后的树根</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h4><ul>
<li><strong>没有度为1的结点</strong></li>
<li>n个叶子节点的哈夫曼树共有2n-1个结点</li>
<li>哈夫曼树的任意<strong>非叶节点的左右子树交换后仍是哈夫曼树</strong>;</li>
<li>对同一组权值{W<sub>1</sub>,…..,w<sub>n</sub>},存在不同构的两棵哈夫曼树</li>
</ul>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>给定一段字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最少?<br><br>进行不等长编码，并避免其二义性。</p>
<p>前缀码(prefixcode):任何字符的编码都不是另一字符编码的前缀</p>
<ul>
<li>可以无二义地解码</li>
</ul>
<p>通过二叉树进行编码：<br>下图是两种二叉树的编码方式，第一种四个元素分别对应00，01，10，11，由于每个元素不是另外一个元素的前缀，因此没有二义性。但是第二个编码方式出现了某个元素在其他元素前面的情况，这就会产生二义性。<br><br>因此，需要产生一棵二叉树，使得每个元素都在叶节点上，保证其不会出现前缀的情况。<br></p>
<p><img src="/img/pics/5.2_5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>生成一棵正常的二叉树之后，如果要让编码效率最高，实际上就等同于生成一颗哈夫曼树，而每条路径就代表它的编码。</p>
<p><img src="/img/pics/5.2_6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="/img/pics/5.2_7.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="如何构造一个哈夫曼编码树"><a href="#如何构造一个哈夫曼编码树" class="headerlink" title="如何构造一个哈夫曼编码树"></a>如何构造一个哈夫曼编码树</h4><p>比如，要根据如下的字母和出现频数来构造一个最优的哈夫曼编码：<br>| a | e | i | s | t | sp | nl |<br>| - | - | - | - | - | - | - |<br>| 10|15 |12 |3 |4 |13 |1|</p>
<p>过程：不断找最小的来合并结点即可。</p>
<p><img src="/img/pics/5.2_8.png" srcset="/img/loading.gif" lazyload alt=""><br><img src="/img/pics/5.2_9.png" srcset="/img/loading.gif" lazyload alt=""><br><img src="/img/pics/5.2_10.png" srcset="/img/loading.gif" lazyload alt=""><br><img src="/img/pics/5.2_11.png" srcset="/img/loading.gif" lazyload alt=""><br><img src="/img/pics/5.2_12.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>最后得到：</p>
<p><img src="/img/pics/5.2_13.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="集合及运算，并查集"><a href="#集合及运算，并查集" class="headerlink" title="集合及运算，并查集"></a>集合及运算，<strong>并查集</strong></h3><p>并查集运用：File Transfer<br><br><a target="_blank" rel="noopener" href="https://www.icourse163.org/learn/ZJU-93001?tid=1464647442#/learn/content?type=detail&amp;id=1243232243&amp;cid=1266529407&amp;replay=true">https://www.icourse163.org/learn/ZJU-93001?tid=1464647442#/learn/content?type=detail&amp;id=1243232243&amp;cid=1266529407&amp;replay=true</a></p>
<h4 id="集合的表示"><a href="#集合的表示" class="headerlink" title="集合的表示"></a>集合的表示</h4><ul>
<li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li>
<li>并查集：集合并、查某元素属于什么集合</li>
<li>并查集问题中集合存储如何实现？</li>
</ul>
<p>可以通过<strong>树</strong>来表示，树的每个结点代表一个集合元素</p>
<p>假设有三个整数集合：<br><br>S1={1,2,4,7}<br><br>S2={3,5,8}<br><br>S3={6,9,10}<br><br>他们可以表示成：<br><img src="/img/pics/5.3.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>这样一棵树，可以使用链表存储，但是使用数组存储更好。<br><br>假设每个元素的类型描述为：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElementType Data;<br>    <span class="hljs-keyword">int</span> Parent;<br>&#125;SetType;<br></code></pre></div></td></tr></table></figure><br><img src="/img/pics/5.3.2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>如果没有父节点，则parent为-1，否则指向其父节点的下标</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>index</th>
<th>Data</th>
<th>Parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>-1</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>-1</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>8</td>
<td>9</td>
<td>5</td>
</tr>
<tr>
<td>9</td>
<td>10</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h4 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h4><ol>
<li>查找某个元素所在的集合(用根节点表示)<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(SetType S[], ElementType X)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在数组S中查找值为X的元素所属的集合</span><br>    <span class="hljs-comment">//MaxSize是全局变量，为S的最大长度</span><br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;MaxSize&amp;&amp;S[i].Data != X; i++&gt;); <span class="hljs-comment">//空转，直到找到X</span><br>    <span class="hljs-keyword">if</span>(i&gt;=NaxSize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//未找到，返回-1</span><br>    <span class="hljs-keyword">for</span>( ;S[i].Parent&gt;=<span class="hljs-number">0</span>;i=S[i].Parent); <span class="hljs-comment">//不断向上，直到找到根节点</span><br>    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回根节点在数组中的下标</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>集合的并操作<br>分别找到X1和X2两个元素所在集合树的根节点，如果他们不同根，则将其中一个根节点的父节点指针设置成另一个根节点的数组下标</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(SetType S[], ElementType X1, ElementType X2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> Root1, Root2;<br>    Root1 = <span class="hljs-built_in">Find</span>(S, X1);<br>    Root2 = <span class="hljs-built_in">Find</span>(S, X2);<br>    <span class="hljs-keyword">if</span>(Root1 != Root2)   S[Root2].Parent = Root1;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>为了改善合并以后的查找性能(防止树过高)，可使每一次合并都小的集合合并到大的集合中。但是要怎么表示每个集合中元素的个数（大小）呢？可以把根节点原来的Parent(-1)改成（负号+这个集合中元素的个数）</p>
<p><img src="/img/pics/5.3.4.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
</ol>
<h2 id="图（上）"><a href="#图（上）" class="headerlink" title="图（上）"></a>图（上）</h2><h3 id="什么是图"><a href="#什么是图" class="headerlink" title="什么是图"></a>什么是图</h3><p>图表示<strong>多对多</strong>的关系。因此，线性表和树都是图的一种特殊形式。<br><br>包含：</p>
<ul>
<li>一组顶点：用V(Vertex)表示顶点集合</li>
<li>一组边：用E(Edge)表示边的集合<ul>
<li>边是定点对：(v,w) $\in$ E，其中v，w $\in$ V</li>
<li>有向边<v,w>表示从v指向w的单向边</li>
<li>不考虑重边(两条互指的单向边)和自回路</li>
</ul>
</li>
</ul>
<h4 id="怎样表示一个图"><a href="#怎样表示一个图" class="headerlink" title="怎样表示一个图"></a>怎样表示一个图</h4><ol>
<li><p>可以用邻接矩阵 G[N][N]，其中：</p>
<script type="math/tex; mode=display">G[i][j]= \begin{cases}1 & \text { 若< } v_{i}, v_{j}>\text { 是G中的边 } \\ 0 & \text { 否则 }\end{cases}</script><p>它是对称矩阵，有一半空间是浪费的 <br><br>因此，将上面邻接矩阵压缩成一个长度为N(N+1)/2的一维数组A：{G<sub>00</sub>,G<sub>10</sub>,G<sub>11</sub>,…,G<sub>n-1 0</sub>,…,G<sub>n-1 n-1</sub>,}</p>
<p>则G<sub>ij</sub>在G中对应的下标为(i*(i+1)/2+j)</p>
<p>如果要构造一个网络，只要把G[i][j]的值定义为边<vi,vj>的权重即可</p>
<p>缺点：<br></p>
<ol>
<li>存稀疏图的时候很浪费空间</li>
<li>浪费时间：需要每一个元素都扫过去</li>
</ol>
</li>
<li><p>邻接表：G[N]为指针数组，对应的矩阵每行一个链表，只存储非0元素<br><br>无所谓顺序<br><img src="/img/pics/6.1.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>特点：</p>
<ol>
<li>方便找任意顶点的连接点</li>
<li>节约稀疏图的空间</li>
<li><strong>对于无向图</strong>，方便计算任意顶点的度</li>
<li>很难检测任意一对顶点之间是否存在边</li>
</ol>
</li>
</ol>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p><strong>深度优先搜索，Depth First Search, DFS</strong><br>一条路走到底，没路后<strong>原路返回</strong>，直到返回到这样一个岔路口（结点）：还有没被遍历的支路可以走。重复，指导最后原路返回至初始节点。</p>
<p>伪码描述：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span> <span class="hljs-params">(Vertex V)</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">//类似树的先序遍历</span><br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(V的每个邻接点W)<br>        <span class="hljs-keyword">if</span>(!visited)<br>            <span class="hljs-built_in">DFS</span>(W);<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<p>若有N个顶点、E条边，时间复杂度是（主要耗在对“V的每个邻接点W”进行扫描）:</p>
<ul>
<li>用邻接表存储图，有O(N+E) </li>
<li>用邻接矩阵存储图，有O(N<sup>2</sup>)</li>
</ul>
<p><strong>广度优先搜索，Breadth First Search, BFS</strong><br>类似树的层序遍历</p>
<p>伪码描述：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Vertex V)</span></span><br><span class="hljs-function"></span>&#123;<br>    visited[V] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">Enqueue</span>(V, Q);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br>        V = <span class="hljs-built_in">Dequeue</span>(Q);<br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>            <span class="hljs-keyword">if</span>(!visited[W])&#123;<br>                visited[W] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">Enqueue</span>(W, Q);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>时间复杂度(主要耗在对“V的每个邻接点W”进行扫描)：</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li><p>用邻接矩阵存储图，有O(N<sup>2</sup>)</p>
<h4 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h4></li>
<li><p>连通:如果从v到w存在一条(无向)路径,则称v和w是连通的。</p>
</li>
<li>路径：V到W的路径是一系列顶点{V, v1, v2, …, vn, W}的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数（如果带权，则是所有边的权重和）。如果V到W之间的所有顶点都不同，则称简单路径。 </li>
<li>回路：起点等于终点的路径</li>
<li>连通图：图中任意两顶点均连通</li>
</ul>
<p>无向图：</p>
<ul>
<li>连通分量：无向图的<strong>极大</strong>连通子图<ul>
<li><strong>极大</strong>顶点数：再加1个顶点就不连通了</li>
<li><strong>极大</strong>边数：包含子图中所有顶点相连的所有边</li>
</ul>
</li>
</ul>
<p>有向图：</p>
<ul>
<li>强连通：有向图中顶点V和W之间存在<strong>双向路径</strong>（不一定是同一条，但是都存在），则称V和W是强连通的<ul>
<li>强连通图：有向图中任意两顶点均强连通</li>
<li>强连通分量：有向图的极大强连通子图</li>
</ul>
</li>
</ul>
<p>如何遍历不连通的图呢？<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ListComponents</span><span class="hljs-params">(Graph)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(each V in G)&#123;<br>        <span class="hljs-keyword">if</span>(!visited[V])&#123;<br>            <span class="hljs-built_in">DFS</span>(V);<span class="hljs-comment">//or BFS</span><br>            <span class="hljs-comment">// 每调用一次DFS/BFS, 就把V所在的连通分量遍历了一遍</span><br>            <span class="hljs-comment">// 类似于绘画工具中的油漆桶</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h3 id="如何建立图"><a href="#如何建立图" class="headerlink" title="如何建立图"></a>如何建立图</h3><h4 id="邻接矩阵表示"><a href="#邻接矩阵表示" class="headerlink" title="邻接矩阵表示"></a>邻接矩阵表示</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Nv; <span class="hljs-comment">//顶点数</span><br>    <span class="hljs-keyword">int</span> Ne; <span class="hljs-comment">//边数</span><br>    WeightType G[MaxVertexNum][MaxVertexNum]<br>    Datatype Data[MaxVertexNum] <span class="hljs-comment">//存顶点的数据</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToGNOde MGraph; <span class="hljs-comment">//以邻接矩阵存储的图类型</span><br></code></pre></div></td></tr></table></figure>
<p>初始化一个有VertexNum个顶点但没有边的图<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">MGraph <span class="hljs-title">CreateGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> VertexNum)</span></span><br><span class="hljs-function"></span>&#123;<br>    MGraph Graph;<br>    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct GNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(V =<span class="hljs-number">0</span> ;V&lt;Graph-&gt;Nv;V++)&#123;<br>        <span class="hljs-keyword">for</span>(W=;W&lt;Graph-&gt;Nv;W++)&#123;<br>            Graph-&gt;G[V][W] = ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>向MGraph中插入边<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span><br>    Vertex V1,V2; <span class="hljs-comment">//有向边&lt;V1,V2&gt;</span><br>    WeightType Weight; <span class="hljs-comment">//权值</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToENode Edge;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">(MGraph Graph, Edge E)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//插入&lt;v1,v2&gt;</span><br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    <span class="hljs-comment">//若是无向图，还要插入&lt;v2,v1&gt;</span><br>    Graph-&gt;G[E-&gt;v2][E-&gt;v1] = E-&gt;Weight;<br>&#125;<br>完整地建立一个MGraph&lt;br&gt;<br>输入格式：&lt;br&gt;<br>Nv Ne&lt;br&gt;<br>V1 V2 Weight&lt;br&gt;<br>... ...&lt;br&gt;<br>```<span class="hljs-function">cpp</span><br><span class="hljs-function">MGraph <span class="hljs-title">BuildGraph</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    MGraph Graph;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Nv);<br>    Graph = <span class="hljs-built_in">CreateGraph</span>(NV); <span class="hljs-comment">//initialization</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;(Graph-&gt;Ne));<br>    <span class="hljs-keyword">if</span>(Graph-&gt;Ne !=<span class="hljs-number">0</span>)&#123;<br>        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct ENode));<br>        <span class="hljs-keyword">for</span>(i=;i&lt;Graph-&gt;Ne;i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;E-&gt;V1,&amp;E-&gt;V2,&amp;E-&gt;Weight);<br>            <span class="hljs-built_in">InsertEdge</span>(Graph, E);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//如果顶点有数据的话，读入数据</span><br>    <span class="hljs-keyword">for</span>(V=;V&lt;Graph-&gt;Nv;V++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>),&amp;(Graph-&gt;Data[V]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<p>更简单的实现方法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> G[MAXN][MAXN],Nv,Ne;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BuildGraph</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i,j,v1,v2,w;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Nv);<br>    <span class="hljs-comment">// CreateGraph</span><br>    <span class="hljs-keyword">for</span>(i=;i&lt;Nv;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j=;j&lt;Nv;j++)&#123;<br>            G[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Ne);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;Ne;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;v1,&amp;v2,&amp;w);<br>        G[v1][v2] = w;<br>        G[v2][v1] = w;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="邻接表表示"><a href="#邻接表表示" class="headerlink" title="邻接表表示"></a>邻接表表示</h4><p><img src="/img/pics/6.1.5.png" srcset="/img/loading.gif" lazyload alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> Nv; <span class="hljs-comment">//顶点数</span><br>    <span class="hljs-keyword">int</span> Ne; <span class="hljs-comment">//边数</span><br>    AdjList G; <span class="hljs-comment">//邻接表</span><br>&#125;；<br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph;<br><span class="hljs-comment">//以邻接表方式存储的图</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vnode</span>&#123;</span><br>    PtrToAdjVNode FirstEdge;<br>    DataType Data; <span class="hljs-comment">//存顶点的数据</span><br>&#125; AdjList[MaxVertexNum];<br><span class="hljs-comment">// AdjList是邻接表类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span><br>    Vertex AdjV; <span class="hljs-comment">//邻接点下标</span><br>    WeightType Weight; <span class="hljs-comment">// 边权值</span><br>    PtrToAdjVNode Next; <span class="hljs-comment">// 指向下一个</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><br>初始化一个有VertexNum个顶点但没有边的图<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> Vertex; <span class="hljs-comment">//用顶点下标表示顶点，为整形</span><br><span class="hljs-function">LGraph <span class="hljs-title">CreateGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> VertexNum)</span></span><br><span class="hljs-function"></span>&#123;<br>    Vertex V,W;<br>    LGraph Graph;<br>    Graph = (LGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct GNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 使得其指针为空</span><br>    <span class="hljs-keyword">for</span>(V = <span class="hljs-number">0</span>;V&lt;Graph-&gt;Nv;V++)&#123;<br>        Graph-&gt;G[V].FirstEdge = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>向LGraph中插入边<br><img src="/img/pics/6.1.6.png" srcset="/img/loading.gif" lazyload alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertEdge</span><span class="hljs-params">(LGraph Graph, Edge E)</span></span><br><span class="hljs-function"></span>&#123;<br>    PtrToAdjVNode NewNode;<br>    <span class="hljs-comment">//先为V2建立新的邻接点</span><br>    NewNode=(PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V2;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">//再将V2插入V1的表头</span><br>    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;<br>    Graph-&gt;[E-&gt;V1].FirstEdge = NewNode;<br><br>    <span class="hljs-comment">//若是无向图，还要插入&lt;V2,V1&gt;</span><br>    <span class="hljs-comment">//先为V1建立新的邻接点</span><br>    NewNode=(PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(struct AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V1;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">//再将V1插入V2的表头</span><br>    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge;<br>    Graph-&gt;[E-&gt;V2].FirstEdge = NewNode;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h2 id="图（下）"><a href="#图（下）" class="headerlink" title="图（下）"></a>图（下）</h2><h3 id="最小生成树（Minimum-Spanning-Tree"><a href="#最小生成树（Minimum-Spanning-Tree" class="headerlink" title="最小生成树（Minimum Spanning Tree)"></a>最小生成树（Minimum Spanning Tree)</h3><p><strong>最小生成树存在</strong> 和 <strong>图连通</strong> 是一对充分必要条件</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>是一棵树<ul>
<li>无回路</li>
<li>V个顶点一定有V-1条边</li>
</ul>
</li>
<li>是生成树<ul>
<li>包含全部顶点</li>
<li>V-1条边都在图里</li>
<li>向生成树中任加一条边都一定构成回路</li>
</ul>
</li>
<li>边的权重和最小</li>
</ul>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><ul>
<li>每一步都要最好的</li>
<li>每次都要权重最小的边</li>
</ul>
<p><strong>约束：</strong></p>
<ul>
<li><strong>只能用图里有的边</strong></li>
<li><strong>只能正好用掉V-1条边</strong></li>
<li><strong>不能有回路</strong></li>
</ul>
<h4 id="Prim-普利姆-算法-让一棵小树长大"><a href="#Prim-普利姆-算法-让一棵小树长大" class="headerlink" title="Prim(普利姆)算法-让一棵小树长大"></a>Prim(普利姆)算法-让一棵小树长大</h4><p><strong>注意：构造时需要判断不能构成回路！</strong></p>
<p>适用于稠密图，算法复杂度为<strong>O(V<sup>2</sup></strong></p>
<p>算法描述：</p>
<ol>
<li>在一个加权连通图中，顶点集合V，边集合为E</li>
<li>任意选出一个点作为初始顶点,标记为visit,计算所有与之相连接的点的距离，选择距离最短的，标记visit.</li>
<li>重复以下操作，直到所有点都被标记为visit：<br>在剩下的点中，计算与已标记visit点距离最小的点，标记visit,证明加入了最小生成树。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化：dist[V] = E(s,V)或正无穷</span><br>    <span class="hljs-comment">//        parent[s] = -1</span><br>    MST = &#123;s&#125;;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        V = 未收录顶点中dist最小者;<br>        <span class="hljs-keyword">if</span>(这样的V不存在)&#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">//MST完成了，或者剩下的结点和树之间的距离都是无穷大</span><br>        &#125;<br>        <span class="hljs-comment">//将V收录进MST</span><br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>            <span class="hljs-keyword">if</span>(dist[W]!=<span class="hljs-number">0</span>,<span class="hljs-string">&quot;即没有被收录&quot;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">E</span>(V,W)&lt;dist[W],<span class="hljs-string">&quot;小树长大后，需要更新一下未收录结点和MST的距离&quot;</span>)&#123;<br>                    dist[W] = <span class="hljs-built_in">E</span>(V,W);<br>                    parent[W] = V;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">if</span>(MST中收录的顶点不到V个)<br>         <span class="hljs-comment">//说明图不是连通的</span><br>         &#123;<br>             <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;生成树不存在&quot;</span>);<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="Kruskal算法-将森林合并成树"><a href="#Kruskal算法-将森林合并成树" class="headerlink" title="Kruskal算法-将森林合并成树"></a>Kruskal算法-将森林合并成树</h4><p><strong>注意：构造时需要判断不能构成回路！</strong></p>
<p>适用于稀疏图，直接选出权重最小的边（每一条边都会连接两棵树，因此是树的合并），直到无法再选出符合条件的边为止。时间复杂度：O(ElogE)</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(Graph G)</span></span><br><span class="hljs-function"></span>&#123;<br>    MST = &#123;&#125;;<br>    <span class="hljs-keyword">while</span>(MST中不到V<span class="hljs-number">-1</span>条边&amp;&amp;E中还有边)&#123;<br>        从E中取一条权重最小的边<span class="hljs-built_in">E</span>(V,W); <span class="hljs-comment">//最小堆</span><br>        将<span class="hljs-built_in">E</span>(V,W)从E中删除；<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">E</span>(V,W)不在MST中构成回路)<br>            将<span class="hljs-built_in">E</span>(V,W)加入MST;<br>        <span class="hljs-keyword">else</span><br>            彻底无视<span class="hljs-built_in">E</span>(V,W);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(MST中不到V<span class="hljs-number">-1</span>条边)<br>        <span class="hljs-built_in">ERROR</span>(<span class="hljs-string">&quot;生成树不存在&quot;</span>)；<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>AOV(activity on vertex)网络,活动仅发生在顶点处。</li>
<li>拓扑序：如果图中从V到W有一条有向路径，则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序</li>
<li>获得一个拓扑序的过程就是拓扑排序</li>
<li>AOV如果有合理的拓扑序，则必定是有向无环图（Directed Acyclic Graph, DAG)<br><img src="/img/pics/8.2.1.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ul>
<p>算法：</p>
<ul>
<li>每次选择入度为0的顶点（没有前置结点）</li>
<li>每次输出后，要把被输出的点和他对应的边给抹除</li>
<li>不断这样一层一层输出，即可得到拓扑序<br><img src="/img/pics/8.2.2.png" srcset="/img/loading.gif" lazyload alt=""><br><img src="/img/pics/8.2.3.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ul>
<p>O(V<sup>2</sup>)<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TopSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(cnt = <span class="hljs-number">0</span>; cnt&lt;V;cnt++)&#123;<br>        V = 未输出的入度为<span class="hljs-number">0</span>的顶点; <span class="hljs-comment">//这一步的扫描很耗时（O(N)）</span><br>        <span class="hljs-keyword">if</span>(这样的V不存在)&#123;  <span class="hljs-comment">//即，外循环还没结束，就碰到入度始终不为0的结点</span><br>            <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;图中有回路&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        输出V，或者记录V的输出序号;<br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>            Indegree[W]--;<span class="hljs-comment">//入度减少</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 更加聪明的算法：随时将入度变为0的顶点放到一个容器里，这样就不用扫描</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TopSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(图中每个顶点V)&#123;<br>        <span class="hljs-keyword">if</span>(Indegree[V]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">Enqueue</span>(V,Q);<br>        &#125;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">IsEmpty</span>(Q))&#123;<br>            V = <span class="hljs-built_in">Dequeue</span>(Q);<br>            输出V，或者记录V的输出序号;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(V的每个邻接点W)&#123;<br>                <span class="hljs-keyword">if</span>(--Indegree[W]==<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">Enqueue</span>(W,Q); <span class="hljs-comment">//碰到入度为0的直接加入队列，就不用额外重新扫描</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt != V)&#123;<br>        <span class="hljs-built_in">ERROR</span>(<span class="hljs-string">&quot;图中有回路&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>这个算法还可以用来检测一个有向图是否是有向无环图(DAG)</p>
<h4 id="关键路径问题"><a href="#关键路径问题" class="headerlink" title="关键路径问题"></a>关键路径问题</h4><p>AOE(Activity On Edge)网络</p>
<ul>
<li>一般用于安排项目的工序<br><img src="/img/pics/8.2.4.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ul>
<p>工期安排举例：<br><img src="/img/pics/8.2.5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>关键路径则是由<strong>绝对不允许延误</strong>的活动组成的路径</p>
<h2 id="排序（上）"><a href="#排序（上）" class="headerlink" title="排序（上）"></a>排序（上）</h2><p>模板：</p>
<h3 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h3><h4 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h4><p>改进：设立一个flag标志一次循环中是否有做交换（swap）若没有做交换，则认为其余序列已经是有序的，则可以直接跳出，节省时间。</p>
<p>最好情况：顺序，T=O(N)<br><br>最坏情况：逆序，T=O(N<sup>2</sup>)</p>
<p>优点：可与适配数组和链表，而且在由于只在值不同时才做交换，是稳定的。<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (P=N<span class="hljs-number">-1</span>;P&gt;=<span class="hljs-number">0</span>;P--)&#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;P;i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i]&gt;A[i+<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-built_in">swap</span>(A[i], A[i+<span class="hljs-number">1</span>]);<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h4><p>最好情况：顺序，T=O(N)<br><br>最坏情况：逆序，T=O(N<sup>2</sup>)<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insertion_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(P=<span class="hljs-number">1</span>;P&lt;N;P++)&#123;<br>        Tmp = A[P]; <br>        <span class="hljs-keyword">for</span>(i=P; i&gt;<span class="hljs-number">0</span> &amp;&amp; A[i<span class="hljs-number">-1</span>] &gt; Tmp; i--)&#123;<br>            A[i] = A[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//数据往后逐个拷贝移位</span><br>        &#125;<br>        A[i] = Tmp; <span class="hljs-comment">//插入</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<p>由于只有在牌大小不同时才移位，这种排序也是稳定的</p>
<h4 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h4><ul>
<li>对于下标i<j，如果A[i]>A[j], 则称(i,j)是一对逆序对(inversion)</li>
<li>交换2个相邻元素正好消去1个逆序对!</li>
<li>因此插入和冒泡对于同一个数列的交换次数一样不是巧合</li>
<li>插入排序：T(N,I)=O(N+I)<ul>
<li>如果序列基本有序，则插入排序简单有效</li>
</ul>
</li>
<li>任意N个不同元素组成的序列平均具有N(N-1)/4个逆序对。</li>
<li>定理:任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为Ω(N<sup>2</sup>)<ul>
<li>因此，要提高效率，必须<ul>
<li>每次消去不止一个的逆序对</li>
<li>每次交换相隔较远的2个元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="希尔排序（Shell-sort）（不稳定）"><a href="#希尔排序（Shell-sort）（不稳定）" class="headerlink" title="希尔排序（Shell sort）（不稳定）"></a>希尔排序（Shell sort）（不稳定）</h3><p>即采取设定间隔来采样，并对采样值分别做插入排序.<br><img src="/img/pics/9.1.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>希尔排序为什么不稳定？</p>
<blockquote>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
</blockquote>
<p>流程：</p>
<ol>
<li>定义一个增量序列作为采样间隔DM&gt;DM-1&gt;…&gt;D1=1，最后一位必须是1，比如{5, 3, 1}</li>
<li>对每个采样间隔进行“Dk-间隔排序”，比如对按照5-间隔滑动采样出来的5个序列分别进行插入排序。</li>
<li><strong>注意:“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk间隔”有序的，这是希尔排序的关键</strong></li>
</ol>
<p>注意：需要保证增量序列的互质！增量元素不互质，则小增量可能根本不起作用，如：<br><img src="/img/pics/9.1.2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>因此增量序列的设计是关键的，如这里采用Sedgwick</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 希尔排序 - 用Sedgewick增量序列 */</span><br>     <span class="hljs-keyword">int</span> Si, D, P, i;<br>     ElementType Tmp;<br>     <span class="hljs-comment">/* 这里只列出一小部分增量 */</span><br>     <span class="hljs-keyword">int</span> Sedgewick[] = &#123;<span class="hljs-number">929</span>, <span class="hljs-number">505</span>, <span class="hljs-number">209</span>, <span class="hljs-number">109</span>, <span class="hljs-number">41</span>, <span class="hljs-number">19</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>     <br>     <span class="hljs-keyword">for</span> ( Si=<span class="hljs-number">0</span>; Sedgewick[Si]&gt;=N; Si++ ) <br>         ; <span class="hljs-comment">/* 初始的增量Sedgewick[Si]不能超过待排序列长度 */</span><br><br>     <span class="hljs-keyword">for</span> ( D=Sedgewick[Si]; D&gt;<span class="hljs-number">0</span>; D=Sedgewick[++Si] )<br>         <span class="hljs-keyword">for</span> ( P=D; P&lt;N; P++ ) &#123; <span class="hljs-comment">/* 插入排序*/</span><br>             Tmp = A[P];<br>             <span class="hljs-keyword">for</span> ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )<br>                 A[i] = A[i-D];<br>             A[i] = Tmp;<br>         &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="选择排序（不稳定），堆排序（不稳定）"><a href="#选择排序（不稳定），堆排序（不稳定）" class="headerlink" title="选择排序（不稳定），堆排序（不稳定）"></a>选择排序（不稳定），堆排序（不稳定）</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序和插入排序的差别：插入排序是选择给定序列中最近的一组逆序对交换，而选择排序则是寻找全局最小元，并将其换到序列的最后位置</p>
<p>选择排序是不稳定的。</p>
<blockquote>
<p>举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
</blockquote>
<p>选择排序算法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Selection_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt; N; i++)&#123;<br>        MinPosition = <span class="hljs-built_in">ScanForMin</span>(A, i, N<span class="hljs-number">-1</span>); <span class="hljs-comment">//这一步scanformin需要O(N)的复杂度，可以用最小堆优化</span><br>        <span class="hljs-comment">// 从到中寻找最小元，并将其位置赋给MinPosition</span><br>        <span class="hljs-built_in">Swap</span>(A[i], A[MinPosition]&#125;);<br>        <span class="hljs-comment">// 将未排序部分的最小元换到有序部分的最后位置</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>（实际中，堆排序可能不如Sedgwick序列的希尔排序好用）</p>
<p>简单的情况：调用一个最小堆，使用时让其返回根节点（最小值）即可。</p>
<p><a target="_blank" rel="noopener" href="https://zhidao.baidu.com/question/589205766.html">堆排序不是稳定的</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39996908/article/details/111108431">为什么需要判断排序是否稳定</a></p>
<blockquote>
<p>在需要对多个(也意味着多次)具有优先级的关键字进行排序的场景下，稳定排序能利用上一次排序的结果服务于本次排序，从而保证对于值相同的元素的两次排序结果相同。</p>
</blockquote>
<p>算法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Heap_Sort</span> <span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">BuildHeap</span>(A); <span class="hljs-comment">// O(N)</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;<br>        TmpA[i] = <span class="hljs-built_in">DeleteMin</span>(A); <span class="hljs-comment">//O(logN)</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123; <span class="hljs-comment">//这一步需要额外的O(N)空间，且复制也需要时间</span><br>        A[i] = TmpA[i];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><br>另一种算法，直接在原数组上操作，不需额外开辟空间复制元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PercDown</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 改编代码4.24的PercDown( MaxHeap H, int p )    */</span><br>  <span class="hljs-comment">/* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 */</span><br>    <span class="hljs-keyword">int</span> Parent, Child;<br>    ElementType X;<br><br>    X = A[p]; <span class="hljs-comment">/* 取出根结点存放的值 */</span><br>    <span class="hljs-keyword">for</span>( Parent=p; (Parent*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)&lt;N; Parent=Child ) &#123;<br>        Child = Parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>( (Child!=N<span class="hljs-number">-1</span>) &amp;&amp; (A[Child]&lt;A[Child+<span class="hljs-number">1</span>]) )<br>            Child++;  <span class="hljs-comment">/* Child指向左右子结点的较大者 */</span><br>        <span class="hljs-keyword">if</span>( X &gt;= A[Child] ) <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* 找到了合适位置 */</span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 下滤X */</span><br>            A[Parent] = A[Child];<br>    &#125;<br>    A[Parent] = X;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 堆排序 */</span><br>     <span class="hljs-keyword">int</span> i;<br>      <br>     <span class="hljs-keyword">for</span> ( i=N/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i-- )<span class="hljs-comment">/* 建立最大堆 */</span><br>         <span class="hljs-built_in">PercDown</span>( A, i, N );<br>     <br>     <span class="hljs-keyword">for</span> ( i=N<span class="hljs-number">-1</span>; i&gt;<span class="hljs-number">0</span>; i-- ) &#123;<br>         <span class="hljs-comment">/* 删除最大堆顶 */</span><br>         <span class="hljs-built_in">Swap</span>( &amp;A[<span class="hljs-number">0</span>], &amp;A[i] ); <span class="hljs-comment">/* 见代码7.1 */</span><br>         <span class="hljs-built_in">PercDown</span>( A, <span class="hljs-number">0</span>, i );<br>     &#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h3><p>是一种<strong>稳定</strong>的排序，算法复杂度也低。唯一的不好是需要额外的空间<br></p>
<p>内排序：指在排序期间数据对象全部存放在内存的排序。<br>外排序：指在排序期间全部对象太多，不能同时存放在内存中，必须根据排序过程的要求，不断在内，外存间移动的排序。<br><br>归并排序适用于外排序，不适用于内排序</p>
<h4 id="有序子列的归并"><a href="#有序子列的归并" class="headerlink" title="有序子列的归并"></a>有序子列的归并</h4><p>类似多项式相加的思想：<br><img src="/img/pics/9.2.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>算法：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">( ElementType A[], ElementType TmpA[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> RightEnd )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */</span><br>     <span class="hljs-keyword">int</span> LeftEnd, NumElements, Tmp;<br>     <span class="hljs-keyword">int</span> i;<br>     <br>     LeftEnd = R - <span class="hljs-number">1</span>; <span class="hljs-comment">/* 左边终点位置 */</span><br>     Tmp = L;         <span class="hljs-comment">/* 有序序列的起始位置 */</span><br>     NumElements = RightEnd - L + <span class="hljs-number">1</span>;<br>     <br>     <span class="hljs-keyword">while</span>( L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd ) &#123;<br>         <span class="hljs-keyword">if</span> ( A[L] &lt;= A[R] )<br>             TmpA[Tmp++] = A[L++]; <span class="hljs-comment">/* 将左边元素复制到TmpA */</span><br>         <span class="hljs-keyword">else</span><br>             TmpA[Tmp++] = A[R++]; <span class="hljs-comment">/* 将右边元素复制到TmpA */</span><br>     &#125;<br><br>     <span class="hljs-keyword">while</span>( L &lt;= LeftEnd )<br>         TmpA[Tmp++] = A[L++]; <span class="hljs-comment">/* 直接复制左边剩下的 */</span><br>     <span class="hljs-keyword">while</span>( R &lt;= RightEnd )<br>         TmpA[Tmp++] = A[R++]; <span class="hljs-comment">/* 直接复制右边剩下的 */</span><br>         <br>     <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; NumElements; i++, RightEnd -- )<br>         A[RightEnd] = TmpA[RightEnd]; <span class="hljs-comment">/* 将有序的TmpA[]复制回A[] */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>分而治之。<br><img src="/img/pics/9.2.2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Msort</span><span class="hljs-params">( ElementType A[], ElementType TmpA[], <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> RightEnd )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 核心递归排序函数 */</span> <br>     <span class="hljs-keyword">int</span> Center;<br>     <br>     <span class="hljs-keyword">if</span> ( L &lt; RightEnd ) &#123;<br>          Center = (L+RightEnd) / <span class="hljs-number">2</span>;<br>          <span class="hljs-built_in">Msort</span>( A, TmpA, L, Center );              <span class="hljs-comment">/* 递归解决左边 */</span> <br>          <span class="hljs-built_in">Msort</span>( A, TmpA, Center+<span class="hljs-number">1</span>, RightEnd );     <span class="hljs-comment">/* 递归解决右边 */</span>  <br>          <span class="hljs-built_in">Merge</span>( A, TmpA, L, Center+<span class="hljs-number">1</span>, RightEnd );  <span class="hljs-comment">/* 合并两段有序序列 */</span> <br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><br><span class="hljs-comment">/* 归并排序 - 循环实现 */</span><br><span class="hljs-comment">/* 这里Merge函数在递归版本中给出 */</span><br><br><span class="hljs-comment">/* length = 当前有序子列的长度*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge_pass</span><span class="hljs-params">( ElementType A[], ElementType TmpA[], <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> length )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 两两归并相邻有序子列 */</span><br>     <span class="hljs-keyword">int</span> i, j;<br>      <br>     <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i &lt;= N<span class="hljs-number">-2</span>*length; i += <span class="hljs-number">2</span>*length )<br>         <span class="hljs-built_in">Merge</span>( A, TmpA, i, i+length, i+<span class="hljs-number">2</span>*length<span class="hljs-number">-1</span> );<br>     <span class="hljs-keyword">if</span> ( i+length &lt; N ) <span class="hljs-comment">/* 归并最后2个子列*/</span><br>         <span class="hljs-built_in">Merge</span>( A, TmpA, i, i+length, N<span class="hljs-number">-1</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-comment">/* 最后只剩1个子列*/</span><br>         <span class="hljs-keyword">for</span> ( j = i; j &lt; N; j++ ) TmpA[j] = A[j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Merge_Sort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <br>     <span class="hljs-keyword">int</span> length; <br>     ElementType *TmpA;<br>     <br>     length = <span class="hljs-number">1</span>; <span class="hljs-comment">/* 初始化子序列长度*/</span><br>     TmpA = <span class="hljs-built_in">malloc</span>( N * <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( ElementType ) );<br>     <span class="hljs-keyword">if</span> ( TmpA != <span class="hljs-literal">NULL</span> ) &#123;<br>          <span class="hljs-keyword">while</span>( length &lt; N ) &#123;<br>              <span class="hljs-built_in">Merge_pass</span>( A, TmpA, N, length );<br>              length *= <span class="hljs-number">2</span>;<br>              <span class="hljs-built_in">Merge_pass</span>( TmpA, A, N, length );<br>              length *= <span class="hljs-number">2</span>;<br>          &#125;<br>          <span class="hljs-built_in">free</span>( TmpA );<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;空间不足&quot;</span> );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="排序（下）"><a href="#排序（下）" class="headerlink" title="排序（下）"></a>排序（下）</h2><h3 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h3><p>算法思想：分而治之<br><br>使用主元（pivot）将数据分成两块<br><img src="/img/pics/10.1.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>伪码描述：<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Quicksort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(N&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    pivot = 从A[]中选一个主元  &lt;- 这一步很关键<br>    将S=&#123;A[]\pivot&#125;分成两个独立子集： &lt;- 这一步也很关键<br>        A1 = &#123; a∈S | a≤pivot &#125; 和<br>        A2 = &#123; a∈S | a≥pivot &#125;;<br>    A[] = <span class="hljs-built_in">Quicksort</span>(A1,N1)∪&#123;pivot&#125;∪<span class="hljs-built_in">Quicksort</span>(A2,N2)<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<p>当每次正好中分时，是快排算法的最好情况，此时O(NlogN)</p>
<h4 id="怎么选择主元"><a href="#怎么选择主元" class="headerlink" title="怎么选择主元"></a>怎么选择主元</h4><ul>
<li>经典方法：取头、中、尾的中位数（一共就3个元素）（如8、12、3的中位数是8）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ElementType <span class="hljs-title">Median3</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right )</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">int</span> Center = (Left+Right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> ( A[Left] &gt; A[Center] )<br>        <span class="hljs-built_in">Swap</span>( &amp;A[Left], &amp;A[Center] );<br>    <span class="hljs-keyword">if</span> ( A[Left] &gt; A[Right] )<br>        <span class="hljs-built_in">Swap</span>( &amp;A[Left], &amp;A[Right] );<br>    <span class="hljs-keyword">if</span> ( A[Center] &gt; A[Right] )<br>        <span class="hljs-built_in">Swap</span>( &amp;A[Center], &amp;A[Right] );<br>    <span class="hljs-comment">/* 此时A[Left] &lt;= A[Center] &lt;= A[Right] */</span><br>    <span class="hljs-built_in">Swap</span>( &amp;A[Center], &amp;A[Right<span class="hljs-number">-1</span>] ); <span class="hljs-comment">/* 将基准Pivot藏到右边*/</span><br>    <span class="hljs-comment">/* 只需要考虑A[Left+1] … A[Right-2] */</span><br>    <span class="hljs-keyword">return</span>  A[Right<span class="hljs-number">-1</span>];  <span class="hljs-comment">/* 返回基准Pivot */</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="怎么划分子集"><a href="#怎么划分子集" class="headerlink" title="怎么划分子集"></a>怎么划分子集</h4><p>快排之所以快的原因在于子集划分之后，它的主元被一次性地放到了正确的位置上，以后不再移动，而不像插入排序那样之后还可能要移动。</p>
<p>如果有元素正好等于pivot，则停下来交换，这样可以保证pivot最后会处于比较中心的位置，对于递归来说是有好处的</p>
<p>初始状态，6为pivot，初始化两个指针i和j，分别往右和往左移<br><br>i所指向的值应该比6小，否则就发出红色警告，j反之。<br><img src="/img/pics/10.1.2.png" srcset="/img/loading.gif" lazyload alt=""><br>一边发出红色警告则停止，让另一边开始移动；如果两边都发出红色警告，则停止<br><img src="/img/pics/10.1.3.png" srcset="/img/loading.gif" lazyload alt=""><br>并交换他们所指向的元素。<br><img src="/img/pics/10.1.4.png" srcset="/img/loading.gif" lazyload alt=""><br>然后进行下一轮的比较，如果没有发出警报就一直右移/左移<br><img src="/img/pics/10.1.5.png" srcset="/img/loading.gif" lazyload alt=""><br>交换，<br><img src="/img/pics/10.1.6.png" srcset="/img/loading.gif" lazyload alt=""><br>直到检测到i，j错位，则结束，并将pivot交换到i的位置<br><img src="/img/pics/10.1.7.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="对于小规模数据的处理："><a href="#对于小规模数据的处理：" class="headerlink" title="对于小规模数据的处理："></a>对于小规模数据的处理：</h4><ul>
<li>快速排序的问题<ul>
<li>用到递归</li>
<li>对小规模的数据（例如N不到100）可能还不如插入排序快</li>
</ul>
</li>
<li>解决方案<ul>
<li>当递归的数据规模小于一个阈值，则停止递归，直接调用简单排序（例如插入排序）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Qsort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 核心递归函数 */</span> <br>     <span class="hljs-keyword">int</span> Pivot, Cutoff, Low, High;<br>      <span class="hljs-comment">// Cutoff是阈值</span><br>     <span class="hljs-keyword">if</span> ( Cutoff &lt;= Right-Left ) &#123; <span class="hljs-comment">/* 如果序列元素充分多，进入快排 */</span><br>          Pivot = <span class="hljs-built_in">Median3</span>( A, Left, Right ); <span class="hljs-comment">/* 选基准 */</span> <br>          Low = Left; High = Right<span class="hljs-number">-1</span>;<br>          <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/*将序列中比基准小的移到基准左边，大的移到右边*/</span><br>               <span class="hljs-keyword">while</span> ( A[++Low] &lt; Pivot ) ;<br>               <span class="hljs-keyword">while</span> ( A[--High] &gt; Pivot ) ;<br>               <span class="hljs-keyword">if</span> ( Low &lt; High ) <span class="hljs-built_in">Swap</span>( &amp;A[Low], &amp;A[High] );<br>               <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-built_in">Swap</span>( &amp;A[Low], &amp;A[Right<span class="hljs-number">-1</span>] );   <span class="hljs-comment">/* 将基准换到正确的位置 */</span> <br>          <span class="hljs-built_in">Qsort</span>( A, Left, Low<span class="hljs-number">-1</span> );    <span class="hljs-comment">/* 递归解决左边 */</span> <br>          <span class="hljs-built_in">Qsort</span>( A, Low+<span class="hljs-number">1</span>, Right );   <span class="hljs-comment">/* 递归解决右边 */</span>  <br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-built_in">InsertionSort</span>( A+Left, Right-Left+<span class="hljs-number">1</span> ); <span class="hljs-comment">/* 元素太少，用简单排序 */</span> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">( ElementType A[], <span class="hljs-keyword">int</span> N )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 统一接口 */</span><br>     <span class="hljs-built_in">Qsort</span>( A, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span> );<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="表排序"><a href="#表排序" class="headerlink" title="表排序"></a>表排序</h3><p>每个元素是具体的，庞大的一个实体（如，一部5G的电影，一个3G的ZIP），这时对其进行任何频繁的swap都是不切实际的。<br><br>表排序不移动元素本身，只移动指针，这种排序方法叫做<strong>间接排序</strong>。</p>
<p>间接排序</p>
<ul>
<li>定义一个指针数组作为表(table)</li>
<li>只需修改指针数组即可</li>
<li>输出时直接输出排序后的指针数组所对应的元素<br><img src="/img/pics/10.2.1.png" srcset="/img/loading.gif" lazyload alt=""><br>如果仅仅要求按顺序输出，则输出：<br><br>A[table[0]],A[table[1]],…,A[table[N-1]]</li>
</ul>
<h4 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h4><p>N个数字的排列由若干个独立的环组成，按顺序地移位每一个独立的环。<br><br>如果table[i] == i，则说明这个物体已经在他该待的位置上了（环中只有他一个元素）</p>
<h3 id="基数排序（Radix-sort）（稳定）"><a href="#基数排序（Radix-sort）（稳定）" class="headerlink" title="基数排序（Radix sort）（稳定）"></a>基数排序（Radix sort）（稳定）</h3><p>只能用于有基数的东西。对于结构体排序，或者只有相对大小关系，没有具体数值（比如你要自己写判断大小的函数），那么基数排序就没法使用（因为它不是基于比较的）。<br><br>基于比较的排序下界就是O(nlogn)，基数排序不是基于比较的排序，而是基于数据分配，所以可以突破下界</p>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>引例：假设我们有N个学生，他们的成绩是0到100之间的整数(于是有M=101个不同的成绩值)。如何在线性时间内将学生按成绩排序?<br><br>由于只有101个不同的成绩值，可以直接分成101个不同的桶，数据便可扫描一遍就对号入座，接入对应的链表里。输出时只需直接按顺序输出链表即可<br><img src="/img/pics/10.3.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bucket_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-keyword">int</span> N)</span> </span><br><span class="hljs-function"></span>&#123;  count[]初始化;<br>   <span class="hljs-keyword">while</span> (读入<span class="hljs-number">1</span>个学生成绩grade)<br>      将该生插入count[grade]链表;<br>   <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">0</span>; i&lt;M; i++ ) &#123;<br>      <span class="hljs-keyword">if</span> ( count[i] )<br>         输出整个count[i]链表;<br>   &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但是如果M比N大很多怎么办呢？加入M=1000，N=10，那就要建1000个桶，很不划算。这时可以使用基数排序。这里的基数指进制的基数，比如10进制则为10</p>
<p>如果按照<strong>次位优先(Least Significant Digit, LSD)</strong>，则：<br><img src="/img/pics/10.3.2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>基数排序的算法复杂度取决于桶的个数。如果桶比较少的话，复杂度接近线性。</p>
<h4 id="多关键字的排序"><a href="#多关键字的排序" class="headerlink" title="多关键字的排序"></a>多关键字的排序</h4><p>引例：扑克牌的排序，花色是主关键字，面值是次关键字。<br><img src="/img/pics/10.3.3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>运用基数排序，如果把主关键字作为高位，次关键字作为低位，就用到了<strong>主位优先(Most Significant Digit, MSD)</strong>。</p>
<ol>
<li>第一种办法：<br>为4种花色建立4个桶，再在每个花色桶里对数值进行排序——这样效率不高</li>
<li>第二种方法：用次位优先：<br>先为面值建立13个桶，将结果合并，然后再为花色建立4个桶。—-效率大大提高（实际上在现实生活中，也倾向于用第二种方法分扑克牌。但是相较于第一种方法，显然地，第二种需要占用的桌面，或者说空间，要大得多。）</li>
</ol>
<h3 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/knull/archive/2012/12/11/2813724.html">常见排序算法的代码实例</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序方法</th>
<th>平均时间复杂度</th>
<th>最坏情况下时间复杂度</th>
<th>额外空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单选择排序</td>
<td>O(N<sup>2</sup>)</td>
<td>O(N<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(N<sup>2</sup>)</td>
<td>O(N<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(N<sup>2</sup>)</td>
<td>O(N<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(N<sup>d</sup>)</td>
<td>O(N<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(NlogN)</td>
<td>O(N<sup>2</sup>)</td>
<td>O(logN)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(NlogN)</td>
<td>O(NlogN)</td>
<td>O(N)</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(P(N+B))</td>
<td>O(P(N+B))</td>
<td>O(N+B)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
</div>
<h2 id="散列查找（哈希）"><a href="#散列查找（哈希）" class="headerlink" title="散列查找（哈希）"></a>散列查找（哈希）</h2><p>目前已经学过的查找方法：</p>
<ol>
<li>顺序查找 O(N)</li>
<li>二分查找（静态查找），需要先把数据从小到大排好 O(log<sub>2</sub>N)</li>
<li>二叉搜索树 O(h) h为二叉查找树的高度</li>
<li>平衡二叉树(AVL) O(log<sub>2</sub>N)</li>
</ol>
<p>对于二叉查找，对于 10亿 的用户，查找30次即可，且只需要1T的连续空间。但是因为账户数据是按大小有序存储的，插入和删除一个新的QQ号码将需要移动大量数据。</p>
<p><strong>查找的本质：</strong>已知对象，查找位置</p>
<ul>
<li>如果是有序安排对象：全序、半序</li>
<li>直接“算出”对象位置：散列/哈希</li>
</ul>
<p>散列查找的两项基本工作：</p>
<ul>
<li>计算位置：构造合适的散列函数(哈希函数)来确定关键词的存储位置</li>
<li>解决冲突：应用某种策略解决多个关键词位置相同的问题</li>
</ul>
<p>哈希的时间复杂度几乎是常量：O(1),也就是说查找时间与问题的规模无关！</p>
<p>以空间换时间</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表的数据结构描述：</p>
<p>类型名称:符号表（SymbolTable）</p>
<p>数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合。</p>
<p>操作集：Table$\in$SymbolTable，Name$\in$NameType，Attr$\in$AttributeType</p>
<ol>
<li>SymbolTable InitializeTable( int TableSize )： 创建一个长度为TableSize的符号表；</li>
<li>Boolean IsIn( SymbolTable Table, NameType Name)： 查找特定的名字Name是否在符号表Table中；</li>
<li>AttributeType Find( SymbolTable Table, NameType Name)： 获取Table中指定名字Name对应的属性；</li>
<li>SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)： 将Table中指定名字Name的属性修改为Attr；</li>
<li>SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)： 向Table中插入一个新名字Name及其属性Attr；</li>
<li>SymbolTable Delete(SymbolTable Table, NameType Name)： 从Table中删除一个名字Name及其属性。</li>
</ol>
<p>“散列（Hashing）” 的基本思想是：</p>
<ul>
<li>以关键字key为自变量，通过一个确定的函数 h（散列函数），计算出对应的函数值h(key)，作为数据对象的存储地址。</li>
<li>可能不同的关键字会映射到同一个散列地址上， 即h(key<sub>i</sub>) = h(key<sub>j</sub>)（当key<sub>&lt;/sub&gt; ≠key<sub>j</sub>），称为“冲突(Collision)”。</li>
<li>因此需要某种冲突解决策略</li>
</ul>
<p>举例：<br><br>有n = 11个数据对象的集合{18，23，11，20，2，7，27，30，<br>42，15，34}。<br><br>符号表的大小用TableSize = 17，选取散列函数h如下：<br>h(key) = key mod TableSize (求余)<br><img src="/img/pics/11.1.1.png" srcset="/img/loading.gif" lazyload alt=""></p>
<ol>
<li><p>存放：<br> h(18)=1, h(23)=6, h(11)=11, h(20)=3, h(2)=2, …….<br><br> 如果新插入35， h(35)=1, 该位置已有对象！冲突！！(潜在解决办法：使用二维数组，先匹配到对应的行的第一列，如果有冲突，加到该行的后续的列)</p>
</li>
<li><p>查找：<br>key = 22, h(22)= 5，该地址空，不在表中<br><br>key = 30, h(30)= 13，该地址存放是30，找到！</p>
</li>
</ol>
<p>装填因子（Loading Factor）：设散列表空间大小为m，填入表<br>中元素个数是n，则称α＝ n / m为散列表的装填因子α＝11 / 17 ≈ 0.65</p>
<h3 id="哈希函数的构造方法"><a href="#哈希函数的构造方法" class="headerlink" title="哈希函数的构造方法"></a>哈希函数的构造方法</h3><p>一个“好”的散列函数一般应考虑下列两个因素：</p>
<ol>
<li>计算简单，以便提高转换速度；</li>
<li>关键词对应的地址空间分布均匀，以尽量减少冲突。</li>
</ol>
<h4 id="数字关键词的哈希函数构造"><a href="#数字关键词的哈希函数构造" class="headerlink" title="数字关键词的哈希函数构造"></a><strong>数字关键词</strong>的哈希函数构造</h4><ol>
<li>直接定址法<br>取关键词的某个线性函数值为散列地址，即h(key) = a · key + b (a、b为常数)</li>
<li>除留余数法<br>哈希函数为：h(key) = key mod p</li>
<li><p>数字分析法<br>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址<br><br>比如：取11位手机号码key的后4位作为地址：散列函数为：h(key) = atoi(key+7) (char *key），atoi是array to integer函数</p>
</li>
<li><p>折叠法<br>把关键词分割成位数相同的几个部分，然后叠加：<br><img src="/img/pics/11.1.2.png" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li>平方取中法<br><img src="/img/pics/11.1.3.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ol>
<h4 id="字符关键词的哈希函数构造"><a href="#字符关键词的哈希函数构造" class="headerlink" title="字符关键词的哈希函数构造"></a><strong>字符关键词</strong>的哈希函数构造</h4><p>通过求余mod操作来实现大整数向小整数的映射</p>
<ol>
<li><p>一个简单的散列函数——ASCII码加和法<br>对字符型关键词key定义散列函数如下：</p>
<script type="math/tex; mode=display">h(key) = ( \Sigma key[i]) mod TableSize</script><p>但是这个方法在碰到这些字符时冲突严重：a3, b2, c1; eat, tea</p>
</li>
<li><p>简单的改进——前3个字符移位法:</p>
<script type="math/tex; mode=display">h(key)=(key[0] \times 27^2 + key[1] \times 27 + key[2])mod TableSize</script><p>仍然冲突：string、 street、strong、structure等等；空间浪费：3000/263 ≈ 30%</p>
</li>
<li><p>好的散列函数——移位法:<br>涉及关键词所有n个字符，并且分布得很好：</p>
<script type="math/tex; mode=display">h(key) = (\Sigma_{i=0}^{n-1} key[n - i - 1]\times 32^i ) mod TableSize</script></li>
</ol>
<p>快速计算：</p>
<script type="math/tex; mode=display">h(“abcde”)=‘a’*324+’b’*323+’c’*322+’d’*32+’e’</script><p>巧妙的做法：<br><br>( ( (a x 32 + b) x 32 + c) x 32 + d) …<br><br>而这里更巧妙的是，乘以32实际上就是向左移动5位<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">Index <span class="hljs-title">Hash</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *Key, <span class="hljs-keyword">int</span> TableSize )</span></span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>; <span class="hljs-comment">// 散列函数值，初始化为0 </span><br>    <span class="hljs-keyword">while</span> ( *Key != <span class="hljs-string">&#x27;\0&#x27;</span>) <span class="hljs-comment">// 这里\0代表字符串的末尾，为空</span><br>        h = ( h &lt;&lt; <span class="hljs-number">5</span> ) + *Key++; <span class="hljs-comment">//左移5位就是乘32，因此虽然ascii码字母只有27，我们还是把进制设为32更方便</span><br>    <span class="hljs-keyword">return</span> h % TableSize;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h3 id="冲突的处理"><a href="#冲突的处理" class="headerlink" title="冲突的处理"></a>冲突的处理</h3><h4 id="开放地址法（Open-Addressing）"><a href="#开放地址法（Open-Addressing）" class="headerlink" title="开放地址法（Open Addressing）"></a>开放地址法（Open Addressing）</h4><p>若发生了第 i 次冲突，试探的下一个地址将增加di，基本公式是：</p>
<script type="math/tex; mode=display">h_i(key) = (h(key)+d_i) mod TableSize ( 1≤ i < TableSize )</script><p>di 决定了不同的解决冲突方案：线性探测($d_i=i$)、平方探测($d_i = \pmi^2$)、双散列($d_1 = i\timesh_2(key$)。</p>
<h5 id="线性探测法（Linear-Probing）"><a href="#线性探测法（Linear-Probing）" class="headerlink" title="线性探测法（Linear Probing）"></a>线性探测法（Linear Probing）</h5><p>线性探测法：以增量序列 1，2，……，TableSize -1）循环试探下一个存储地址。</p>
<p>[例] 设关键词序列为 {47，7，29，11，9，84，54，20，30}，</p>
<ul>
<li>散列表表长TableSize =13 （装填因子 α = 9/13 ≈ 0.69）；</li>
<li>散列函数为：h(key) = key mod 11。<br>用线性探测法处理冲突，列出依次插入后的散列表，并估算查找性能</li>
</ul>
<p><img src="/img/pics/11.1.4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="/img/pics/11.1.5.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>哈希表查找性能分析</strong></p>
<ul>
<li>成功平均查找长度(ASLs)</li>
<li>不成功平均查找长度(ASLu)</li>
</ul>
<p>对于散列表：<br><img src="/img/pics/11.1.6.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>ASLs：查找表中关键词的平均查找比较次数（其冲突次数加1）<br><br>ASLs= （1+7+1+1+2+1+4+2+4）/ 9 = 23/9 ≈ 2.56</p>
<p>ASLu：不在散列表中的关键词的平均查找次数（不成功）<br><br>一般方法：将不在散列表中的关键词分若干类。<br>如：根据H(key)值分类<br><br>ASL u= （3+2+1+2+1+1+1+9+8+7+6）/ 11 = 41/11 ≈ 3.73</p>
<h5 id="平方探测法（Quadratic-Probing）—-二次探测"><a href="#平方探测法（Quadratic-Probing）—-二次探测" class="headerlink" title="平方探测法（Quadratic Probing）—- 二次探测"></a>平方探测法（Quadratic Probing）—- 二次探测</h5><p>平方探测法：以增量序列$1^2，-1^2，2^2，-2^2，……，q^2，-q^2$且$q ≤ floor(TableSize/2)$(向下取整)循环试探下一个存储地址。</p>
<p>[例]设关键词序列为 {47，7，29，11，9，84，54，20，30}，</p>
<ul>
<li>散列表表长TableSize = 11，</li>
<li>散列函数为：h(key) = key mod 11。<br>用平方探测法处理冲突，列出依次插入后的散列表，并估算ASLs。<br><img src="/img/pics/11.2.1.png" srcset="/img/loading.gif" lazyload alt=""></li>
</ul>
<p>ASLs = （1+1+2+1+1+3+1+4+4）/ 9 = 18/9 = 2<br><img src="/img/pics/11.2.2.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>但是，对于某些tablesize，平方探测（二次探测）并不能接触到全部的空间。<br><br>如果散列表长度TableSize是某个4k+3（k是正整<br>数）形式的素数时，平方探测法就可以探查到整个散列表空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class"><span class="hljs-title">HashTbl</span> *<span class="hljs-title">HashTable</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span>&#123;</span><br>    <span class="hljs-keyword">int</span> TableSize;<br>    Cell *TheCells;<br>&#125;H ;<br><br><span class="hljs-function">HashTable <span class="hljs-title">InitializeTable</span><span class="hljs-params">( <span class="hljs-keyword">int</span> TableSize )</span></span><br><span class="hljs-function"></span>&#123;<br>    HashTable H;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span> ( TableSize &lt; MinTableSize )&#123;<br>        <span class="hljs-built_in">Error</span>( <span class="hljs-string">&quot;散列表太小&quot;</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">/* 分配散列表 */</span><br>    H = (HashTable)<span class="hljs-built_in">malloc</span>( <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( struct HashTbl ) );<br>    <span class="hljs-keyword">if</span> ( H == <span class="hljs-literal">NULL</span> )<br>        <span class="hljs-built_in">FatalError</span>( <span class="hljs-string">&quot;空间溢出!!!&quot;</span> );<br>    H-&gt;TableSize = <span class="hljs-built_in">NextPrime</span>( TableSize );<br>        <span class="hljs-comment">/* 分配散列表 Cells */</span><br>    H-&gt;TheCells=(Cell *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( Cell )*H-&gt;TableSize);<br>    <span class="hljs-keyword">if</span>( H-&gt;TheCells == <span class="hljs-literal">NULL</span> )<br>        <span class="hljs-built_in">FatalError</span>( <span class="hljs-string">&quot;空间溢出!!!&quot;</span> );<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; H-&gt;TableSize; i++ )<br>        H-&gt;TheCells[ i ].Info = Empty;<br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br><br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( ElementType Key, HashTable H )</span> <span class="hljs-comment">/*平方探测*/</span></span><br><span class="hljs-function"></span>&#123; Position CurrentPos, NewPos;<br>    <span class="hljs-keyword">int</span> CNum; <span class="hljs-comment">/* 记录冲突次数 */</span><br>    CNum = <span class="hljs-number">0</span>;<br>    NewPos = CurrentPos = <span class="hljs-built_in">Hash</span>( Key, H-&gt;TableSize ); <br>    <span class="hljs-keyword">while</span>( H-&gt;TheCells[ NewPos ].Info != Empty &amp;&amp;<br>    H-&gt;TheCells[ NewPos ].Element != Key ) &#123;<br>    <span class="hljs-comment">/* 字符串类型的关键词需要 strcmp 函数!! */</span><br>        <span class="hljs-keyword">if</span>(++CNum % <span class="hljs-number">2</span>)&#123; <span class="hljs-comment">/* 判断冲突的奇偶次 */</span><br>            NewPos = CurrentPos + (CNum+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*(CNum+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">//这里的操作很巧妙，看下图！</span><br>            <span class="hljs-keyword">while</span>( NewPos &gt;= H-&gt;TableSize )<br>            NewPos -= H-&gt;TableSize;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            NewPos = CurrentPos - CNum/<span class="hljs-number">2</span> * CNum/<span class="hljs-number">2</span>;<span class="hljs-comment">//这里的操作很巧妙，看下图！</span><br>            <span class="hljs-keyword">while</span>( NewPos &lt; <span class="hljs-number">0</span> )<br>            NewPos += H-&gt;TableSize;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NewPos;<br>    &#125;<br></code></pre></div></td></tr></table></figure>
<p><img src="/img/pics/11.2.3.png" srcset="/img/loading.gif" lazyload alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">( ElementType Key, HashTable H )</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* 插入操作 */</span><br>    Position Pos;<br>    Pos = <span class="hljs-built_in">Find</span>( Key, H );<br>    <span class="hljs-keyword">if</span>( H-&gt;TheCells[ Pos ].Info != Legitimate ) &#123;<br>        <span class="hljs-comment">/* 确认在此插入 */</span><br>        H-&gt;TheCells[ Pos ].Info = Legitimate;<br>        H-&gt;TheCells[ Pos ].Element = Key;<br>        <span class="hljs-comment">/*字符串类型的关键词需要 strcpy 函数!! */</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>在开放地址散列表中，删除操作要很小心。 通常只能“懒惰删除”，即需要增加一个“删除标记(Deleted)”，而并不是真正删除它。 以便查找时不会“断链”。其空间可以在下次插入时重用</p>
<h5 id="双散列探测法（Double-Hashing）"><a href="#双散列探测法（Double-Hashing）" class="headerlink" title="双散列探测法（Double Hashing）"></a>双散列探测法（Double Hashing）</h5><p>di 为i*h<sub>2</sub>(key)，h<sub>2</sub>(key)是另一个散列函数探测序列成：h<sub>2</sub>(key)，2h<sub>2</sub>(key)，3h<sub>2</sub>(key)，……</p>
<ul>
<li>对任意的key，h2(key) ≠ 0 </li>
<li>探测序列还应该保证所有的散列存储单元都应该能够被探测到。 选择以下形式有良好的效果：<br>h<sub>2</sub>(key) = p - (key mod p)<br><br>其中：p &lt; TableSize，p、TableSize都是素数。</li>
</ul>
<h5 id="再散列（Rehashing）"><a href="#再散列（Rehashing）" class="headerlink" title="再散列（Rehashing）"></a>再散列（Rehashing）</h5><p>当散列表元素太多（即装填因子 α太大）时，查找效率会下降；</p>
<p>实用最大装填因子一般取 0.5 &lt;= α&lt;= 0.85</p>
<p>当装填因子过大时，解决的方法是加倍扩大散列表，这个过程叫<br>做“再散列（Rehashing）”</p>
<p>注意：扩大散列表后，原来的元素需要全部重新计算</p>
<h5 id="分离链接法✔（Separate-Chaining）"><a href="#分离链接法✔（Separate-Chaining）" class="headerlink" title="分离链接法✔（Separate Chaining）"></a>分离链接法✔（Separate Chaining）</h5><p>分离链接法：将相应位置上冲突的所有关键词存储在同一个单链表中</p>
<p>[例] 设关键字序列为 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89, 94, 21;<br><br>散列函数取为：h(key) = key mod 11；<br><br>用分离链接法处理冲突。<br><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span> &#123;</span><br> <span class="hljs-keyword">int</span> TableSize;<br> List TheLists;<br>&#125; *H;<br></code></pre></div></td></tr></table></figure><br><img src="/img/pics/11.2.4.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>表中有9个结点只需1次查找，5个结点需要2次查找，查找成功的平均查找次数：<br><br> ASLs=（9+5*2）/ 14 ≈ 1.36</p>
<figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">Position</span>, *<span class="hljs-title">List</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br>    ElementType Element;<br>    Position Next;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span> *<span class="hljs-title">HashTable</span>;</span> <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTbl</span> &#123;</span><br>    <span class="hljs-keyword">int</span> TableSize;<br>    List TheLists;<br>&#125;;<br><span class="hljs-function">Position <span class="hljs-title">Find</span><span class="hljs-params">( ElementType Key, HashTable H )</span></span><br><span class="hljs-function"></span>&#123; <br>    Position P;<br>    <span class="hljs-keyword">int</span> Pos;<br><br>    Pos = <span class="hljs-built_in">Hash</span>( Key, H-&gt;TableSize ); <span class="hljs-comment">/*初始散列位置*/</span><br>    P = H-&gt;TheLists[Pos]. Next; <span class="hljs-comment">/*获得链表头*/</span><br>    <span class="hljs-keyword">while</span>( P != <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(P-&gt;Element, Key) )<br>        P = P-&gt;Next;<br>    <span class="hljs-keyword">return</span> P;<br>&#125;<br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/ComputerScience/">ComputerScience</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/13/AlgorithmNotes/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/08/deep_into_operating_system_tsinghua/">
                        <span class="hidden-mobile">深入理解操作系统学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
